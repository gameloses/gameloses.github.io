<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小工知识库</title>
  
  <subtitle>coding wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bytemode.github.io/"/>
  <updated>2018-12-05T12:25:15.853Z</updated>
  <id>https://bytemode.github.io/</id>
  
  <author>
    <name>bytemode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lua表访问跟踪</title>
    <link href="https://bytemode.github.io/2018/12/05/lua%E8%A1%A8%E8%AE%BF%E9%97%AE%E8%B7%9F%E8%B8%AA/"/>
    <id>https://bytemode.github.io/2018/12/05/lua表访问跟踪/</id>
    <published>2018-12-05T12:21:39.000Z</published>
    <updated>2018-12-05T12:25:15.853Z</updated>
    
    <content type="html"><![CDATA[<p>当访问一个 table 或者更新 table 中的某个元素时，lua 首先会在 table 查找是否存在该元素，如果没有，就会查找 table 是否存在 <strong>index(访问) 或者 </strong>newindex(更新) 原方法。以访问为例，首先在 table 中查找某个字段，如果不存在，解释器会去查找 <strong>index 这个原方法，如果仍然没有，返回 nil。所以说，</strong>index 和 __newindex 是在 table 中没有所需访问的 index 时才发挥作用的。    </p><p>根据上面这种思路，如果我们想跟踪一个 table 的操作行为，那么<strong>需要一个空表</strong>，每次对这个空表操作的时候，就会使用 <strong>index 或者 </strong>newindex 这些元方法，在元方法中对原始 table 进行访问和操作，并打印跟踪信息。而之前创建的那个空表，就是代理。</p><pre><code>---------------------------------------------print &quot;跟踪单个表&quot;local _t = {}local mt = {    __newindex = function(t, name, value)        print(&quot;__newindex&quot;, name, value)        --rawset(_t, name, value) --原始访问 不访问原表        _t[name] = value    end,    __index = function(t, name)        print(&quot;__index&quot;, name, value)        --return rawget(_t, name) --原始访问 不访问原表        return _t[name]    end}--a.__index = alocal a = {}   setmetatable(a, mt)a.x = 1print(a.x)---------------------------------------------print &quot;跟踪多个表&quot;local index = {}    --  创建私有索引，即原表在代理表中特殊字段local mt = {    __index = function (t, k)        print(&quot;__index &quot; .. tostring(k))        return t[index][k]    end,    __newindex = function (t, k, v)        print(&quot;__newindex &quot; .. tostring(k) .. &quot; to &quot; .. tostring(v))        t[index][k] = v    end}function track (t)    local proxy = {}    proxy[index] = t    setmetatable(proxy, mt)    return proxyendlocal ori_table = {} --在其他地方创建的原表，对他进行跟踪local _o = track(ori_table)_o[2] = &quot;lua&quot;print(_o[2])</code></pre>]]></content>
    
    <summary type="html">
    
      lua表问跟踪器,使用一个代理器通过——index和newindex特性记录表的访问.跟踪lua表的赋值和取值table.key table.key = value会被跟踪.
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua高级特性</title>
    <link href="https://bytemode.github.io/2018/12/05/lua%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://bytemode.github.io/2018/12/05/lua高级特性/</id>
    <published>2018-12-05T11:52:56.000Z</published>
    <updated>2018-12-05T12:37:33.841Z</updated>
    
    <content type="html"><![CDATA[<ol><li>条件表达式</li></ol><p>实现类似c++中a?b:c的效果。</p><p>a and b or c  – a 为true则返回b or c, a为false则返回false</p><p>(a and b)or c – a 为true则返回</p><ol start="2"><li>弱引用</li></ol><p>元表 __mode字段来设置表k,v是弱引用，被弱引用table引用，垃圾回收时可回收，只要k,v被回收，整个条目会删除。</p><p>Lua采用了基于垃圾收集的内存管理机制，当某个table对象被存放在容器中，而容器的外部不再有任何变量引用该对象，对于这样的对象，Lua的垃圾收集器是不会清理的，因为容器对象仍然引用着他。见如下代码：</p><pre><code>a = {}key = {}a[key] = 1key = {}a[key] = 2collectgarbage()for k,v inpairs(a) do print(v) end --输出1 2</code></pre><p><img src="http://note.youdao.com/src/5DE9982C6F844B22841E66D43A96E67E" alt="复制代码"></p><p>​    在执行垃圾收集之后，table a中的两个key都无法被清理，但是对value等于1的key而言，如果后面的逻辑不会遍历table a的话，那么我们就可以认为该对象内存泄露了。在Lua中提供了一种被称为弱引用table的机制，可以提示垃圾收集器，如果某个对象，如上面代码中的第一个table key，只是被弱引用table引用，那么在执行垃圾收集时可以将其清理。</p><p>​    Lua中的弱引用表提供了3中弱引用模式，即key是弱引用、value是弱引用，以及key和value均是弱引用。不论是哪种类型的弱引用table，只要有一个key或value被回收，那么它们所在的整个条目都会从table中删除。</p><p>​    一个table的弱引用类型是通过其元表的__mode字段来决定的。如果该值为包含字符”k”，那么table就是key弱引用，如果包含”v”，则是value若引用，如果两个字符均存在，就是key/value弱引用。见如下代码：</p><p> 1 a = {}</p><p> 2 b = {__mode = “k”}</p><p> 3setmetatable(a,b)</p><p> 4 key = {}</p><p> 5 a[key] = 1</p><p> 6 key = {}</p><p> 7 a[key] = 2</p><p> 8collectgarbage()</p><p> 9for k,v inpairs(a) do</p><p>10print(v)</p><p>11end</p><p>12–仅仅输出2</p><p><img src="http://note.youdao.com/src/5DE9982C6F844B22841E66D43A96E67E" alt="复制代码"></p><p>​    在上面的代码示例中，第一个key在被存放到table a之后，就被第二个key的定义所覆盖，因此它的唯一引用来自key弱引用表。事实上，这种机制在Java中也同样存在，Java在1.5之后的版本中也提供了一组弱引用容器，其语义和Lua的弱引用table相似。</p><p>​    最后需要说明的是，Lua中的弱引用表只是作用于table类型的变量，对于其他类型的变量，如数值和字符串等，弱引用表并不起任何作用。</p><p><img src="http://note.youdao.com/src/3D93E1809F1242B98CB49B56896F7F36" alt="img"></p><p><img src="http://note.youdao.com/src/0EEB7D1771464F09AB998AE5C04D31EC" alt="img"></p><p><img src="http://note.youdao.com/src/0CB44C0AD62A43568F0D6E138877BD8C" alt="img"></p><p><img src="http://note.youdao.com/src/78D8E70FC09A44B987325BADE5349886" alt="img"></p><p><img src="http://note.youdao.com/src/7D22CEC95D2848599A731E5703DAEB01" alt="img"></p><p>2.尾递归</p><p>什么是尾递归</p><p>尾递归的写法只是具备了使当前函数在调用下一个函数前把当前占有的栈销毁，但是会不会真的这样做，是要具体看编译器是否最终这样做。</p><p>什么是尾递归呢?(tail recursion), 顾名思议，就是一种“不一样的”递归，说到它的不一样，就得先说说一般的递归。对于一般的递归，比如下面的求阶乘，教科书上会告诉我们，如果这个函数调用的深度太深，很容易会有爆栈的危险。</p><p><img src="http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336" alt="复制代码"></p><p>// 先不考虑溢出问题int func(int n) {     if (n &lt;= 1) return1;      return (n * func(n-1)); }</p><p><img src="http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336" alt="复制代码"></p><p>原因很多人的都知道，让我们先回顾一下函数调用的大概过程：</p><p>1）调用开始前，调用方（或函数本身）会往栈上压相关的数据，参数，返回地址，局部变量等。</p><p>2）执行函数。</p><p>3）清理栈上相关的数据，返回。</p><p>因此，在函数 A 执行的时候，如果在第二步中，它又调用了另一个函数 B，B 又调用 C…. 栈就会不断地增长不断地装入数据，当这个调用链很深的时候，栈很容易就满 了，这就是一般递归函数所容易面临的大问题。</p><p>而尾递归在某些语言的实现上，能避免上述所说的问题，注意是某些语言上，尾递归本身并不能消除函数调用栈过长的问题，那什么是尾递归呢？在上面写的一般递归函数 func() 中，我们可以看到，func(n)  是依赖于 func(n-1) 的，func(n) 只有在得到 func(n-1) 的结果之后，才能计算它自己的返回值，因此理论上，在 func(n-1) 返回之前，func(n)，不能结束返回。因此func(n)就必须保留它在栈上的数据，直到func(n-1)先返回，而尾递归的实现则可以在编译器的帮助下，消除这个限制：</p><p><img src="http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336" alt="复制代码"></p><p>// 先不考虑溢出int tail_func(int n, int res) {      if (n &lt;= 1) return res;       return tail_func(n - 1, n * res); }  // 像下面这样调用 tail_func(10000000000, 1);</p><p><img src="http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336" alt="复制代码"></p><p>从上可以看到尾递归把返回结果放到了调用的参数里。这个细小的变化导致，tail_func(n, res)不必像以前一样，非要等到拿到了tail_func(n-1, n<em>res)的返回值，才能计算它自己的返回结果 – 它完全就等于tail_func(n-1, n</em>res)的返回值。因此理论上：tail_func(n)在调用tail_func(n-1)前，完全就可以先销毁自己放在栈上的东西。</p><p>这就是为什么尾递归如果在得到编译器的帮助下，是完全可以避免爆栈的原因：每一个函数在调用下一个函数之前，都能做到先把当前自己占用的栈给先释放了，尾递归的调用链上可以做到只有一个函数在使用栈，因此可以无限地调用！</p><p>所谓尾调用，就是一个函数返回另一个函数的返回值：</p><p>复制代码代码如下:</p><p>function f()</p><p>…</p><p>return g()</p><p>end</p><p>因为调用g()后，f()中不再执行任何代码，所以不需要保留f()的调用桟信息；Lua做了这样的优化，称为”尾调用消除”，g()返回后，控制点直接返回到调用f()的地方。</p><p>这种优化对尾递归非常有益，通常递归意味着调用桟的不断增长，甚至可能造成堆栈溢出；而尾递归提供了优化条件，编译器可以优化掉调用桟</p><p><img src="http://note.youdao.com/src/0ED3D9C5EDFC4F01A2DFB30A52209CCF" alt="img"></p><p>3.元表相关</p><p>table存在两种行为：查询和修改（赋值），通过元方法<strong>index和</strong>newindex来改变table的这两种行为。</p><p>__index主要用于table的查询</p><p>table[key] 的访问过程，首先检查table表中是否存在key的字段，如果有则返回，否则检查是否有__index的元方法，没有返回nil,有则查找元方法。</p><p>__index元方法可以是一个函数，还可以是一个table。如果是一个函数，则以table和不存在的key作为参数方位该函数，</p><p>例如：__index = function(t,key)</p><p>如果是一个table时，就以相同的方式来访问这个table（即传入key访问元方法的table，如果存在则放回值，反之返回nil）</p><p>例如：__index = tab –此时会返回tab[key]的值</p><p>__index可以很好的实现具有默认值的table</p><p>function setDefaultValues(t,d)</p><p>​    local mt = {__index = function() return d end}</p><p>​    setmetatable(t, mt)</p><p>end</p><p>tab = {x=10,y=20}</p><p>print(tab.x ,tab.y,tab.z)    –由于没有设置元方法则为nil</p><p>setDefaultValues(tab,100)    –设置默认值（设置__index元方法）</p><p>print(tab.z)            –检查到有__index的元方法则返回默认值</p><p>__newindex主要用于table的更新</p><p>当对table中不存在的索引赋值时，解释器就会查找__newindex元方法。如果有这个元方法，就调用这个元方法，而不是执行复制。如果这个元方法是一个table，解释器就在table中进行赋值，而不是对原来的table。</p><p>local k = {}</p><p>local mt = {</p><p>​    __newindex = k</p><p>}</p><p>local t = {}</p><p>setmetatable(t, mt)</p><p>print(“赋值前：”)</p><p>for k,v in pairs(k) do</p><p>​    print(k ,v)</p><p>end</p><p>t[1] = 20</p><p>print(“赋值后：t表中的值:”)</p><p>for k,v in pairs(t) do</p><p>​    print(k ,v)</p><p>end</p><p>print(“赋值后：k表中的值:”)</p><p>for k,v in pairs(k) do</p><p>​    print(k ,v)</p><p>end</p><p>4.class的实现</p><p>子类在定义时复制所有基类的方法，在实例化时将该类作为metatable的__index赋值给实例。这就是cocos2dx里面的lua class的实现。</p><p>function class(classname, super)</p><p>​     local cls = {}</p><p>​     if super then –复制基类方法</p><p>​        cls = {}</p><p>​        for k,v in pairs(super) do cls[k] = v end</p><p>​        cls.super = super</p><p>​    else</p><p>​        cls = {ctor = function() end}</p><p>​    end</p><p>​    cls.__cname = classname</p><p>​    cls.__index = cls</p><p>​    function cls.new(…) –实例化</p><p>​        local instance = setmetatable({}, cls)</p><p>​        instance.class = cls</p><p>​        instance:ctor(…)</p><p>​        return instance</p><p>​    end</p><p>​    return cls</p><p>end</p><p>5.闭包实现</p><p>Lua使用闭包的扁平表示:</p><p>GC头部包含了垃圾回收信息；</p><p>闭包包含了一个指向原型的指针，原型包含了函数的所有静态信息：主要部分是函数编译之后的代码，其余包括参数个数、调试信息和其他类似的数据;</p><p>闭包还包含0个或多个指向upvalue的指针，每个upvalue表示一个由闭包使用的非局部变量.</p><p><img src="http://note.youdao.com/src/FF6FBB6589004740A5B86749709A7A3E" alt="img"></p><p> Lua闭包实现的核心部件是upvalue结构，它表示了一个闭包和一个变量的连接.</p><p> 用于访问upvalue的虚拟机指令有2条：GETUPVALUE将一个upvalue的值复制到寄存器；SETUPVALUE将一个寄存器的值复制到upvalue。</p><p>　一个upvalue有两种状态：open和closed。当一个upvalue被创建时，它是open的，并且它的指针指向Lua栈中对应的变量。当Lua关闭了一个upvalue，upvalue指向的值被复制到upvalue结构内部，并且指针也相应进行调整</p><p>6.table，string的实现</p><p><img src="http://note.youdao.com/src/F989FAE3253F481F82FC84C8284ADBE7" alt="img"></p><p>lua中对基础数据类型使用统一的数据结构TValue表示，value_表示值，tt_表示数据类型。由此可知Value是一个union结构</p><p>对于nil,boolean,lightuserdata,number,cfunction这些数据类型的值都是直接存放在TValue中，其他类型的数据都用GCObject来表示，TValue中只是保存GCObject结构的指针</p><p>TString</p><ol><li>/* </li><li>** creates a new string object </li><li>*/  </li><li>static TString <em>createstrobj (lua_State </em>L, const char *str, size_t l,  </li><li>​                              int tag, unsigned int h, GCObject **list) {  </li><li>TString *ts;  </li><li>size_t totalsize;  /<em> total size of TString object </em>/  </li><li>totalsize = sizeof(TString) + ((l + 1) * sizeof(char));  </li><li>ts = &amp;luaC_newobj(L, tag, totalsize, list, 0)-&gt;ts;  </li><li>ts-&gt;tsv.len = l;  </li><li>ts-&gt;tsv.hash = h;  </li><li>ts-&gt;tsv.extra = 0;  </li><li>memcpy(ts+1, str, l*sizeof(char));  </li><li>((char <em>)(ts+1))[l] = ‘\0’;  /</em> ending 0 */  </li><li>return ts;  </li><li>}  </li></ol><p><img src="http://note.youdao.com/src/EC2292CD831B47AD975575C6691C41EB" alt="img"></p><p>​                                      图1-2</p><p>   从代码可以看出，字符串在lua的内存分配结构，如图1-2所示。lua字符串都自动加上结束符。</p><p>C代码  </p><ol><li>/* </li><li>** new string (with explicit length) </li><li>*/  </li><li>TString <em>luaS_newlstr (lua_State </em>L, const char *str, size_t l) {  </li><li>if (l &lt;= LUAI_MAXSHORTLEN)  /<em> short string? </em>/  </li><li>​    return internshrstr(L, str, l);  </li><li>else {  </li><li>​    if (l + 1 &gt; (MAX_SIZET - sizeof(TString))/sizeof(char))  </li><li>​      luaM_toobig(L);  </li><li>​    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed, NULL);  </li><li>}  </li><li>}  </li></ol><p>​    在实际中对字符串的使用大部分都是很短的，所以lua保存字符串分为短字符串和长字符串，短字符串都保存在全局的字符串hash表中，长字符串则放在全局的可gc对象列表中。</p><p>   static TString <em>internshrstr (lua_State </em>L, const char *str, size_t l) {  </p><ol><li>GCObject *o;  </li><li>global_State *g = G(L);  </li><li>unsigned int h = luaS_hash(str, l, g-&gt;seed);  </li><li>for (o = g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  </li><li>​       o != NULL;  </li><li>​       o = gch(o)-&gt;next) {  </li><li>​    TString *ts = rawgco2ts(o);  </li><li>​    if (h == ts-&gt;tsv.hash &amp;&amp;  </li><li>​        l == ts-&gt;tsv.len &amp;&amp;  </li><li>​        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {  </li><li>​      if (isdead(G(L), o))  /<em> string is dead (but was not collected yet)? </em>/  </li><li>​        changewhite(o);  /<em> resurrect it </em>/  </li><li>​      return ts;  </li><li>​    }  </li><li>}  </li><li>return newshrstr(L, str, l, h);  /<em> not found; create a new string </em>/  </li><li>}  </li></ol><p>​    短字符串的hash表采用开放寻址hash算法，在处理一个短字符串的时候对首先判断字符串在hash表中是否已存在，存在则直接返回其地址；不存在则创建该字符串，并求出其hash值。长字符串则都重新分配内存保存。因此在对比两个字符串是否相等时，短字符串只要比较地址是否相等就行了，而对于长字符串则需要对比所有字符。由此可见lua中对于短字符串的处理很高效，一般用于字符串的比较，或者用作table的key。</p><p>  Table</p><p><img src="http://note.youdao.com/src/16471361C7A045F88883BCA7216834EE" alt="img"></p><p>lua中的table是key-value的形式来存放数据的，table分为两部分：数组部分array和hash部分。array和sizearray为数组部分，node，lastfree，lsizenode为hash部分。</p><p>数组段和 hash 段两个部分。数字 key 一般放在数组段中，没有初始化过的 key 值全部设置为 nil 。当数字 key 过于离散的时候，部分较大的数字 key 会被移到 hash段中去。</p><p>key为你init</p><p>当key小于数组长度时，则直接返回数组中的值，否则计算key的hash值，从表的hash部分查找key的值。</p><p>当key为string</p><p>统一调用mainposition获取其hash值对应的散列地址.</p><p>当给table的key赋值的时候，会先查找key是否存在，如果存在则对value重新赋值，如果不存在则表示key也不存在，会调用luaH_newkey创建key，然后再对value赋值。在创建key的时候如果table的大小不够会触发rehash对表进行扩大。</p><p>7.gc相关</p><p>采用垃圾回收机制对所有的lua对象(GCObject)进行管理。Lua虚拟机会定期运行GC，释放掉已经不再被被引用到的lua对象。</p><p>基本算法【标记清除】</p><p>基本的垃圾回收算法被称为”mark-and-sweep”算法。算法本身其实很简单。</p><p>1.系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。</p><p>2.root集合代表着已知的系统级别的对象引用。</p><p>3.从root集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。</p><p>我们可以将所有对象分成三个状态：</p><ol><li>White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。</li><li>Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。</li><li>Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用。</li></ol><p>基本的算法可以描述如下：</p><ol><li>当前所有对象都是White状态;  </li><li>将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </li><li>while(Gray集合不为空)  </li><li>{  </li><li>​    从Gray集合中移除一个对象O，并将O设置成Black状态;  </li><li>​    for(O中每一个引用到的对象O1) {  </li><li>​        if(O1在White状态) {  </li><li>​            将O1从White设置成Gray，并放到到Gray集合中；  </li><li>​        }  </li><li>​    }  </li><li>}  </li><li>for(任意一个对象O){  </li><li>​    if(O在White状态)  </li><li>​        销毁对象O;  </li><li>​    else  </li><li>​        将O设置成White状态;  </li><li>}  </li></ol><p>Incremental Garbage Collection</p><p>上面的算法如果一次性执行，在对象很多的情况下，会执行很长时间，严重影响程序本身的响应速度。其中一个解决办法就是，可以将上面的算法分步执行，这样每个步骤所耗费的时间就比较小了。我们可以将上述算法改为以下下几个步骤。</p><p>首先标识所有的root对象：</p><ol><li>当前所有对象都是White状态;  </li><li>将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  </li></ol><p>遍历访问所有的gray对象。如果超出了本次计算量上限，退出等待下一次遍历:</p><ol><li>while(Gray集合不为空,并且没有超过本次计算量的上限){  </li><li>​    从Gray集合中移除一个对象O，并将O设置成Black状态;  </li><li>​    for(O中每一个引用到的对象O1) {  </li><li>​        if(O1在White状态) {  </li><li>​            将O1从White设置成Gray，并放到到Gray集合中；  </li><li>​        }  </li><li>​    }  </li><li>}  </li></ol><p>销毁垃圾对象：</p><ol><li>for(任意一个对象O){  </li><li>​    if(O在White状态)  </li><li>​        销毁对象O;  </li><li>​    else  </li><li>​        将O设置成White状态;  </li><li>}  </li></ol><p>在每个步骤之间，由于程序可以正常执行，所以会破坏当前对象之间的引用关系。black对象表示已经被扫描的对象，所以他应该不可能引用到一个white对象。当程序的改变使得一个black对象引用到一个white对象时，就会造成错误。解决这个问题的办法就是设置barrier。barrier在程序正常运行过程中，监控所有的引用改变。如果一个black对象需要引用一个white对象，存在两种处理办法：</p><ol><li>将white对象设置成gray，并添加到gray列表中等待扫描。这样等于帮助整个GC的标识过程向前推进了一步。</li><li>将black对象该回成gray，并添加到gray列表中等待扫描。这样等于使整个GC的标识过程后退了一步。</li></ol><p>这种垃圾回收方式被称为”Incremental Garbage Collection”(简称为”IGC”，Lua所采用的就是这种方法。使用”IGC”并不是没有代价的。IGC所检测出来的垃圾对象集合比实际的集合要小，也就是说，有些在GC过程中变成垃圾的对象，有可能在本轮GC中检测不到。不过，这些残余的垃圾对象一定会在下一轮GC被检测出来，不会造成泄露。</p>]]></content>
    
    <summary type="html">
    
      涉及lua原表、尾递归、弱引用表、luastate、gc、源码解析、记录lua表访问赋值、lua面向对象等
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua和c交互原理</title>
    <link href="https://bytemode.github.io/2018/12/05/lua%E5%92%8Cc%E4%BA%A4%E4%BA%92/"/>
    <id>https://bytemode.github.io/2018/12/05/lua和c交互/</id>
    <published>2018-12-05T11:20:11.000Z</published>
    <updated>2018-12-05T11:52:34.908Z</updated>
    
    <content type="html"><![CDATA[<p>luastate</p>]]></content>
    
    <summary type="html">
    
      lua和c语言的交互,两者相互调用的原理.
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>git重点用法</title>
    <link href="https://bytemode.github.io/2018/12/05/git%E9%87%8D%E7%82%B9%E7%94%A8%E6%B3%95/"/>
    <id>https://bytemode.github.io/2018/12/05/git重点用法/</id>
    <published>2018-12-05T05:46:52.000Z</published>
    <updated>2018-12-05T12:12:59.103Z</updated>
    
    <content type="html"><![CDATA[<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><img src="/2018/12/05/git重点用法/gitflow.png" title="git flow"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>放入暂存区<br><code>git add .</code><br><code>git add file</code></p></li><li><p>提交到仓库<br><code>git commit -m &#39;log&#39;</code></p></li><li><p>撤销工作区修改<br><code>git checkout -- file</code><br><code>git checkout .</code></p></li><li><p>暂存区回退到工作区<br><code>git reset HEAD file</code></p></li><li><p>Reset回退commit<br>回滚commit,工作区暂存区也改变<br><code>git reset --hard  commitid</code><br>只回滚commit,工作区暂存区代码没有改变<br><code>git reset --soft commitid</code><br>回滚commit,暂存区改变,工作区不变<br><code>git reset -mixed commitid</code> 等同 <code>git reset commitid</code></p></li><li><p>revert回退commit</p><p><code>git revert commit</code></p><p>但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在.</p><p>而reset是指将HEAD指针指到指定提交,历史记录中不会出现放弃的提交记录.</p></li><li><p>commit id查看<br><code>git log</code><br><code>git reflog</code></p></li><li><p>git push<br><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>推送本地master分支到远程origin主机的master分支，后者不存在就创建<br><code>git push origin master</code> 省略了远程分支名</p></li><li><p>git pull<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>远程主机origin的master分支拉取过来，与本地的brantest分支合并:<br><code>git pull origin master:brantest</code><br>将远程origin主机的master分支拉取过来和本地的当前分支进行合并<br><code>git pull origin master</code></p><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4></li><li>本地代码回滚到commitid<br><code>git reset --hard commitid</code></li><li>远程代码回回滚<br>方法1：<br>回滚后强制推送本地到远程<br><code>git reset --hard commitid</code><br><code>git push origin branch -f</code><br>方法2：<br>且分支在分支上reset然后删除远程分支，使用本地分支重新远程分支<pre><code>git checkout the_branchgit branch bkgit pullgit reset --hard th_commit_idgit push origin :the_branch 删除远程then_branchgit push origin the_branch</code></pre></li></ul><h4 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h4><ul><li><p>删除某次提交</p><p><code>git rebase -i commitid^</code></p><p>在命令编辑里边把某次提交之前的内容改为drop.退出交互模式,就会删除相应commit.之后强制推送就ok.</p></li><li><p>修改某次提交</p><p><code>git rebase -i commitid^</code></p><p>在编辑框中把需要修改的某次提交所在commit之前的pick改为edit然后保存退出.之后做出修改,完成之后执行如下命令：</p><pre><code>git add .git commit --amendgit rebase --continue</code></pre></li></ul><h4 id="子仓库"><a href="#子仓库" class="headerlink" title="子仓库"></a>子仓库</h4><p>主要用于工程中以来的第三方库，第三方库是独立的git仓库可以自行管理.</p><ul><li><p>添加submodule</p><p><code>git submodule add 仓库地址 localpath</code></p><p>会在.gitmodules和.git/config中添加submodule路径和对应的仓库库地址</p></li><li><p>clone父仓库之后更新子仓库</p><pre><code>git submodule initgit submodule update</code></pre></li><li><p>submodule修改后再localpath中 add commit push</p></li><li><p>删除submodule</p><p>删除.gitmodules和.git.config中的submodule信息;git rm –cached localpath.  </p><h4 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h4></li><li><p>git merge</p><p>$ git merge issueFix</p><p>如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:test.c</p><p>printf (“test1″);</p><p>=======</p><p>printf (“test2″);</p><p>>&gt;&gt;&gt;&gt;&gt;&gt; issueFix:test.c</p><p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在 issueFix 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><p>printf (“test2″);</p><p>这个解决方案各采纳了两个分支中的一部分内容，而且删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，和&gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决（resolved）。</p></li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><ul><li><p>创建分支</p><p><code>git branch bname</code></p></li><li><p>切换分支</p><p>git checkout bname</p></li><li><p>创建并切分支</p><p>git checkout -b bname</p></li><li><p>git checkout -b 本地分支名x origin/远程分支名x</p><p><code>git checkout -b dev origin/dev</code></p><p>远程分支dev切分支到本地dev分支</p></li><li><p>查看分支</p><p>git branch -av</p></li></ul>]]></content>
    
    <summary type="html">
    
      涉及git工作流程,实用方法.分支合并回滚子模块等.注重实践中常用的方法流程,同时对原理稍作注解.git的实践说明书.
    
    </summary>
    
      <category term="git" scheme="https://bytemode.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://bytemode.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx性能优化</title>
    <link href="https://bytemode.github.io/2018/12/03/cocos2dx%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://bytemode.github.io/2018/12/03/cocos2dx性能优化/</id>
    <published>2018-12-03T08:14:02.000Z</published>
    <updated>2018-12-03T08:33:50.766Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/03/cocos2dx性能优化/hexo_github.png" title="ceshi">]]></content>
    
    <summary type="html">
    
      cocos2dx性能优化,主要是针对帧率、内存、drawcall优化.
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>golang服务器开发</title>
    <link href="https://bytemode.github.io/2018/11/30/golang/"/>
    <id>https://bytemode.github.io/2018/11/30/golang/</id>
    <published>2018-11-30T07:55:25.000Z</published>
    <updated>2018-12-03T08:36:36.632Z</updated>
    
    <content type="html"><![CDATA[<h4 id="golang开发笔记"><a href="#golang开发笔记" class="headerlink" title="golang开发笔记"></a>golang开发笔记</h4><p>涉及内容包括web服务器、游戏服务器的开始使用,包括一些开元的golang软件的解读.</p><p>leaf goworld 等教程. 同时会有一些游戏demo展示.</p><blockquote><p>跳转链接：</p></blockquote><p><a href="https://gameloses.github.io/golang/">golang深度解析</a></p><p><a href="https://gameloses.github.io/golang/">leaf解析</a></p><p><a href="https://gameloses.github.io/golang/">goworld解析</a></p><p><a href="https://gameloses.github.io/golang/">https://gameloses.github.io/golang/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;golang开发笔记&quot;&gt;&lt;a href=&quot;#golang开发笔记&quot; class=&quot;headerlink&quot; title=&quot;golang开发笔记&quot;&gt;&lt;/a&gt;golang开发笔记&lt;/h4&gt;&lt;p&gt;涉及内容包括web服务器、游戏服务器的开始使用,包括一些开元的golang软
      
    
    </summary>
    
      <category term="golang" scheme="https://bytemode.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://bytemode.github.io/tags/golang/"/>
    
      <category term="go" scheme="https://bytemode.github.io/tags/go/"/>
    
      <category term="游戏服务器" scheme="https://bytemode.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="leaf" scheme="https://bytemode.github.io/tags/leaf/"/>
    
      <category term="goworld" scheme="https://bytemode.github.io/tags/goworld/"/>
    
  </entry>
  
  <entry>
    <title>gitbook使用</title>
    <link href="https://bytemode.github.io/2018/11/28/gitbook/"/>
    <id>https://bytemode.github.io/2018/11/28/gitbook/</id>
    <published>2018-11-28T10:23:58.000Z</published>
    <updated>2018-12-03T07:13:36.182Z</updated>
    
    <content type="html"><![CDATA[<p>Gitbook的搭建</p><p>gitbook是一个npm工具使用的是git和markdown技术支持构建多种格式的ebook.</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install gitbook-cligitbook -V</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>创建一个空目录,生成README.md SUMMARY.md两个文件,使用如下命令</p><p><code>gitbook init</code></p><ul><li>README.md —— 书籍的介绍写在这个文件里</li><li>SUMMARY.md —— 书籍的目录结构在这里配置</li></ul><h4 id="编辑电子书"><a href="#编辑电子书" class="headerlink" title="编辑电子书"></a>编辑电子书</h4><p>目录编辑</p><pre><code>* [第一章](section1/README.md)    * [第一节](section1/example1.md)    * [第二节](section1/example2.md)* [第二章](section2/README.md)    * [第一节](section2/example1.md)</code></pre><p>目录支持三级，目录中可以带链接.名录名+链接的方式.链接即相对md文件名字.</p><h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><p><code>gitbook serve</code></p><h4 id="发布电子书"><a href="#发布电子书" class="headerlink" title="发布电子书"></a>发布电子书</h4><p><code>gitbook build</code></p><p>在本地目录生成_book静态网页电子书</p><h4 id="生成电子书"><a href="#生成电子书" class="headerlink" title="生成电子书"></a>生成电子书</h4><p>安装插件calibre. <a href="https://link.jianshu.com/?t=https://calibre-ebook.com/download" target="_blank" rel="noopener">https://calibre-ebook.com/download</a></p><p>添加环境变量：</p><pre><code>cd ~vim .bash_profilePATH = /Applications/calibre.app/Contents/MacOS:${PATH}&quot;source .bash_profile</code></pre><p>生成电子书命令如下：</p><pre><code>gitbook pdfgitbook mobi</code></pre><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>利用gh-pages将gitbook生成的静态网页发布到github pages上.</p><ol><li><p>安装gh-pages <code>npm install g gh-pages</code> </p></li><li><p>在github上创建仓库例如cocos2dx</p></li><li><p>将书籍源码push到仓库的master分支</p></li><li><p>将_book发布到github仓库的gh-pages分支</p><pre><code>gitbook buildgh-pages -d _book</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gitbook的搭建&lt;/p&gt;
&lt;p&gt;gitbook是一个npm工具使用的是git和markdown技术支持构建多种格式的ebook.&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h4
      
    
    </summary>
    
      <category term="web" scheme="https://bytemode.github.io/categories/web/"/>
    
    
      <category term="Gitbook" scheme="https://bytemode.github.io/tags/Gitbook/"/>
    
  </entry>
  
  <entry>
    <title>github上搭建hexo博客</title>
    <link href="https://bytemode.github.io/2018/11/23/hexo%E6%90%AD%E5%BB%BAgithubblog/"/>
    <id>https://bytemode.github.io/2018/11/23/hexo搭建githubblog/</id>
    <published>2018-11-23T12:51:11.000Z</published>
    <updated>2018-12-03T08:31:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>打算在github上搭建起hexo博客和gitbook,主要记录一些技术积累.涉及游戏开前后端区块链等.解读一些开源的库.像skynet,pomelo,kbengine,coco2dx,cocos creator,ETH,goworld等.本文记录一下搭建hexo的过程纯属经验之谈.</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><img src="/2018/11/23/hexo搭建githubblog/hexo_github.png" title="基本流程"><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><ul><li><p>node.js</p><blockquote><p>mac下注意npm对user/local的权限问题</p></blockquote></li><li><p>git  </p><blockquote><p>保证使用ssh和github进行认证测试通过：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>.</p></blockquote></li><li><p>创建github仓库</p><blockquote><p>例如github用户名为gameloses则仓库名为:gameloses.github.io</p></blockquote></li></ul><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><pre><code>npm install -g hexo-clihexo init blogcd blognpm install</code></pre><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>在 _config.yml 中修改大部份的配置  </p><ul><li><p>配置部署参数</p><pre><code>deploy:  type: git  repository: git@github.com:gameloses/gameloses.github.io.git  branch: master</code></pre></li><li><p>安装部署插件      </p><pre><code>cd blognpm install hexo-deployer-git --save</code></pre></li><li><p>安装首页文章显示插件</p><p><code>npm install --save hexo-auto-excerpt</code></p><p>设置显示字数：</p><p>auto_excerpt:</p><p>  enable: true</p><p>  length: 300</p></li><li><p>手动添加文章描述</p><p><code>npm install --save hexo-front-matter-excerpt</code></p><p>在文章标题描述中添加：excerpt: xxxxxxxx 或者文章中添加 “<a id="more"></a>“</p></li><li><p>文章资源文件夹</p><pre><code>post_asset_folder: true{% asset_img example.jpg This is an example image %}</code></pre></li><li><p>发布上传博客<br><code>hexo d -g</code></p></li><li><p>常见的其他命令</p><pre><code>hexo s == hexo server   //启动本地服务hexo g == hexo generate //生成hexo d == hexo deploy   //发布hexo n == hexo new      //新建</code></pre></li></ul><h4 id="书写文章"><a href="#书写文章" class="headerlink" title="书写文章"></a>书写文章</h4><p><code>hexo new post &quot;文章名字&quot;</code><br>使用模板生成文章</p><pre><code>title: cocos2dx引擎架构概述comments: truedate: 2018-11-23 20:51:11tags:categories:</code></pre><h4 id="分类标签"><a href="#分类标签" class="headerlink" title="分类标签"></a>分类标签</h4><p>为了使分类标签生效需要生成两个page文件</p><pre><code>hexo new page categorieshexo new page tags</code></pre><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>一个模仿github样式的主题</p><pre><code>git clone git@github.com:sabrinaluo/hexo-theme-replica.git themes/replica</code></pre><p>Set theme: replica in _config.yml (the one in your root folder)     </p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>安装rss<br><code>npm install hero-generator-feed</code><br>配置如下：</p><pre><code>plugin:- hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20rss: /atom.xml</code></pre><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>添加WWW和@主机记录，记录类型为CNAME.</p><p> 在source目录下创建CNAME文件，文件内容为域名例如：chuangyutime.com</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ol><li>mac下node安装好之后使用npm安装全局包会出现usr/local目录权限读写问题？<br><code>sudo chown -R $USER /usr/local</code><br>修改权限之后使用ls -l /usr/local 查看权限</li><li>分类标签404？<br>需要创建两个page categories、tags</li><li>vscode 编写markdown回退文本之后以后存在特殊的bs字符问题？<br>显示隐藏字符 <code>&quot;editor.renderControlCharacters&quot;: true</code><br>安装插件：<code>Remove backspace control character</code><br>开启设置：<code>&quot;editor.formatOnType&quot;: true 在被设定的情况下，进行变换时;输入时启动</code></li></ol>]]></content>
    
    <summary type="html">
    
      使用hexo搭建博客并且部署在github上,在过程中遇到很多问题,重要插件安装文章模板生成还有很坑的域名绑定问题.
    
    </summary>
    
      <category term="web" scheme="https://bytemode.github.io/categories/web/"/>
    
    
      <category term="hexo" scheme="https://bytemode.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
