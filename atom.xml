<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小工知识库</title>
  
  <subtitle>coding wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bytemode.github.io/"/>
  <updated>2018-12-31T07:50:12.394Z</updated>
  <id>https://bytemode.github.io/</id>
  
  <author>
    <name>sunfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opengl绘制三角形</title>
    <link href="https://bytemode.github.io/2018/12/28/opengl%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>https://bytemode.github.io/2018/12/28/opengl绘制三角形/</id>
    <published>2018-12-28T07:15:06.000Z</published>
    <updated>2018-12-31T07:50:12.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul></blockquote><h4 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h4><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p><p>2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</p><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且并行执行。GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的。</p><p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。蓝色部分代表的是可以注入自定义的着色器的部分。</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_pipeline.png" alt="img"></p><p>图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。概括性地解释一下渲染管线的每个部分。</p><h5 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h5><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置和一些颜色值组成的吧。</p><p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p><h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><h5 id="图元组装"><a href="#图元组装" class="headerlink" title="图元组装"></a>图元组装</h5><p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p><h5 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h5><p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p><h5 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h5><p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><h5 id="测试混合"><a href="#测试混合" class="headerlink" title="测试混合"></a>测试混合</h5><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把<strong>所有的</strong>3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的<strong>标准化设备坐标</strong>(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p><pre><code>float vertices[] = {    -0.5f, -0.5f, 0.0f,     0.5f, -0.5f, 0.0f,     0.0f,  0.5f, 0.0f};</code></pre><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。</p><p><strong>标准化设备坐标(Normalized Device Coordinates, NDC)</strong></p><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_ndc.png" alt="NDC"></p><p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p><p>你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p><p><strong>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点</strong>。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><p>顶点缓冲对象是OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</p><pre><code>unsigned int VBO;glGenBuffers(1, &amp;VBO);</code></pre><p>OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲(VBO)绑定到GL_ARRAY_BUFFER目标上：</p><pre><code>glBindBuffer(GL_ARRAY_BUFFER, VBO);  </code></pre><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p><pre><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code>sizeof</code>计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。下面我们会创建一个顶点和片段着色器来真正处理这些数据。</p><h4 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。我们使用着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。</p><p>我们需要做的第一件事是用着色器语言GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码：</p><pre><code>#version 330 corelayout (location = 0) in vec3 aPos;void main(){    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);}</code></pre><p>可以看到，GLSL看起来很像C语言。每个着色器都起始于一个版本声明。</p><p>下一步，使用<code>in</code>关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个<code>float</code>分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个<code>vec3</code>输入变量aPos。我们同样也通过<code>layout (location = 0)</code>设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。</p><p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的gl_Position变量，它在幕后是<code>vec4</code>类型的。在main函数的最后，我们将gl_Position设置的值会成为该顶点着色器的输出。由于我们的输入是一个3分量的向量，我们必须把它转换为4分量的。我们可以把<code>vec3</code>的数据作为<code>vec4</code>构造器的参数，同时把<code>w</code>分量设置为<code>1.0f</code>（我们会在后面解释为什么）来完成这一任务。</p><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内。</p><h5 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h5><p>我们已经写了一个顶点着色器源码（储存在一个C的字符串中），但是为了能够让OpenGL使用它，我们必须在运行时动态编译它的源码。</p><p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code>unsigned int</code>，然后用glCreateShader创建这个着色器：</p><pre><code>unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);</code></pre><p>我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><pre><code>glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader);</code></pre><p>glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为<code>NULL</code>。</p><p>你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p><pre><code>int  success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</code></pre><p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</p><pre><code>if(!success){    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;}</code></pre><p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h4 id="片段着色器-1"><a href="#片段着色器-1" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>片段着色器所做的是计算像素最后的颜色输出。</p><p>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p><pre><code>#version 330 coreout vec4 FragColor;void main(){    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);} </code></pre><p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用<code>out</code>关键字声明输出变量，这里我们命名为FragColor。下面，我们将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的<code>vec4</code>赋值给颜色输出。</p><p>编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</p><pre><code>unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader);</code></pre><p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p><h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><p>创建一个程序对象很简单：</p><pre><code>unsigned int shaderProgram;shaderProgram = glCreateProgram();</code></pre><p>glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p><pre><code>glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);</code></pre><p>代码应该很清楚，我们把着色器附加到了程序上，然后用glLinkProgram链接。</p><p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</p><pre><code>glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) {    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);    ...}</code></pre><p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><pre><code>glUseProgram(shaderProgram);</code></pre><p>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</p><p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p><pre><code>glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><p>现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。</p><h4 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h4><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p><p>我们的顶点缓冲数据会被解析为下面这样子：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_vertex_attribute_pointer.png" alt="img"></p><ul><li>位置数据被储存为32位浮点值。</li><li>每个位置包含3个这样的值。</li><li>在这3个值之间没有空隙。这几个值在数组中紧密排列(Tightly Packed)。</li><li>数据中第一个值在缓冲开始的位置。</li></ul><p>有了这些信息我们就可以<strong>使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据</strong>（应用到逐个顶点属性上）了：</p><pre><code>//解析顶点数据即解析顶点数据给着色器中的顶点属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);//启用顶点属性glEnableVertexAttribArray(0);</code></pre><p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p><ul><li>第一个参数指定我们<strong>要配置的顶点属性</strong>。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。在着色器中的位置索引。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li><li>第四个参数是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>float</code>之后，我们把步长设置为<code>3 * sizeof(float)</code>。</li><li>最后一个参数的类型是<code>void*</code>，需进行这个奇怪的强制类型转换。它表示位置数据在缓冲（vbo）中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。</li></ul><p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是<strong>从哪个VBO获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的</strong>。由于在调用glVetexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p><p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该<strong>使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性</strong>；顶点属性默认是禁用的。我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：</p><pre><code>//创建顶点缓冲区对象（vbo）unsigned int VBO;glGenBuffers(1, &amp;VBO);//绑定vbo到GL_ARRAY_BUFFER目标(GL_ARRAY_BUFFER是顶点缓冲区的类型)glBindBuffer(GL_ARRAY_BUFFER, VBO);//复制顶点数组到缓冲中供OpenGL使用glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//设置顶点属性指针,告诉opengl如何解析顶点数据到顶点属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);//启用顶点属性glEnableVertexAttribArray(0);//当我们渲染一个物体时要使用着色器程序glUseProgram(shaderProgram);//绘制物体someOpenGLFunctionThatDrawsOurTriangle();</code></pre><p>当多存多个物体，每个物体有多个顶点的时候，绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p><h4 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h4><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_vertex_array_objects.png" alt="img"></p><p>创建一个VAO和创建一个VBO很类似：</p><pre><code>unsigned int VAO;glGenVertexArrays(1, &amp;VAO);</code></pre><p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p><pre><code>//初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..//绑定VAOglBindVertexArray(VAO);//把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VAO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);[...]// ..:: 绘制代码（渲染循环中） :: ..// 4. 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO); 设置的顶点属性配置someOpenGLFunctionThatDrawsOurTriangle();</code></pre><p>一个储存了顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p><h4 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h4><p>要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><pre><code>glUseProgram(shaderProgram); //使用着色器glBindVertexArray(VAO);      //设置的顶点属性配置glDrawArrays(GL_TRIANGLES, 0, 3);</code></pre><p>glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填<code>0</code>。最后一个参数指定我们打算绘制多少个顶点，这里是<code>3</code></p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_hellotriangle.png" alt="img"></p><h4 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h4><p>索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p><pre><code>float vertices[] = {    // 第一个三角形    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, 0.5f, 0.0f,  // 左上角    // 第二个三角形    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角};</code></pre><p>可以看到，有几个顶点叠加了。我们指定了<code>右下角</code>和<code>左上角</code>两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。</p><p>索引缓冲对象的工作方式正是这样的。<strong>和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点</strong>。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。</p><ol><li>首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</li></ol><pre><code>float vertices[] = {    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角};unsigned int indices[] = { // 注意索引从0开始!     0, 1, 3, // 第一个三角形    1, 2, 3  // 第二个三角形};</code></pre><p>你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。</p><ol start="2"><li>下一步我们需要创建索引缓冲对象：</li></ol><pre><code>unsigned int EBO;glGenBuffers(1, &amp;EBO);</code></pre><p>与VBO类似，<strong>我们先绑定EBO然后用glBufferData把索引复制到缓冲里</strong>。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p><pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</code></pre><p>要注意的是，我们传递了<strong>GL_ELEMENT_ARRAY_BUFFER</strong>当作缓冲目标。</p><ol start="3"><li><p>最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。</p><p>使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p></li></ol><pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p><p><strong>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引</strong>。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。<strong>VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。**</strong>绑定VAO的同时也会自动绑定EBO。**</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_vertex_array_objects_ebo.png" alt="img"></p><p>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</p><p>最后的初始化和绘制代码现在看起来像这样：</p><pre><code>// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);[...]// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0);</code></pre><p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_hellotriangle2.png" alt="img"></p><h4 id="绘制三角形的代码"><a href="#绘制三角形的代码" class="headerlink" title="绘制三角形的代码"></a>绘制三角形的代码</h4><pre><code>#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;const char *vertexShaderSource = &quot;#version 330 core\n&quot;    &quot;layout (location = 0) in vec3 aPos;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;    &quot;}\0&quot;;const char *fragmentShaderSource = &quot;#version 330 core\n&quot;    &quot;out vec4 FragColor;\n&quot;    &quot;void main()\n&quot;    &quot;{\n&quot;    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;    &quot;}\n\0&quot;;int main(){    //glfw初始化和设置    glfwInit();    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    //创建glfw窗口设置当前上下文设置窗口大小变化回调    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL)    {        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    }    glfwMakeContextCurrent(window);    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // glad: load all OpenGL function pointers    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))    {        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    }    // build and compile our shader program    // 创建编译顶点着色器    int vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);    glCompileShader(vertexShader);    // check for shader compile errors    int success;    char infoLog[512];    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);    if (!success)    {        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    }    //创建编译片段着色器    int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    // check for shader compile errors    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);    if (!success)    {        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    }    //创建shader程序 连接顶点片段着色器 连接shader程序    int shaderProgram = glCreateProgram();    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram);    // check for linking errors    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);    if (!success) {        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    }    //链接完成着shader程序之后删除着色器程序    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader);    // set up vertex data (and buffer(s)) and configure vertex attributes    //顶点数组    float vertices[] = {         0.5f,  0.5f, 0.0f,  // top right         0.5f, -0.5f, 0.0f,  // bottom right        -0.5f, -0.5f, 0.0f,  // bottom left        -0.5f,  0.5f, 0.0f   // top left     };    //索引数组    unsigned int indices[] = {  // note that we start from 0!        0, 1, 3,  // first Triangle        1, 2, 3   // second Triangle    };    //创建顶点缓冲对象 顶点数组对象 索引缓冲对象    unsigned int VBO, VAO, EBO;    glGenVertexArrays(1, &amp;VAO);    glGenBuffers(1, &amp;VBO);    glGenBuffers(1, &amp;EBO);    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).    glBindVertexArray(VAO);    //绑定顶点缓冲区 copy顶点数据到顶点缓冲区对象    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    //绑定顶点索引缓冲区 copy顶点索引数据到顶点索引缓冲区    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);    //设置顶点属性指针 解释顶点数据 顶点索引获取顶点数据    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#39;s bound vertex buffer object so afterwards we can safely unbind    glBindBuffer(GL_ARRAY_BUFFER, 0);     // remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);    // You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other    // VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary.    glBindVertexArray(0);     // uncomment this call to draw in wireframe polygons.    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);    // render loop    // -----------    while (!glfwWindowShouldClose(window))    {        // input        // -----        processInput(window);        // render        // ------        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        // draw our first triangle        glUseProgram(shaderProgram);        glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organized        //glDrawArrays(GL_TRIANGLES, 0, 6); //需要绑定顶点数据        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); //需要绑定顶点索引数据        // glBindVertexArray(0); // no need to unbind it every time         // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)        // -------------------------------------------------------------------------------        glfwSwapBuffers(window);        glfwPollEvents();    }    // optional: de-allocate all resources once they&#39;ve outlived their purpose:    // ------------------------------------------------------------------------    glDeleteVertexArrays(1, &amp;VAO);    glDeleteBuffers(1, &amp;VBO);    glDeleteBuffers(1, &amp;EBO);    // glfw: terminate, clearing all previously allocated GLFW resources.    // ------------------------------------------------------------------    glfwTerminate();    return 0;}// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window){    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);}// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height){    // make sure the viewport matches the new window dimensions; note that width and     // height will be significantly larger than specified on retina displays.    glViewport(0, 0, width, height);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;顶点数组对象：Vertex Array Object，VAO&lt;/li&gt;
&lt;li&gt;顶点缓冲对象：Vertex Buffer Object，VBO&lt;/li&gt;
&lt;li&gt;索引缓冲对象：Element Buffer Object，EBO或Inde
      
    
    </summary>
    
      <category term="opengl" scheme="https://bytemode.github.io/categories/opengl/"/>
    
    
      <category term="opengl" scheme="https://bytemode.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>opengl纹理</title>
    <link href="https://bytemode.github.io/2018/12/27/opengl%E7%BA%B9%E7%90%86/"/>
    <id>https://bytemode.github.io/2018/12/27/opengl纹理/</id>
    <published>2018-12-27T08:59:39.000Z</published>
    <updated>2018-12-31T08:30:34.961Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于纹理"><a href="#关于纹理" class="headerlink" title="关于纹理"></a>关于纹理</h4><p>可以为每个顶点添加颜色来增加图形的细节，从而创建出丰富的图像。想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销.纹理是一个2D图片，它可以用来添加物体的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p><p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_tex_coords.png" alt="img"></p><p>我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值</p><p>纹理坐标看起来就像这样：</p><pre><code>float texCoords[] = {    0.0f, 0.0f, // 左下角    1.0f, 0.0f, // 右下角    0.5f, 1.0f // 上中};</code></pre><h4 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h4><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像，其他的环绕方式</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p>纹理选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（<code>s</code>、<code>t</code>、<code>r</code>）它们和<code>x</code>、<code>y</code>、<code>z</code>是等价的）：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</code></pre><p>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是<code>WRAP</code>选项，并且指定<code>S</code>和<code>T</code>轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</p><p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的<code>fv</code>后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><pre><code>float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</code></pre><h4 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h4><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p><p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_filter_nearest.png" alt="img"></p><p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_filter_linear.png" alt="img"></p><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_texture_filtering.png" alt="img"></p><p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><h4 id="多级纹理"><a href="#多级纹理" class="headerlink" title="多级纹理"></a>多级纹理</h4><p>再提个大场景中，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，对它们使用高分辨率纹理浪费内存。</p><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_mipmaps.png" alt="img"></p><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p><p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p><table><thead><tr><th>过滤方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_NEAREST_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td>GL_LINEAR_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td>GL_NEAREST_MIPMAP_LINEAR</td><td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td>GL_LINEAR_MIPMAP_LINEAR</td><td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h2 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>创建纹理对象，使用id类记录对象</p><pre><code>unsigned int texture;glGenTextures(1, &amp;texture);</code></pre><p>glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的<code>unsigned int</code>数组中（我们的例子中只是单独的一个<code>unsigned int</code>），</p><p>绑定对象，让之后任何的纹理指令都可以配置当前绑定的纹理：</p><pre><code>glBindTexture(GL_TEXTURE_2D, texture);</code></pre><p>使用图片数据生成一个纹理了：</p><pre><code>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);glGenerateMipmap(GL_TEXTURE_2D);</code></pre><p>函数很长，参数也不少，所以我们一个一个地讲解：</p><ul><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有<code>RGB</code>值，因此我们也把纹理储存为<code>RGB</code>值。</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为<code>0</code>（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为<code>char</code>(byte)数组，我们将会传入对应值。</li><li>最后一个参数是真正的图像数据。</li></ul><p>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</p><p>生成一个纹理的过程应该看起来像这样：</p><pre><code>unsigned int texture;//生成并且绑定纹理对象glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);//为当前绑定的纹理对象设置环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//多级纹理过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}</code></pre><h4 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h4><p>使用glDrawElements绘制,我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p><pre><code>float vertices[] = {//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // 右上     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // 右下    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // 左下    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // 左上};</code></pre><p>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_vertex_attribute_pointer_interleaved_textures.png" alt="img"></p><pre><code>glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2);</code></pre><p>注意，我们同样需要调整前面两个顶点属性的步长参数为<code>8 * sizeof(float)</code>。</p><p>接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p><pre><code>#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main(){    gl_Position = vec4(aPos, 1.0);    ourColor = aColor;    TexCoord = aTexCoord;}</code></pre><p>片段着色器应该接下来会把输出变量<code>TexCoord</code>作为输入变量。</p><p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如<code>sampler1D</code>、<code>sampler3D</code>，或在我们的例子中的<code>sampler2D</code>。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><pre><code>#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D ourTexture;void main(){    FragColor = texture(ourTexture, TexCoord);}</code></pre><p>我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色</p><p>现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p><pre><code>//glBindTexture中textture是纹理对象的idglBindTexture(GL_TEXTURE_2D, texture);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>完成之后你会看到下面的图像：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_textures2.png" alt="img"></p><p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色：</p><pre><code>FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);</code></pre><p>最终的效果应该是顶点颜色和纹理颜色的混合色：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_textures_funky.png" alt="img"></p><p>我猜你会说我们的箱子喜欢跳70年代的迪斯科。</p><h4 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h4><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p><p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p><pre><code>glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元glBindTexture(GL_TEXTURE_2D, texture);</code></pre><p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用<code>glBindTexture</code>的时候，无需激活任何纹理单元。</p><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p><p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p><pre><code>#version 330 core...uniform sampler2D texture1;uniform sampler2D texture2;void main(){    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);}</code></pre><p>最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是<code>0.0</code>，它会返回第一个输入；如果是<code>1.0</code>，会返回第二个输入值。<code>0.2</code>会返回<code>80%</code>的第一个输入颜色和<code>20%</code>的第二个输入颜色，即返回两个纹理的混合色。</p><p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。</p><p>为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，<strong>先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元</strong>：</p><pre><code>glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>我们还要通过使用<strong>glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元</strong>。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><pre><code>ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置while(...) {    [...]}</code></pre><p>通过使用glUniform1i设置采样器，我们保证了每个uniform采样器对应着正确的纹理单元。你应该能得到下面的结果：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/bytemode/1361208/o_textures_combined.png" alt="img"></p><p>你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴<code>0.0</code>坐标是在图片的底部的，但是图片的y轴<code>0.0</code>坐标通常在顶部。在图像加载时帮助我们翻转y轴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于纹理&quot;&gt;&lt;a href=&quot;#关于纹理&quot; class=&quot;headerlink&quot; title=&quot;关于纹理&quot;&gt;&lt;/a&gt;关于纹理&lt;/h4&gt;&lt;p&gt;可以为每个顶点添加颜色来增加图形的细节，从而创建出丰富的图像。想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多
      
    
    </summary>
    
      <category term="opengl" scheme="https://bytemode.github.io/categories/opengl/"/>
    
    
      <category term="opengl" scheme="https://bytemode.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx批处理渲染</title>
    <link href="https://bytemode.github.io/2018/12/27/cocos2dx%E6%89%B9%E5%A4%84%E7%90%86%E6%B8%B2%E6%9F%93/"/>
    <id>https://bytemode.github.io/2018/12/27/cocos2dx批处理渲染/</id>
    <published>2018-12-27T08:32:40.000Z</published>
    <updated>2018-12-27T10:00:34.643Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>opengl基础</title>
    <link href="https://bytemode.github.io/2018/12/27/opengl%E5%9F%BA%E7%A1%80/"/>
    <id>https://bytemode.github.io/2018/12/27/opengl基础/</id>
    <published>2018-12-27T08:13:48.000Z</published>
    <updated>2018-12-29T13:53:10.763Z</updated>
    
    <content type="html"><![CDATA[<h4 id="opengl"><a href="#opengl" class="headerlink" title="opengl"></a>opengl</h4><p>opengl是一个由<a href="http://www.khronos.org/" target="_blank" rel="noopener">Khronos组织</a>制定并维护的规范(Specification) 。是一系列的图形软件编程接口，和gdi类似。opengl有很多封装的库最有名的GLFW库。接下来很多东西以GLFW 为例子来说明一些api的使用问题，但这并不影响opengl本身的逻辑表述。</p><h5 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h5><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p><p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p><p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集 。</p><p>当我们使用一个对象时，通常看起来像如下一样：</p><pre><code>// OpenGL的状态struct OpenGL_Context {    ...    object* object_Window_Target;    ...     };// 创建对象unsigned int objectId = 0;glGenObject(1, &amp;objectId);// 绑定对象至上下文glBindObject(GL_WINDOW_TARGET, objectId);// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);// 将上下文对象设回默认glBindObject(GL_WINDOW_TARGET, 0);</code></pre><p>这一段代码展现了使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><p>我们要开始一个图形渲染程序，首要是要选择gl库，因为要使用api.然后创建窗口、设置视口、设置窗口大小调整后的回调在回调中要处理视口、接着是渲染循环、还要处理处输入等。</p><h5 id="实例化配置glfw"><a href="#实例化配置glfw" class="headerlink" title="实例化配置glfw"></a>实例化配置glfw</h5><pre><code>int main(){    glfwInit();  //初始化glfw    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //配置glfw    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    return 0;}</code></pre><p>首先，我们在main函数中调用glfwInit函数来初始化GLFW，然后我们可以使用glfwWindowHint函数来配置GLFW。glfwWindowHint函数的第一个参数代表选项的名称，我们可以从很多以GLFW_开头的枚举值中选择；第二个参数接受一个整形，用来设置这个选项的值</p><h5 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h5><p>接下来我们创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到。</p><pre><code>GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);if (window == NULL){    glfwTerminate();    return -1;}glfwMakeContextCurrent(window);</code></pre><p>glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），。这个函数将会返回一个GLFWwindow对象，创建完窗口我们就可以通知GLFW将我们窗口的上下文设置为当前线程的主上下文了。</p><h5 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h5><p>必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的<strong>维度</strong>(Dimension)：</p><pre><code>glViewport(0, 0, 800, 600);</code></pre><p>glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p><p>OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标，处理过的OpenGL坐标范围只为-1到1。 </p><p>当窗口大小发生变换的时候需要设置视口的大小：</p><pre><code>glfwSetFramebufferSizeCallback(window, [](GLFWwindow* window, int width, int height){    glViewport(0, 0, width, height);});</code></pre><h5 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h5><p>我们同样也希望能够在GLFW中实现一些输入控制，这可以通过使用GLFW的几个输入函数来完成。我们将会使用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个processInput函数来让所有的输入代码保持整洁。</p><pre><code>void processInput(GLFWwindow *window){    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);}</code></pre><h5 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h5><p>需要在程序中添加一个while循环，我们可以把它称之为渲染循环(Render Loop)，它能在我们让GLFW退出前一直保持运行。下面几行的代码就实现了一个简单的渲染循环：</p><pre><code>// 渲染循环while(!glfwWindowShouldClose(window)){    // 输入    processInput(window);    // 渲染指令    ...    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    glClear(GL_COLOR_BUFFER_BIT);    // 检查并调用事件，交换缓冲    glfwPollEvents();    glfwSwapBuffers(window);}glfwTerminate();</code></pre><ul><li>glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回<code>true</code>然后渲染循环便结束了，之后为我们就可以关闭应用程序了。</li><li>glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li><li>glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</li><li>glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。 </li><li>调用了glClearColor来设置清空屏幕所用的颜色 </li><li>glClearColor函数是一个<strong>状态设置</strong>函数，而glClear函数则是一个<strong>状态使用</strong>的函数，它使用了当前的状态来获取应该清除为的颜色。 </li><li>glfwTerminate(); 释放所有申请的资源</li></ul><h5 id="双缓冲-Double-Buffer"><a href="#双缓冲-Double-Buffer" class="headerlink" title="双缓冲(Double Buffer)"></a>双缓冲(Double Buffer)</h5><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p><h4 id="最终的程序结构"><a href="#最终的程序结构" class="headerlink" title="最终的程序结构"></a>最终的程序结构</h4><pre><code>#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main(){    //glfw初始化和设置    glfwInit();    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    //创建窗口配置窗口    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL)    {        glfwTerminate();        return -1;    }    //设置问当前窗口上下文    glfwMakeContextCurrent(window);    //设置窗口大小改变的回调 处理视口变化    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // render loop    while (!glfwWindowShouldClose(window))    {        // input        processInput(window);        // render        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)        // -------------------------------------------------------------------------------        glfwSwapBuffers(window);        glfwPollEvents();    }    // glfw: terminate, clearing all previously allocated GLFW resources.    glfwTerminate();    return 0;}void processInput(GLFWwindow *window){    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);}void framebuffer_size_callback(GLFWwindow* window, int width, int height){    glViewport(0, 0, width, height);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;opengl&quot;&gt;&lt;a href=&quot;#opengl&quot; class=&quot;headerlink&quot; title=&quot;opengl&quot;&gt;&lt;/a&gt;opengl&lt;/h4&gt;&lt;p&gt;opengl是一个由&lt;a href=&quot;http://www.khronos.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="opengl" scheme="https://bytemode.github.io/categories/opengl/"/>
    
    
      <category term="opengl" scheme="https://bytemode.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx是如何绘制图片的</title>
    <link href="https://bytemode.github.io/2018/12/18/cocos2dx%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E7%9A%84/"/>
    <id>https://bytemode.github.io/2018/12/18/cocos2dx是如何绘制图片的/</id>
    <published>2018-12-18T13:56:58.000Z</published>
    <updated>2018-12-29T13:53:10.763Z</updated>
    
    <content type="html"><![CDATA[<p>cocos2dx绘制单个图片的渲染命令是QUAD_COMMAND,通过分析这个命令可以学习opengl es是如何处理图片渲染的.</p><h4 id="关于VAO和VBO"><a href="#关于VAO和VBO" class="headerlink" title="关于VAO和VBO"></a>关于VAO和VBO</h4><p>顶点数组对象（Vertex Array Object  即VAO）是一个包含多个顶点缓冲区对象（Vertex Buffer Object， 即 VBO）的对象，一般存储一个可渲染物体的顶点信息. 顶点缓冲区对象（ VBO）是你显卡内存中的一块高速内存缓冲区，用来存储顶点的所有信息。</p><p>顶点数组指定的顶点数据保存在客户内存中,在进行glDrawArray或者glDrawElements等绘图调用时，这些数据必须同客户内存复制到图形内存中,没必要每次绘图时都复制顶点数据，而是在图形内存中缓存这些数据，这样可以显著改善渲染性能，也可以降低内存带宽和电力消耗需求,这就是顶点缓冲区对象发挥作用的地方.在OpenGL3.0中，出现了更进一步的VAO，VBO通过绘制上下文获得绘制状态，VAO可以拥有多个VBO，它记录所有绘制状态，它的代码更简洁，效率更高.</p><pre><code>void Renderer::setupBuffer(){    if(Configuration::getInstance()-&gt;supportsShareableVAO())    {        //初始化VBO和VAO        setupVBOAndVAO();    }    else    {        //不支持VAO，只初始化VBO        setupVBO();    }}void Renderer::setupVBOAndVAO(){    //一个VAO    glGenVertexArrays(1, &amp;_quadVAO);    //绑定VAO    GL::bindVAO(_quadVAO);    //创建生成两个VBO    glGenBuffers(2, &amp;_buffersVBO[0]);    //顶点Buffer    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);    glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) * VBO_SIZE, _quads, GL_DYNAMIC_DRAW);    //这里就是VAO和VBO的区别，VAO把这些放到初始化中，无论后面绘制多少次，只要他不被改变，这段代码只会被调用一次，而VBO中，这个功能的代码会在每次被绘制时调用，这样就节约了效率    //位置    glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_POSITION);    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F), (GLvoid*) offsetof( V3F_C4B_T2F, vertices));    //颜色    glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_COLOR);    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(V3F_C4B_T2F), (GLvoid*) offsetof( V3F_C4B_T2F, colors));    //纹理坐标数据    glEnableVertexAttribArray(GLProgram::VERTEX_ATTRIB_TEX_COORDS);    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORDS, 2, GL_FLOAT, GL_FALSE, sizeof(V3F_C4B_T2F), (GLvoid*) offsetof( V3F_C4B_T2F, texCoords));    //索引Buffer    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]);    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * VBO_SIZE * 6, _indices, GL_STATIC_DRAW);    //取消VAO    GL::bindVAO(0);    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);    glBindBuffer(GL_ARRAY_BUFFER, 0);    CHECK_GL_ERROR_DEBUG();}void Renderer::setupVBO(){    //创建生成两个VBO    glGenBuffers(2, &amp;_buffersVBO[0]);    //调用函数绑定buffer    mapBuffers();}void Renderer::mapBuffers(){    //GL_ARRAY_BUFFER 表示顶点数据    //GL_ELEMENT_ARRAY_BUFFER 表示索引数据    //避免改变buffer元素    GL::bindVAO(0);    //绑定id 顶点数据    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);    //为改id制定一段内存区域    glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) * VBO_SIZE, _quads, GL_DYNAMIC_DRAW);    glBindBuffer(GL_ARRAY_BUFFER, 0);    //第二个VBO 索引数据    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]);    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(_indices[0]) * VBO_SIZE * 6, _indices, GL_STATIC_DRAW);    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);    CHECK_GL_ERROR_DEBUG();}</code></pre><p>0l;需要介绍的两个关键的函数</p><p>glBindBuffer：它绑定缓冲区对象表示选择未来的操作将影响哪个缓冲区对象。如果应用程序有多个缓冲区对象，就需要多次调用glBindBuffer()函数：一次用于初始化缓冲区对象以及它的数据，以后的调用要么选择用于渲染的缓冲区对象，要么对缓冲区对象的数据进行更新。</p><p>当传入的第二个参数第一次使用一个非零无符号整数时，创建一个新的缓冲区对象；当第二个参数是之前使用过的，这个缓冲区对象成为活动缓冲区对象；如果第二个参数值为0时，停止使用缓冲区对象</p><p>glBufferData：保留空间存储数据，他分配一定大小的（第二个参数）的openGL服务端内存，用于存储顶点数据或索引。这个被绑定的对象之前相关联的数据都会被清除。</p><p>glBufferData参数介绍</p><p>参数1，目标GL_ARRAY_BUFFER或者GL_ELEMENT_ARRAY_BUFFER</p><p>参数2，内存容量</p><p>参数3，用于初始化缓冲区对象，可以使一个指针，也可以是空</p><p>参数4，如何读写，可以选择如下几种</p><pre><code>GL_DYNAMIC_DRAW:多次指定，多次作为绘图和图像指定函数的源数据，缓冲区对象的数据不仅常常需要进行更新，而且使用频率也非常高GL_STATIC_DRAW:数据只指定一次，多次作为绘图和图像指定函数的源数据，缓冲区对象的数据只指定1次，但是这些数据被使用的频率很高GL_STREAM_DRAW:数据只指定一次，最多只有几次作为绘图和图像指定函数的源数据，缓冲区对象中的数据常常需要更新，但是在绘图或其他操作中使用这些数据的次数较少</code></pre><p>从初始化的代码上，为什么VAO反倒复杂了呢？因为他只是把绘制时需要做的一些事情提前放到初始化函数中，来看一下绘制流程。</p><pre><code>//当前的openGL是否支持VAOif (Configuration::getInstance()-&gt;supportsShareableVAO()){    //绑定顶点数组    glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);    //向缓冲区申请空间并指定数据传输方式    glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) * (_numQuads), nullptr, GL_DYNAMIC_DRAW);    //提供缓冲区对象包含整个数据集合的更新    void *buf = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);    memcpy(buf, _quads, sizeof(_quads[0])* (_numQuads));    //缓冲区对象的更新完成    glUnmapBuffer(GL_ARRAY_BUFFER);    //为了禁用缓冲区对象，可以用0作为缓冲区对象的标识符来调用glBindBuffer()函数。这将把OpenGL切换为默认的不使用缓冲区对象的模式。    glBindBuffer(GL_ARRAY_BUFFER, 0);    //Bind VAO    GL::bindVAO(_quadVAO);}else{</code></pre><p>#define kQuadSize sizeof(_quads[0].bl)<br>        glBindBuffer(GL_ARRAY_BUFFER, _buffersVBO[0]);<br>        glBufferData(GL_ARRAY_BUFFER, sizeof(_quads[0]) <em> _numQuads , _quads, GL_DYNAMIC_DRAW);<br>        //激活顶点颜色纹理坐标的属性<br>        GL::enableVertexAttribs(GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);<br>        //顶点<br>        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid</em>) offsetof(V3F_C4B_T2F, vertices));<br>        //颜色<br>        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (GLvoid<em>) offsetof(V3F_C4B_T2F, colors));<br>        //纹理坐标<br>        glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORDS, 2, GL_FLOAT, GL_FALSE, kQuadSize, (GLvoid</em>) offsetof(V3F_C4B_T2F, texCoords));</p><pre><code>    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _buffersVBO[1]);}</code></pre><p>可以看到，这些设置属性的函数放在了绘制函数里，虽然看似是一样的，但是绘制函数会被调用的更频繁，所以把这些函数放到初始化函数中可以大幅提高程序的效率。</p><p>这里介绍VAO的两个函数：</p><p>glMapBuffer函数返回一个指针，指向与第一个参数相关联的当前绑定缓冲区对象的数据存储。第一个参数与glBufferData的第一个参数一致。第二个参数是GL_READ_ONLY、GL_WRITE_ONLY或GL_READ_WRITE之一，表示可以对数据进行的操作。</p><p>glUnmapBuffer表示对当前绑定缓冲区对象的更新已经完成，并且这个缓冲区可以释放。</p><p>enableVertexAttribs激活相关属性，激活的属性可以调用glVertexAttribPointer指定数据源，可选的有VERTEX_ATTRIB_FLAG_POSITION，VERTEX_ATTRIB_FLAG_COLOR和VERTEX_ATTRIB_FLAG_TEX_COORDS，这里这个参数是激活这三个。</p><p>glVertexAttribPointer指定了渲染时第一个参数代表的索引值的顶点属性数组的数据格式和位置。</p><p>第一个参数指定要修改的顶点属性的索引值，包括VERTEX_ATTRIB_POSITION（位置），VERTEX_ATTRIB_COLOR（颜色），VERTEX_ATTRIB_TEX_COORDS（纹理坐标）。</p><p>第二个参数指定每个属性值的组件数量且必须为1、2、3、4之一。</p><p>第三个参数指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT,GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。</p><p>第四个参数指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE，意味着整数型的值会被映射至区间<a href="有符号整数">-1,1</a>，或者区间[0,1]（无符号整数））或者直接转换为固定点值（GL_FALSE）。</p><p>第五个参数指定了一个属性到下一个属性之间的步长（这就允许属性值被存储在单一数组或者不同的数组中）。也就是连续顶点属性之间的偏移量。如果为0，那么它们是紧密排列在一起的。初始值为0。</p><p>第六个参数指定一个指针，指向数组中第一个顶点属性的第一个组件。初始值为0。</p><p>最后需要调用绘制元素函数，绘制这些信息</p><p>glDrawElements(GL_TRIANGLES, (GLsizei) quadsToDraw<em>6, GL_UNSIGNED_SHORT, (GLvoid</em>) (startQuad<em>6</em>sizeof(_indices[0])) );<br>它根据索引绘图(注意：顶点数据和索引各自使用不同的缓冲区)</p><pre><code>需要注意的是在Renderer的析构函数中要调用glDeleteBuffers来释放它的资源，并使它的标识可以其他缓冲区对象使用。</code></pre><h3 id="QUAD-COMMAND的绘制函数"><a href="#QUAD-COMMAND的绘制函数" class="headerlink" title="QUAD_COMMAND的绘制函数"></a>QUAD_COMMAND的绘制函数</h3><p>QUAD_COMMAND命令回调用drawBatchedQuads调用绘制函数</p><pre><code>else if ( RenderCommand::Type::QUAD_COMMAND == commandType )        {            flush3D();            if(_filledIndex &gt; 0)            {                drawBatchedTriangles();                _lastMaterialID = 0;            }            auto cmd = static_cast&lt;QuadCommand*&gt;(command);            //Batch quads            if( (_numberQuads + cmd-&gt;getQuadCount()) * 4 &gt; VBO_SIZE )            {                drawBatchedQuads();            }            _batchQuadCommands.push_back(cmd);            fillQuads(cmd);        }void Renderer::flush(){    //绘制    drawBatchedQuads();    //清空    _lastMaterialID = 0;}</code></pre><p>这个处理主要是把命令存入_batchedQuadCommands中，如果如果Quad数据量超过VBO的大小，那么调用绘制，将缓存的命令全部绘制.如果一直没有超过VBO的大小，drawBatchedQuads绘制函数将在flush被调用时调用</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cocos2dx绘制单个图片的渲染命令是QUAD_COMMAND,通过分析这个命令可以学习opengl es是如何处理图片渲染的.&lt;/p&gt;
&lt;h4 id=&quot;关于VAO和VBO&quot;&gt;&lt;a href=&quot;#关于VAO和VBO&quot; class=&quot;headerlink&quot; title=&quot;关
      
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx渲染架构</title>
    <link href="https://bytemode.github.io/2018/12/17/cocos2dx%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://bytemode.github.io/2018/12/17/cocos2dx渲染架构/</id>
    <published>2018-12-17T12:13:14.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<p>2dx的时代UI树便利和渲染是没有分开的，遍历UI树的时候就渲染.3dx版本为了分离了ui树的遍历和渲染，先遍历生成渲染命令发到渲染队列，之后遍历渲染命令队列开始渲染.这样做的好处是渲染命令可以重用，单独的渲染可以做优化例如自动批绘制.本篇首先介绍cocos2D-X 3.x版本的渲染结构，之后会深入opengl es.</p><h4 id="mainLoop"><a href="#mainLoop" class="headerlink" title="mainLoop"></a>mainLoop</h4><pre><code>void DisplayLinkDirector::mainLoop(){    if (_purgeDirectorInNextLoop)    {        //只有一种情况会调用到这里来，就是导演类调用end函数        _purgeDirectorInNextLoop = false;        //清除导演类        purgeDirector();    }    else if (! _invalid)    {        //绘制        drawScene();        //清除内存        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();    }}</code></pre><p>分析的起点是mainLoop函数，这是在主线程里面会调用的循环，其中drawScene函数进行绘制。那么就进一步来看drawScene函数。mainLoop实在opengl的ondrawframe调用过来的即平台每帧渲染会调用.</p><h4 id="drawScene"><a href="#drawScene" class="headerlink" title="drawScene"></a>drawScene</h4><pre><code>void Director::drawScene(){    //计算间隔时间    calculateDeltaTime();    //如果间隔时间过小会被忽略    if(_deltaTime &lt; FLT_EPSILON){ return;}    //空函数，也许之后会有作用    if (_openGLView)    {        _openGLView-&gt;pollInputEvents();    }    //非暂停状态    if (! _paused)    {        //scheduler更新 会使actionmanager更新和相关的schedule更新 引擎物理模拟都是在绘制之前做的        _scheduler-&gt;update(_deltaTime);        _eventDispatcher-&gt;dispatchEvent(_eventAfterUpdate);    }    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    //切换下一场景，必须放在逻辑后绘制前，否则会出bug    if (_nextScene)    {        setNextScene();    }    kmGLPushMatrix();    //创建单位矩阵    kmMat4 identity;    kmMat4Identity(&amp;identity);    //绘制场景    if (_runningScene)    {        //递归的遍历scene中的每个node的visit生成渲染命令放入渲染队列        _runningScene-&gt;visit(_renderer, identity, false);        _eventDispatcher-&gt;dispatchEvent(_eventAfterVisit);    }    //绘制观察节点，如果你需要在场景中设立观察节点，请调用摄像机的setNotificationNode函数     if (_notificationNode)    {        _notificationNode-&gt;visit(_renderer, identity, false);//这是一个常驻节点    }    //绘制屏幕左下角的状态    if (_displayStats)    {        showStats();    }    //渲染    _renderer-&gt;render();    //渲染后    _eventDispatcher-&gt;dispatchEvent(_eventAfterDraw);    kmGLPopMatrix();    _totalFrames++;    if (_openGLView)    {        _openGLView-&gt;swapBuffers(); //交换缓冲区    }    //计算绘制时间    if (_displayStats)    {        calculateMPF();    }}</code></pre><p>其中和绘制相关的是visit的调用和render的调用，其中visit函数会调用节点的draw函数，在3.x之前的版本中draw函数就会直接调用绘制代码，3.x版本是在draw函数中生成将绘制命令放入到renderer队列中，然后renderer函数去进行真正的绘制，首先来看sprite的draw函数.</p><h4 id="渲染命令"><a href="#渲染命令" class="headerlink" title="渲染命令"></a>渲染命令</h4><pre><code>void Sprite::draw(Renderer *renderer, const kmMat4 &amp;transform, bool transformUpdated){    //检查是否超出边界，自动裁剪    _insideBounds = transformUpdated ? renderer-&gt;checkVisibility(transform, _contentSize) : _insideBounds;    if(_insideBounds)    {        //初始化        _quadCommand.init(_globalZOrder, _texture-&gt;getName(), _shaderProgram, _blendFunc, &amp;_quad, 1, transform);        renderer-&gt;addCommand(&amp;_quadCommand);        //物理引擎相关绘制边界if CC_SPRITE_DEBUG_DRAW        _customDebugDrawCommand.init(_globalZOrder);        //自定义函数        _customDebugDrawCommand.func = CC_CALLBACK_0(Sprite::drawDebugData, this);        renderer-&gt;addCommand(&amp;_customDebugDrawCommand);endif    }}</code></pre><p>这里面用了两种不同的绘制命令quadCommand初始化后就可以加入到绘制命令中，customDebugDrawCommand传入了一个回调函数，具体的命令种类会在后面介绍。其中自定义的customDebugDrawCommand命令在初始化的时候只传入了全局z轴坐标，因为它的绘制函数全部都在传入的回调函数里面，_quadCommand则需要传入<strong>全局z轴坐标，贴图名称，shader，混合，坐标点集合，坐标点集个数，变换</strong>。</p><h4 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h4><pre><code>void Renderer::render(){    _isRendering = true;    if (_glViewAssigned)    {        //清除        _drawnBatches = _drawnVertices = 0;        //排序        for (auto &amp;renderqueue : _renderGroups)        {            renderqueue.sort();        }        //绘制        visitRenderQueue(_renderGroups[0]);        flush();    }    clean();    _isRendering = false;}</code></pre><p>Render类中的render函数进行真正的绘制，<strong>首先排序，再进行绘制</strong>，从列表中的第一个组开始绘制。在visitRenderQueue函数中可以看到五种不同类型的绘制命令类型，分别对应五个类，这五个类都继承自RenderCommand。</p><h5 id="绘制命令"><a href="#绘制命令" class="headerlink" title="绘制命令"></a>绘制命令</h5><ol><li><p>QUAD_COMMAND：</p><p>QuadCommand类绘制精灵等。所有绘制图片的命令都会调用到这里，处理这个类型命令的代码就是绘制贴图的openGL代码，</p></li><li><p>CUSTOM_COMMAND：</p><p>自定义绘制，自己定义绘制函数，在调用绘制时只需调用已经传进来的回调函数就可以，裁剪节点，绘制图形节点都采用这个绘制，把绘制函数定义在自己的类里。这种类型的绘制命令不会在处理命令的时候调用任何一句openGL代码，而是调用你写好并设置给func的绘制函数，并自己实现一个自定义的绘制。</p></li><li><p>BATCH_COMMAND：</p><p>批处理绘制，批处理精灵和粒子,其实它类似于自定义绘制，也不会再render函数中出现任何一句openGL函数，它调用一个固定的函数。</p></li><li><p>GROUP_COMMAND：</p><p>绘制组，一个节点包括两个以上绘制命令的时候，把这个绘制命令存储到另外一个renderGroups中的元素中，并把这个元素的指针作为一个节点存储到renderGroups[0]中。</p></li></ol><h5 id="render流程"><a href="#render流程" class="headerlink" title="render流程"></a>render流程</h5><pre><code>void Renderer::addCommand(RenderCommand* command){    //获得栈顶的索引    int renderQueue =_commandGroupStack.top();    //调用真正的addCommand    addCommand(command, renderQueue);}void Renderer::addCommand(RenderCommand* command, int renderQueue){    //将命令加入到数组中    _renderGroups[renderQueue].push_back(command);}</code></pre><p>addCommand它是获得需要把命令加入到renderGroups位置中的索引，这个索引是从commandGroupStack获得的，commandGroupStack是个栈，当我们创建一个GROUP_COMMAND时，需要调用pushGroup函数，它是把当前这个命令在_renderGroups的索引位置压到栈顶，当addCommand时，调用top，获得这个位置</p><pre><code>groupCommand.init(globalZOrder);renderer-&gt;addCommand(&amp;_groupCommand);renderer-&gt;pushGroup(_groupCommand.getRenderQueueID());</code></pre><p>GROUP_COMMAND一般用于绘制的节点有一个以上的绘制命 令，把这些命令组织在一起，无需排定它们之间的顺序，他们作为一个整体被调用，所以一定要记住，栈是push，pop对应的，关于这个节点的所有的绘制命令被添加完成后，请调用pop，将这个值从栈顶弹出，否则后面的命令也会被添加到这里。</p><p> 为什么调用的起始只需调用为什么只是0，其他的呢？</p><p><code>visitRenderQueue(_renderGroups[0]);</code></p><p>它们会在处理GROUP_COMMAND被调用</p><pre><code>else if(RenderCommand::Type::GROUP_COMMAND == commandType) {    flush();    int renderQueueID = ((GroupCommand*) command)-&gt;getRenderQueueID();    visitRenderQueue(_renderGroups[renderQueueID]);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2dx的时代UI树便利和渲染是没有分开的，遍历UI树的时候就渲染.3dx版本为了分离了ui树的遍历和渲染，先遍历生成渲染命令发到渲染队列，之后遍历渲染命令队列开始渲染.这样做的好处是渲染命令可以重用，单独的渲染可以做优化例如自动批绘制.本篇首先介绍cocos2D-X 3.x
      
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>tolua原理</title>
    <link href="https://bytemode.github.io/2018/12/17/tolua%E5%8E%9F%E7%90%86/"/>
    <id>https://bytemode.github.io/2018/12/17/tolua原理/</id>
    <published>2018-12-17T03:03:17.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？"><a href="#tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？" class="headerlink" title="tolua++如何将c++对象导入到lua里？lua如何能够访问c++对象成员？"></a>tolua++如何将c++对象导入到lua里？lua如何能够访问c++对象成员？</h4><p>创建一个 userdata ，存放 C/C++ 对象指针，然后给 userdata 添加元表，用<strong>index</strong> 和<strong>newindex</strong> 元方法映射 C/C++ 中的对象方法。</p><ol><li>c++层新建一个元表作为类型（通过tolua_usertype）放在注册表中（_R[mt] = name），并且设置这些类型的继承关系(通过_R.tolua_super).</li><li>创建一个类表(newtable)，并且设置_R中的原型表为元表（通过tolua_usertype），这个类表是放在全局表中的.</li><li>在注册类型的时候metatable里新建了.get和.set表。</li></ol><p>​      成员变量：在.set和.get表里存储以变量名为键一读取设置c函数为值的键值对。</p><p>​      变量的读取赋值会在在metatable的<strong>index和</strong>newindex里，以变量名为键，从.get和.set表里取得读取设置函数并调用。</p><p>​      成员函数：只需要以函数名为键，函数为值存储在metatable里。</p><ol start="3"><li>因为c++类型已经在注册表里，所以可以直接访问。</li></ol><p>​     lua里调用c++创建一个对象之后，c++需要返回这个对象：</p><p>​     新建userdata,将c++指针放入userdata;以对象地址为key，userdata为值放入tolua_ubox表里；设置此类型对象的元表为userdata的元表。</p><p>   经过上面4个步骤，就可以在lua里面调用类表。</p><p>传入c++对象的tolua++函数是tolua_pushusertype。一般情况下，第一次使用这个函数将一个c++对象push到lua堆栈上时，才会新建userdata。tolua++会以c++对象地址为键，userdata为值，将键值对存储在tolua_ubox表里。下次推入同样的c++对象时，从这个表里取出userdata推入堆栈即可。</p><h4 id="tolua-如何处理类型的继承"><a href="#tolua-如何处理类型的继承" class="headerlink" title="tolua++如何处理类型的继承"></a>tolua++如何处理类型的继承</h4><p>父类的metatable,是子类metatable的metatable。这样调用父类方法时，就会去父类的metatable里查找了。</p><p>tolua++还维护了一个tolua_super表，这个表以c++类型的metatable为键，以一个表格为值。这个值表格以类型名称为键，以true为值，记录了metatable对应c++类型的父类有哪些。这个表格可以用来帮助判断对象是否是某一个类型。</p><h4 id="tolua-如何管理对象的生命周期"><a href="#tolua-如何管理对象的生命周期" class="headerlink" title="tolua++如何管理对象的生命周期"></a>tolua++如何管理对象的生命周期</h4><p>一般情况下，当lua里对c++对象的引用变量可以被垃圾回收时，tolua++只是简单的释放userdata占用的4字节指针地址内存。但是也可以通过绑定或者代码指定的方式，让tolua++真正释放对象所占内存。</p><p>绑定的方式，是指在将c++类型构造函数使用tolua++导出到lua里时，tolua++会自动生成new_local方法。如果在lua代码里，用这个方法新建对象时，tolua++会调用tolua_register_gc方法，指明回收对象时回收对象内存。</p><p>在c++代码里，使用tolua_pushusertype_and_takeownership；在lua代码里，使用tolua.takeownership，都可以达到同样的目的。</p><p>对于这些指定由tolua++回收内存的对象，如果其类型的析构函数也通过tolua++导出了，则在回收内存时，会通过delete运算符，调用对象的析构函数。否则只会使用free方法回收。</p><p>tolua_register_gc方法，做的事情，是以对象指针为键，以对象metatable为值，将键值对存储在tolua_gc表里。在对象类型的metatable表的__gc方法里，tolua++会检查tolua_gc表是否包含以这个地址为键的表项。包含的话才会进行上述的内存回收工作。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>有的时候，在lua里取得一个c++对象后，我们想赋给它一些只在lua环境下有意义的属性。或者，我们想在lua里扩展一个c++类。tolua++也提供了实现这种需求的机制。</p><p>tolua++在LUA_REGISTRY里维护了一张tolua_peers表。这张表以表示c++对象的userdata为键，以一张表格t为值。t里面就记录了这个对象在lua里扩展的属性。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>C++在进行函数调用的时候是this指针+函数地址, Lua提供用户自定义的userdata.</p><p> 一般lua中持有c++对象是使用userdata来实现的(userdata 类型用来将任意 C 数据保存在 Lua 变量中. 这个类型相当于一块原生的内存, 除了赋值和相同性判断, Lua 没有为之预定义任何操作.通过使用 metatable （元表）, 可以为 userdata 自定义一组操作. metatable 中还可以定义一个函数gc让 userdata 作垃圾收集时调用它。</p><p>​     因此，metatable可以用来模拟C++里面的函数，通过替换它来实现函数，类成员的查找。Userdata可以很方便的获取到转换成C++里面this指针。通过this指针+类的函数地址即可调用C++里面的类成员函数。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>tolua_open()创建很多用于管理的内部变量， 如记录所有基类；</p><p>tolua_usertype() 创建两个表分别问type和 const type类型， const type 继承自 type;</p><p>tolua_cclass()注册类设置元表建立父子类关系；</p><p>tolua_beginmodule（）注册一个模块</p><p>tolua_function()函数绑定到lua表中</p><p>tolua_beginmodule（）结束模块注册。</p><h5 id="tolua-open是入口点，它创建很多用于管理的内部变量，以下用-G指代全局表，-R指定registry-table："><a href="#tolua-open是入口点，它创建很多用于管理的内部变量，以下用-G指代全局表，-R指定registry-table：" class="headerlink" title="tolua_open是入口点，它创建很多用于管理的内部变量，以下用_G指代全局表，_R指定registry table："></a>tolua_open是入口点，它创建很多用于管理的内部变量，以下用_G指代全局表，_R指定registry table：</h5><p>1、_R.TOLUA_VALUE_ROOT={}， 这个表是cocos2dx自己加的，它把所有传入lua的cppobj/userdata都塞到这个表里，而且这还不是一个弱表，也就意味着cocos2dx创建的cpp obj，永远都不会被gc！只有在c++层面被delete时，才会去这个表里删除自己。因此，每一个cocos2dx cpp obj，是不可能依赖lua gc来释放的，必须纯手动管理（retain/release）。当然，根据cocos2dx自身的设计，每个obj在new出来refcount为1，并且会添加autorelease pool里去，因此只要它不在场景树上，下一帧就会被自动删除掉。通常情况下，lua代码是不会干涉其生命期的。但是有些时候我们会把某些节点从场景树上摘下，过一段时间又挂上去，这时就必须先调一下它的retain，如果之后忘记调release，那么它就永远不会销毁了。</p><p>2、_R.tolua_peers={}，这是个弱表，用来缓存所有cppobj的ptr-&gt;peer table，所谓peer table，就是给每个cpp obj userdata关联的一个lua table，用来提供lua层面的额外的kv存储。tolua++把每个userdata的peer table设成该userdata的env，目的当然是为了方便找到它。因为在lua实现里，userdata的env是没有内定用途的，于是tolua++就拿来存peer table了。</p><p>3、_R.tolua_ubox={}，也是个弱表，用来缓存所有cppobj的ptr-&gt;userdata映射，userdata里面存放的值其实就是ptr。这个表的用途是记录所有已经push到lua里的cppobj，每个cppobj第一次进入lua时，会去做创建userdata、关联metatable、设置peertable(env)等等一大堆操作，然后把ptr-&gt;userdata的映射关系记到这个表里，下次再被返回进lua时，就从这表里去查找，查到的话就直接拿已创建好的userdata用了。但是有一种特殊情况，就是第二次push时的类型是上一次的子类，也就是一个“特化类型”，那么需要改设metatable，以使子类的新函数能被访问到。</p><p>4、_R.tolua_super={}，用来记录每个类型的所有基类，key是子类的mt，value则是个map，其中每个kv都是一个pair&lt;基类名,1&gt;。通过这个表可以快速知道两个类之间有无继承关系。</p><p>5、_R.tolua_gc={}</p><p>6、_R.tolua_gc_event = closure{ func:class_gc_event, upvalue:上述两个表格 }， 这是挂在每个类对应的metatable上的__gc方法。</p><p>7、_G.tolua={}，里面存放tolua自己的一些工具函数</p><h5 id="类的注册。"><a href="#类的注册。" class="headerlink" title="类的注册。"></a>类的注册。</h5><p>1、对每个用户类，首先要用tolua_usertype声明这是个用户类型：</p><p>​     tolua_usertype(tolua_S, “<a href="http://www.java123.net/web/" target="_blank" rel="noopener">Web</a>Socket”)</p><p>它里面的做事情很简单，就是分别为type和const type“两个类”建表（这个表也就是其实例userdata的元表），然后设置type继承const type，从数据的角度来看也就是：</p><p>//先用tolua_newmetatable分别创建创建两个元表，其内又调用tolua_classevents挂上各种属性</p><p>_R[“WebSocket”]={</p><p>  __index = cfunc:class_index_event,</p><p>  __newindex = cfunc:class_newindex_event,</p><p>  __gc=_R.tolua_gc_event //上面之&lt;一.6&gt;</p><p>  //其它各种add/sub/lt/eq等方法……</p><p>}</p><p>_R[“const WebSocket”]= ……同上</p><p>//mapsuper(L,type,ctype) 设置两者的继承关系</p><p>_R.tolua_super[_R[“WebSocket”]] ={ “const WebSocket” = 1,} //上面之&lt;一.4&gt;</p><p>//这个过程会递归执行，即把基类的所有基类都添到子类里</p><p>for k,v in pairs(_R.tolua_super[_R[“const WebSocket”]]) do</p><p>_R.tolua_super[_R[“WebSocket”]][k] = v</p><p>end</p><p> //在这一步里，mapsuper只是设置type-&gt;const type，但是在后续步骤里会添加大量type-&gt;base type，因此递归下来，每个type的_R.tolua_super[type]表还是有很多内容的。</p><p>2、然后用tolua_cclass来注册类。</p><p>​    tolua_cclass主要做两件事，一是把基类和父类（以及各const变种）之间的关系建立起来，二是注册类的析构函数（构造函数由普通的create静态函数替代了）。</p><p>关于继承关系，总共四对：</p><p>mapinheritance(L,name,base);</p><p>mapinheritance(L,cname,name);</p><p>mapsuper(L,cname,cbase);</p><p>mapsuper(L,name,base);</p><p>其中c指const。除了上面提到的mapsuper，又来了个mapinheritance， 再次对比说明下：</p><p>mapsuper是：在_R.tolua_super记录每个类(k)有哪些父类(v)，所有父类以v[类名]=1的形式记录着。</p><p>mapinheritance是：把父类元表表设成子类元表表的元表，同时给基类表上挂一个用以记录该类objptr-&gt;userdata映射的弱表，大致是：</p><p>setmetatable( _R.type, _R.base_type )，</p><p>_R.type.tolua_ubox = _R.base_type.tolua_ubox or weak({})</p><p>其中第二句与前述之&lt;一.3&gt;有点相似，只是那是放在_R上的一个总表，而这里是为每个类单独建表，但子类与基类是共用的，也就是每次调用tolua_cclass注册一个类，就有“3个类”的表中的tolua_ubox字段指向了同一个表，这3个类从上到下是：base type -&gt; type -&gt; const type，至于const base type，那是在之前注册基类时处理的了。</p><p>不过这里还有个另外的问题！注意和第2条里的对比：</p><p>mapinheritance(L,cname,name) //tolua_cclass里</p><p>mapsuper(L,type,ctype) //tolua_usertype里</p><p>到底type和const type谁是“基类”呢？这主要看不同场合里“基类”这个概念是用于解决什么问题了：</p><p>对mapsuper而言：在c++里一个声明为const的参数，实际是对函数本身的约束而不是对实参的约束：它只是强调函数内部不会去修改这个参数，至于传进来的实参本身是不是const的根本不重要，因为反正函数已经承诺不会去修改它了。所以要把一个类型为type的obj传给某个带有const type参数的函数，是没有问题的，但反过来，一个const type对象要传给接受type参数的函数是不行的，因为不知道它到底会不会修改（没有承诺不修改就意味着会修改）。再加上tolua++在生成胶水代码时，对每个参数都要做类型匹配检测（也就是在生成代码中大量的lua_isusertype调用），一个usertype变量是否合格，就是检查它所在位置的参数类型，是否是它可以“扮演”的角色，这些角色一是它的所有父类，二就是它以及所有父类的const变种了，而这些可以扮演的类型，恰好就是mapsuper所建立的_R.tolua_super体系中记录的内容了。</p><p>对mapinheritance而言：它将基类表设成子类表的元表，这是为了在子类表里可以找到基类的函数（在class_index_event函数里，有一个while循环，通过这里建立的链条不断向上级查找）。就这个目的而言，type和const type谁做基类是一样的。但是，type还有真正的基类base，按照base-&gt;type-&gt;const type的继承顺序是恰好满足的：</p><p>classA -&gt; const classA</p><p>​          -&gt; classB -&gt; const classB</p><p>​                         -&gt; classC -&gt; const classC</p><p>​                                       -&gt; classD -&gt; const classD</p><p>也就是说const类型在当前层次的链上是一个叶，下一层次不是从它继承，而是与它并级。</p><p>而如果按照base-&gt;const type-&gt;type-&gt;const subtype-&gt;sub type，那么问题就麻烦了，因为在注册函数时，所有函数都是挂在不带const的类表上的，如CCNode的函数都在_R[“CCNode”]里，这也符合脚本里创建类实例时的习惯：直接以“纯粹的”（不带const的）类名来操作，比如CCNode:create，而不会写作const_CCNode:create()。那么在后者的继承链上，每一个const type实际成了断点，没有得到这个type自身的函数！</p><p>3.tolua_beginmodule（） tolua_endmodule()  tolua_function()</p><p>tolua_beginmodule(m_pState, “CTest”);是只注册一个模块，比如，我们管CTest叫做”CTest”，保持和C++的名称一样。这样在Lua的对象库中就会多了一个CTest的对象描述，等同于string,number等等基本类型，同tolua_beginmodule()和tolua_endmodule()对象必须成对出现，如果出现不成对的，你注册的C++类型将会失败。 </p><p>tolua_function(m_pState, “SetData”, tolua_SetData_CTest);指的是将Lua里面CTest对象的”SetData”绑定到你的tolua_SetData_CTest()函数中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？&quot;&gt;&lt;a href=&quot;#tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？&quot; class=&quot;headerlink&quot; title=&quot;tolua++如何将c++对象导入到
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua闭包</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E9%97%AD%E5%8C%85/"/>
    <id>https://bytemode.github.io/2018/12/15/lua闭包/</id>
    <published>2018-12-15T10:47:01.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lua中有两种闭包-c闭包和lua闭包"><a href="#lua中有两种闭包-c闭包和lua闭包" class="headerlink" title="lua中有两种闭包, c闭包和lua闭包"></a>lua中有两种闭包, c闭包和lua闭包</h4><p>两种闭包的公共部分:</p><pre><code>#define ClosureHeader CommonHeader;\lu_byte isC; \  是否c闭包lua_byte nupvalues; \ upvalue的个数GCObject* gclist; \struct Table env 闭包的环境</code></pre><p>C闭包的结构</p><pre><code>struct CClosure{   ClosureHeader;   lua_CFunction f;   TValue upvalue[1];}</code></pre><p>结构比较简单, f是一个满足 int lua_func(lua_State*) 类型的c函数</p><p>upvalue是创建C闭包时压入的upvalue, 类型是TValue, 可以得知, upvalue可以是任意的lua类型 </p><p>Lua闭包结构</p><pre><code>struct LClosure{  ClosureHeader;  strcut Proto* p;  UpVal* upvals[1];}</code></pre><p>Proto的结构比较复杂, 这里先不做分析</p><p>统一的闭包结构, 一个联合体, 说明一个闭包要么是C闭包, 要么是lua闭包, 这个是用isC表识出来的.</p><pre><code>union Closure{    CClosure c;    LClosure  l;}</code></pre><p> <strong>闭包 == {功能抽象, upvalue, env}</strong> </p><h4 id="向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的"><a href="#向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的" class="headerlink" title="向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的"></a>向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的</h4><p>流程: </p><ol><li><p>创建一个 sizeof(CClosure) + (n - 1) * sizeof(TValue)大小的内存, 这段内存是 CClosure + TValue[n],,  isC= 1 标示其是一个C闭包.</p></li><li><p>c-&gt;f = f绑定c函数.         ———  <strong>闭包.功能抽象 = f</strong></p></li><li><p>env = 当前闭包的env.  ———- <strong>闭包.env = env</strong></p></li><li><p>把栈上的n个元素赋值到c-&gt;upvalue[]数组中, 顺序是越先入栈的值放在upvalue数组的越开始位置, c-&gt;nupvalues指定改闭包upvalue的个数.  ———- <strong>闭包.upvalue = upvalue</strong></p></li><li><p>弹出栈上n个元素, 并压入新建的Closure到栈顶.</p></li></ol><p>整个流程是: 分配内存, 填写属性, 链入gc监控, 绑定c函数, 绑定upvalue, 绑定env一个C闭包就ok了</p><h4 id="C闭包被调用的过程"><a href="#C闭包被调用的过程" class="headerlink" title="C闭包被调用的过程"></a>C闭包被调用的过程</h4><p>lua 闭包调用信息结构:</p><pre><code>struct CallInfo{    StkId base; ----闭包调用的栈基    StkId func; ----要调用的闭包在栈上的位置    StkId top;  ----闭包的栈使用限制    const Instruction *savedpc; ----如果在本闭包中再次调用别的闭包, 那么该值就保存下一条指令以便在返回时继续执行    int nresults; ----闭包要返回的值个数    int tailcalls;----尾递归用, 暂时不管}</code></pre><p>这个结构是比较简单的, 它的作用就是维护一个函数调用的有关信息, 其实和c函数调用的栈帧是一样的, 重要的信息base –&gt; ebp, func –&gt; 要调用的函数的栈index, savedpc –&gt; eip, top, nresults和tailcalls没有明显的对应.</p><p><strong>在lua初始化的时候, 分配了一个CallInfo数组, 并用L-&gt;base_ci指向该数组第一个元素, 用L-&gt;end_ci指向该数组最后一个指针, 用L-&gt;size_ci记录数组当前的大小, L-&gt;ci记录的是当前被调用的闭包的调用信息.</strong></p><p>下面讲解一个c闭包的调用的过程:<br>情景: c 函数</p><pre><code>int lua_test(lua_State* L){    int a = lua_tonumber(L, 1);    int b = lua_tonumber(L, 2);    a = a + b;    lua_pushnumber(L, a);}</code></pre><p>已经注册到了lua 中, 形成了一个C闭包, 起名为”test”, 下面去调用它<br><code>luaL_dostring(L, &quot;c = test(3, 4)&quot;)</code></p><p>调用过程堆栈变化情况如下：</p><p>1.初始栈</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-828474891656030&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2cCI6%2FKUHKD74rb5zUmgnkHU678%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=21047001409346822&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>2.压入了函数和参数的堆栈 </p><pre><code>lua_getglobal(L, “test”)lua_pushnumber(L, 3)lua_pushnumber(L, 4) </code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/fbb22d3ec714edd9bbe59e9f1a727f5b?fid=1259087893-250528-1072131023144167&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-RE7mQ7%2BV8SIVj7JObpxAupx2Kt0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092046924209033410&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>3.调用lua_test开始时的堆栈    lua_call(L,3, 4) </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/88d243fb39e38c3d56cefd3a5b2e3459?fid=1259087893-250528-712458354988681&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-QKj7KqKkVTuusQ8o0UkkVwLDB%2B0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092063733828165106&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>4.调用结束的堆栈 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/ca3dd633932be0c1bb59256e44276e6d?fid=1259087893-250528-574814416488756&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-4jo1Tky2%2FALRP0b%2Bv49ptjJVAgw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092105420285105960&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><ol start="5"><li>取出结果的栈 lua_setglobal(L, “c”)     </li></ol><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-381860168682101&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-WW5zL3p%2Bf6EDOcBSTdSYtECt4cw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092179093472688280&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><h4 id="lua-call函数的过程"><a href="#lua-call函数的过程" class="headerlink" title="lua_call函数的过程"></a>lua_call函数的过程</h4><ol><li>lua具有很强一致性, 不管是dostring, 还是dofile, 都会形成一个闭包, 也就是说, 闭包是lua中用来组织结构的基本构件, 这个特点使得lua中的结构具有一致性, 是一种简明而强大的概念.</li><li>根据1， a = test(3, 4)其实是被组织成为一个闭包放在lua栈顶[方便期间, 给这个lua闭包起名为bb], 也就说dostring真正调用的是bb闭包, 然后bb闭包执行时才调用的是test[保存当前信息到当前函数的CallInfo中]</li><li>在调用test的时刻, L-&gt;ci记载着bb闭包的调用信息, 所以, 先把下一个要执行的指令放在L-&gt;ci-&gt;savedpc中, 以供从test返回后继续执行.</li><li>取栈上的test C闭包 cl, 用 cl-&gt;isC == 1断定它的确是一个C闭包[进入一个新的CallInfo, 布置堆栈]</li><li><p>从L中新分配一个CallInfo ci来记录test的调用信息, 并把它的值设置到L-&gt;ci, 这表明一个新的函数调用开始了, 这里还要指定test在栈中的位置, L-&gt;base = ci-&gt;base = ci-&gt;func+1, 注意, 这几个赋值很重要, 导致的堆栈状态由图2转化到图3, 从图中可以看出, L-&gt;base指向了第一个参数, ci-&gt;base也指向了第一个参数, 所以在test中, 我们调用lua_gettop函数返回的值就是2， 因为在调用它的时候, 它的栈帧上只有2个元素, 实现了lua向c语言中传参数.<br>[调用实际的函数]</p></li><li><p>安排好堆栈, 下面就是根据L-&gt;ci-&gt;func指向的栈上的闭包(及test的C闭包), 找到对应的cl-&gt;c-&gt;f, 并调用, 就进入了c函数lua_test [获取返回值调整堆栈, 返回原来的CallInfo]</p></li><li><p>根据lua_test的返回值, 把test闭包和参数弹出栈, 并把返回值压入并调整L-&gt;top</p></li><li><p>恢复 L-&gt;base, L-&gt;ci 和 L-&gt;savedpc, 继续执行.</p></li></ol><h4 id="调用一个新的闭包时："><a href="#调用一个新的闭包时：" class="headerlink" title="调用一个新的闭包时："></a>调用一个新的闭包时：</h4><ol><li>保存当前信息到当前函数的CallInfo中 （CallInfo函数调用的状态信息）</li><li>进入一个新的CallInfo, 布置堆栈  </li><li>调用实际的函数  </li><li>获取返回值调整堆栈, 返回原来的CallInfo</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;lua中有两种闭包-c闭包和lua闭包&quot;&gt;&lt;a href=&quot;#lua中有两种闭包-c闭包和lua闭包&quot; class=&quot;headerlink&quot; title=&quot;lua中有两种闭包, c闭包和lua闭包&quot;&gt;&lt;/a&gt;lua中有两种闭包, c闭包和lua闭包&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua模块注册</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C/"/>
    <id>https://bytemode.github.io/2018/12/15/lua模块注册/</id>
    <published>2018-12-15T10:19:25.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<p>Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.</p><h4 id="相关的函数index2adr"><a href="#相关的函数index2adr" class="headerlink" title="相关的函数index2adr"></a>相关的函数index2adr</h4><pre><code>static TValue *index2adr (lua_State *L, int idx) {  if (idx &gt; 0) {    TValue *o = L-&gt;base + (idx - 1);    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);    if (o &gt;= L-&gt;top) return cast(TValue *, luaO_nilobject);    else return o;  }  else if (idx &gt; LUA_REGISTRYINDEX) {    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);    return L-&gt;top + idx;  }  else switch (idx) {  /* pseudo-indices */    case LUA_REGISTRYINDEX: return registry(L);    case LUA_ENVIRONINDEX: {      Closure *func = curr_func(L);      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);      return &amp;L-&gt;env;    }    case LUA_GLOBALSINDEX: return gt(L);    default: {      Closure *func = curr_func(L);      idx = LUA_GLOBALSINDEX - idx;      return (idx &lt;= func-&gt;c.nupvalues)                ? &amp;func-&gt;c.upvalue[idx-1]                : cast(TValue *, luaO_nilobject);    }  }}</code></pre><p>一个Lua函数栈由两个指针base和top来指定,base指向函数栈底,top则指向栈顶.<br>回到index2addr函数中,几种情况:</p><ol><li>如果索引为正,则从函数栈底为起始位置向上查找数据</li><li>如果索引为负,则从函数栈顶为起始位置向下查找数据</li><li>紧跟着是几种特殊的索引值,都定义了非常大的数据,由于Lua栈限定了函数的栈尺寸,所以不会有那么大的索引,大可放心使用.</li></ol><p>索引值为LUA_REGISTRYINDEX时,则返回的是全局数据global_state的l_registry表;如果索引值为LUA_GLOBALSINDEX,则返回该Lua_State的l_gt表.</p><h4 id="lua模块注册"><a href="#lua模块注册" class="headerlink" title="lua模块注册"></a>lua模块注册</h4><p>Lua内部所有模块的注册都在linit.c的函数luaL_openlibs中提供.可以看到的是,它依次访问一个数组,数组中定义了每个模块的模块名及相应的模块注册函数,依次调用函数就完成了模块的注册.</p><pre><code>static const luaL_Reg lualibs[] = {  {&quot;&quot;, luaopen_base},  {LUA_LOADLIBNAME, luaopen_package},  {LUA_TABLIBNAME, luaopen_table},  {LUA_IOLIBNAME, luaopen_io},  {LUA_OSLIBNAME, luaopen_os},  {LUA_STRLIBNAME, luaopen_string},  {LUA_MATHLIBNAME, luaopen_math},  {LUA_DBLIBNAME, luaopen_debug},  {NULL, NULL}};LUALIB_API void luaL_openlibs (lua_State *L) {  const luaL_Reg *lib = lualibs;  for (; lib-&gt;func; lib++) {    lua_pushcfunction(L, lib-&gt;func);    lua_pushstring(L, lib-&gt;name);    lua_call(L, 1, 0);  }}</code></pre><p>我没有详细的查看每个模块的注册函数,不过还是以最简单的例子来讲解,就是最常用的print函数.</p><p>由于这个函数没有前缀,因此的它所在的模块是””,也就是一个空字符串,因此它是在base模块中注册的,调用的注册函数是luaopen_base.</p><p>紧跟着继续看luaopen_base内部调用的第一个函数base_open:</p><pre><code>static void base_open (lua_State *L) {  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);  /* open lib into global table */  luaL_register(L, &quot;_G&quot;, base_funcs);  // ....}</code></pre><p>首先来看最前面的两句:</p><pre><code>  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);</code></pre><p>这两句首先将LUA_GLOBALSINDEX对应的值压入栈中,其次调用”lua_setglobal(L, “_G”);”,这句代码的意思是在Lua_state的l_gt表中,当查找”_G”时,查找到的是索引值为LUA_GLOBALSINDEX的表.如果觉得有点绕,可以简单这个理解,在Lua中的G表,也就是全局表,满足这个等式”_G = _G[“_G”]“,也就是这个叫”_G”的表,内部有一个key为”_G”的表是指向自己的.怀疑这个结论的,可以在Lua命令行中执行print(_G)和print(_G[“_G”])看看输出结果是不是一致的.</p><p>Lua中要这么处理的理由是:为了让G表和处理其它表使用同样的机制.查找一个变量时,最终会一直查到G表中,这是很自然的事情;所以为了也能按照这个机制顺利的查找到自己,于是在G表中有一个同名成员指向自己.</p><p>好了,前面两句的作用已经分析完毕.其结果有两个:</p><ol><li>_G = _G[“_G”]</li><li>_G表的值压入函数栈中方便了下面的调用.</li></ol><p>继续看下面的语句:<br><strong>luaL_register(L, “_G”, base_funcs);</strong><br><strong>它最终会将base_funcs中的函数注册到G表中,但是里面还有些细节需要看看的.</strong></p><pre><code>LUALIB_API void luaI_openlib (lua_State *L, const char *libname,                              const luaL_Reg *l, int nup) {  if (libname) {    int size = libsize(l);    /* check whether lib already exists */    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */    if (!lua_istable(L, -1)) {  /* not found? */      lua_pop(L, 1);  /* remove previous result */      /* try global variable (and create one if it does not exist) */      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)        luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);      lua_pushvalue(L, -1);      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */    }    lua_remove(L, -2);  /* remove _LOADED table */    lua_insert(L, -(nup+1));  /* move library table to below upvalues */  }// ...}</code></pre><p>注册这些函数之前,首先会到l_registry表的成员_LOADED表中查找该库,如果不存在则再在G表中查找这个库,不存在则创建一个表.因此,不管是lua中内部的库或者是外部使用require引用的库,都会走这个流程并最终在G表和l_registry[“_LOADED”]中存放该库的表.最后,再遍历传进来的函数指针数组,完成库函数的注册.</p><p>比如,注册os.print时,首先将print函数绑定在一个函数指针上,再去l_registry[“_LOADED”]和G表中查询该名为”os”的库是否存在,不存在则创建一个表,即:<br>G[“os”] = {}</p><p>紧跟着注册print函数,即: G[“os”][“print”] = 待注册的函数指针.这样,在调用lua代码os.print(1)时,首先根据”os”到G表中查找对应的表,再在这个表中查找”print”成员得到函数指针,最后完成函数的调用.</p><h4 id="注册外部模块"><a href="#注册外部模块" class="headerlink" title="注册外部模块"></a>注册外部模块</h4><p><strong>luaL_newlibtable</strong> 它仅仅是创建了一个table,然后把数组里的函数放进去而已 </p><p><strong>luaL_setfuncs</strong>它把数组l中的所有函数注册入<strong>栈顶</strong>的table，并给所有函数绑上<strong>nup</strong>个<strong>upvalue</strong> </p><p>define luaL_newlibtable(L, l)</p><pre><code>lua_createtble(L, 0, sizeof(l)/sizeof((l)[0]) - 1)</code></pre><p>define luaL_newlib(L, l)</p><pre><code>(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0)</code></pre><pre><code>LUALIB_API void luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup){    luaL_checkversion(L);    luaL_checkstack(L, nup, &quot;too_many_upvalue&quot;);    for(; l-&gt;name != NULL; i++){/* fill the table with given functions*/        int i;        for(i = 0; i &lt; nup; i++)/copy upvalues to the top/            lua_pushvalue(L, -nup);        lua_pushclosure(L, l-&gt;func, nup);/closure with those upvalues/        lua_setfield(L, -(nup + 2), l-&gt;name);    }    lua_pop(L, nup);/remove upvalues/}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.&lt;/p&gt;
&lt;h4 id=&quot;相关的函数index2adr&quot;&gt;&lt;a href=&quot;#相关的函数index2adr&quot; class=&quot;headerlink&quot; title=&quot;相关的函数in
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua协程</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%8D%8F%E7%A8%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua协程/</id>
    <published>2018-12-15T09:56:15.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器领域，使用Lua协程最好的范例就是ngx_lua了</p><p>来看看Lua协程内部是如何实现的。</p><p>本质上，每个Lua协程其实也是对应一个LuaState指针，所以其实它内部也是一个完整的Lua虚拟机—有完整的Lua堆栈结构，函数调用栈等等等等，绝大部分之前对Lua虚拟机的分析都可以直接套用到Lua协程中。于是，由Lua虚拟机管理着这些隶属于它的协程，当需要暂停当前运行协程的时候，就保存它的运行环境，切换到别的协程继续执行。很简单的实现。</p><p>来看看相关的API。</p><ol><li>lua_newthread</li></ol><p>创建一个Lua协程，最终会调用的API是luaE_newthread，Lua协程在Lua中也是一个独立的Lua类型数据，它的类型是LUA_TTHREAD，创建完毕之后会照例初始化Lua的栈等结构，有一点需要注意的是，调用preinit_state初始化Lua协程的时候，传入的global表指针是来自于Lua虚拟机，换句话说，任何在Lua协程修改的全局变量，也会影响到其他的Lua协程包括Lua虚拟机本身。</p><ol start="2"><li>加载一个Lua文件并且执行</li></ol><p>对于一般的Lua虚拟机，大可以直接调用luaL_dofile即可，它其实是一个宏：</p><pre><code>#define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>展开来也就是当调用luaL_loadfile函数完成对该Lua文件的解析，并且没有错误时，调用lua_pcall函数执行这个Lua脚本。</p><p>但是对于Lua协程而言，却不能这么做，需要调用luaL_loadfile然后再调用lua_resume函数。所以两者的区别在于lua_pcall函数和lua_resume函数。来看看lua_resume函数的实现。这个函数做的几件事情：首先查看当前Lua协程的状态对不对，然后修改计数器：</p><pre><code> L-&gt;baseCcalls = ++L-&gt;nCcalls;</code></pre><p>其次调用status = luaD_rawrunprotected(L, resume, L-&gt;top – nargs);，可以看到这个保护Lua函数堆栈的调用luaD_rawrunprotected最终调用了函数resume:</p><pre><code>static void resume (lua_State *L, void *ud) {  StkId firstArg = cast(StkId, ud);  CallInfo *ci = L-&gt;ci;  if (L-&gt;status == 0) {  /* start coroutine? */    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)      return;  }  else {  /* resuming from previous yield */    lua_assert(L-&gt;status == LUA_YIELD);    L-&gt;status = 0;    if (!f_isLua(ci)) {  /* `common&#39; yield? */      /* finish interrupted execution of `OP_CALL&#39; */      lua_assert(GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||                 GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);      if (luaD_poscall(L, firstArg))  /* complete it... */        L-&gt;top = L-&gt;ci-&gt;top;  /* and correct top if not multiple results */    }    else  /* yielded inside a hook: just continue its execution */      L-&gt;base = L-&gt;ci-&gt;base;  }  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));}</code></pre><p>这个函数将执行Lua代码的流程划分成了几个阶段，如果调用</p><pre><code>luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA</code></pre><p>那么说明这次调用返回的结果小于0，可以跟进luaD_precall函数看看什么情况下会出现这样的情况：</p><pre><code>    n = (*curr_func(L)-&gt;c.f)(L);  /* do the actual call */    lua_lock(L);    if (n &lt; 0)  /* yielding? */      return PCRYIELD;    else {      luaD_poscall(L, L-&gt;top - n);      return PCRC;    }</code></pre><p>继续回到resume函数中，如果之前该Lua协程的状态是YIELD，那么说明之前被中断了，则调用luaD_poscall完成这个函数的调用。<br>然后紧跟着调用luaV_execute继续Lua虚拟机的继续执行。</p><p>可以看到，resume函数做的事情其实有那么几件：</p><ol><li>如果调用C函数时被YIELD了，则直接返回</li><li>如果之前被YIELD了，则调用luaD_poscall完成这个函数的执行，接着调用luaV_execute继续Lua虚拟机的执行。</li></ol><p>因此，这个函数对于函数执行中可能出现的YIELD，有充分的准备和判断，因此它不像一般的pcall那样，一股脑的往下执行，而是会在出现YIELD的时候保存现场返回，在继续执行的时候恢复现场。<br>3）同时，由于resume函数是由luaD_rawrunprotected进行保护调用的，即使执行出错，也不会造成整个程序的退出。</p><p>这就是Lua协程中，比一般的Lua操作过程做的更多的地方。</p><p>最后给出一个Lua协程的例子：<br>co.lua</p><pre><code>print(&quot;before&quot;)test(&quot;123&quot;)print(&quot;after resume&quot;)</code></pre><p>co.c</p><pre><code> #include     #include &quot;lua.h&quot;    #include &quot;lualib.h&quot;    #include &quot;lauxlib.h&quot;    static int panic(lua_State *state) {      printf(&quot;PANIC: unprotected error in call to Lua API (%s)\n&quot;,              lua_tostring(state, -1));      return 0;    }    static int test(lua_State *state) {      printf(&quot;in test\n&quot;);      printf(&quot;yielding\n&quot;);      return lua_yield(state, 0);    }    int main(int argc, char *argv[]) {      char *name = NULL;      name = &quot;co.lua&quot;;      lua_State*  L1 = NULL;      L1 = lua_open();      lua_atpanic(L1, panic);      luaL_openlibs( L1 );      lua_register(L1, &quot;test&quot;, test);      lua_State*  L = lua_newthread(L1);      luaL_loadfile(L, name);      lua_resume(L, 0);      printf(&quot;sleeping\n&quot;);      sleep(1);      lua_resume(L, 0);      printf(&quot;after resume test\n&quot;);      return 0;    }</code></pre><p>你可以使用coroutine.create来创建协程,协程有三种状态：挂起，运行，停止。创建后是挂起状态，即不自动运行。status函数可以查看当前状态。协程真正强大的地方在于他可以通过yield函数将一段正在运行的代码挂起。</p><p>lua的resume-yield可以互相交换数据</p><pre><code>co = coroutine.create(function (a, b)     coroutine.yield(a+b, a-b)end)print(coroutine.resume(co, 3, 8))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表类型</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%A1%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua表类型/</id>
    <published>2018-12-15T09:51:02.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lua的表的定义"><a href="#Lua的表的定义" class="headerlink" title="Lua的表的定义:"></a>Lua的表的定义:</h4><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>这里将Table分为了两个部分:数组部分,array指针指向数组部分的首地址,sizearray是数组的尺寸,绝大部分(注意:不是全部)正整数为key的数据都存放在数组部分;node指针指向一个hash桶,对于不能存放在数组部分的数据,都存放在hash中.如下图所示:<br><img src="https://thumbnail0.baidupcs.com/thumbnail/46eff62f24b48c0dd2380abaa949cb84?fid=1259087893-250528-534280502274275&amp;time=1544864400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-KcBURzIEUOljxyzUWcN5%2FL3uieo%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=17866885042028318&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>hash部分需要特别注意的一点是:在物理上,所有hash部分的数据,其实是存放一块连续的内存中的,即node指针指向的数组;但是从逻辑上来看,如果几块数据在同一个hash桶上,那么又是通过next指针串联起来的.<br>以图中的示例来分析,node数组的第一个和第三个元素,在物理上是第一和第三个元素,但是在逻辑上,它们是通过next指针串联起来的.</p><h4 id="Table查找数据"><a href="#Table查找数据" class="headerlink" title="Table查找数据"></a>Table查找数据</h4><p>有了以上的了解,从Table中查找一个数据的伪代码就很显而易见了:</p><p>如果输入的Key是一个正整数,并且它的值 &gt; 0 &amp;&amp; &lt;= 数组大小<br>    尝试在数组部分查找<br>否则尝试在Hash部分进行查找:<br>    计算出该Key的Hash值(ltable.c中的mainposition函数),根据此Hash值访问node数组得到Hash桶所在位置<br>    遍历该Hash桶下的所有链表元素,直到找到该Key为止<br>以上已经明白了Table的大致结构,来看看Table中如果新加入新的数据会怎么处理.这里有一些内容,要留到后面讲解到Lua虚拟机的时候才触及,这里先讲解一下,当新插入数据时,Table内的数组和Hash部分,做了哪些变化.</p><p>这部分中,核心的算法在ltable.c的rehash函数中,这个函数是计算当新添加数据时,数组和hash重新分配之后各自的尺寸是多少,伪代码如下:</p><p>首先分配一个位图nums,将其中的所有位置0,这个位图的意义在于:nums数组中第i个元素存放的是key在2^(i-1), 2^i之间的元素数量<br>遍历lua Table中的数组部分,计算在数组部分中的元素数量,更新对应的nums数组元素数量.(numusearray函数)<br>遍历lua Table中的Hash部分,因为其中也可能存放了正整数,也根据这里的正整数数量更新对应的nums数组元素数量.(numusehash函数)<br>此时nums数组已经有了当前这个Table中所有正整数的分配统计,逐个遍历nums数组,如果当前已经有的根据新的数组大小和Hash大小重新分配table的大小(computesizes函数)<br>这里要特别讲解的是computesizes函数,在前面的两个函数调用numusearray函数和numusehash函数之后,此时在nums位图中,已经存放了所有有关整数key的信息,即在[2^(i-1), 2^i]范围内,有多少数据.前面曾经提到过,并不是所有的正整数,都会存放在数组部分的,即使它曾经在,也有可能在之后被分配到hash部分,那么判断的依据是什么?到底怎样的数据,在重新分配之后会从数组部分挪到hash部分?<br>来看computesizes函数的实现:</p><pre><code>static int computesizes (int nums[], int *narray) {  int i;  int twotoi;  /* 2^i */  int a = 0;  /* number of elements smaller than 2^i */  int na = 0;  /* number of elements to go to array part */  int n = 0;  /* optimal size for array part */  for (i = 0, twotoi = 1; twotoi/2 &lt; *narray; i++, twotoi *= 2) {    if (nums[i] &gt; 0) {      a += nums[i];      if (a &gt; twotoi/2) {  /* more than half elements present? */        n = twotoi;  /* optimal size (till now) */        na = a;  /* all elements smaller than n will go to array part */      }    }    if (a == *narray) break;  /* all elements already counted */  }  *narray = n;  lua_assert(*narray/2 &lt;= na &amp;&amp; na &lt;= *narray);  return na;}</code></pre><p>注意到这样的细节:这个函数在遍历nums位图数组的时候,会将当前数据数量存放在变量a中,如果a &gt; twotoi/2,也就是当前有一半以上的空间被利用上了,那么这部分数据会继续留在数组部分,否则就会在之后挪到hash部分了.</p><h4 id="纯粹的使用数组或者hash表性能更高"><a href="#纯粹的使用数组或者hash表性能更高" class="headerlink" title="纯粹的使用数组或者hash表性能更高"></a>纯粹的使用数组或者hash表性能更高</h4><p>为了证实这里的判断,简单的写一段lua代码做为实验:</p><pre><code>function print_ipairs(t)  print(&quot;in print_ipairs&quot;)  for k, v in ipairs(t) do    print(k)  endend function print_pairs(t)  print(&quot;in print_pairs&quot;)  for k, v in pairs(t) do    print(k)  endend a = {}a={1,2,3,4,5,6,7,8,9,10}print_ipairs(a)a[2] = nila[3] = nila[4] = nila[6] = nila[&quot;k&quot;] = &quot;e&quot;print_ipairs(a)print_pairs(a)输出为:in print_ipairs12345678910in print_ipairs1in print_pairs17810k59</code></pre><p>在这里,首先对表a赋值,有1-10共十个元素,通过调用函数print_ipairs可知,这些元素都是存放在数组部分的,这是因为ipairs取的是Table的数组部分元素.<br>在这之后,人为的将其中2,3,4,6元素删除,造成原来数组不满一半元素被利用上的现象,然后再插入一个新key “k”,以让这个Table重新分配空间.再此之后,再次调用ipairs遍历a的数组部分,可以看到只有1被打印出来了,也就是说,在重新分配空间之后,除去已经被删除的2,3,4,6之外,只有1还在数组里面,剩下的5,7,8,9,10已经不在数组部分了.紧接着调用pairs遍历这个表,可以看出这些已经不在数组部分的值又被打印出来了,并且它们的顺序已经被打乱,不再按照数字大小顺序来排列了,它们在这次重新分配中被挪动到了hash部分.</p><p>这个实验既验证了我们前面的分析,同时也告诉我们,Table的重新分配,实际上代价是很大的,因此不建议在实际程序中,一个Table即有数组部分,也有Hash部分,纯粹一些,性能上会有提升.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Lua的表的定义&quot;&gt;&lt;a href=&quot;#Lua的表的定义&quot; class=&quot;headerlink&quot; title=&quot;Lua的表的定义:&quot;&gt;&lt;/a&gt;Lua的表的定义:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef struct Table {
  CommonHeade
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua通用数据类型</title>
    <link href="https://bytemode.github.io/2018/12/15/LUA%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/LUA的通用数据类型/</id>
    <published>2018-12-15T06:57:00.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TValue结构"><a href="#TValue结构" class="headerlink" title="TValue结构"></a>TValue结构</h4><p>TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.很容易想到,在面向对象中,这个结构体是一个基类,派生出来的都是其他的子类.</p><p>TValue结构体内部有几个宏, 展开之后就是这样的:</p><pre><code>typedef struct lua_TValue {    union {      union GCObject {        struct GCheader {          GCObject *next; lu_byte tt; lu_byte marked;        } gch;        union TString ts;        union Udata u;        union Closure cl;        struct Table h;        struct Proto p;        struct UpVal uv;        struct lua_State th;  /* thread */      } gc;      void *p;      lua_Number n;      int b;    } value;    int tt;} TValue;</code></pre><p>这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int.</p><h4 id="gc-union"><a href="#gc-union" class="headerlink" title="gc union"></a>gc union</h4><p>gc union的定义,可以看到各种可gc的类型(Tstring,Udata..etc)和一个GCHeader放在 一起,也就是说,当这部分还是数据的时候,数据部分启用,否则就是gc部分了.这里的GCHeader包括了三个部分:next指针将可gc的数据串联成链表,tt表示数据类型,marked存放的gc处理时的颜色值.<br>这是另一种方式的使用C语言实现的面向对象,对外部而言,TValue结构体可以看作是”基类”,真正进行处理时,再根据数据类型决定到底使用value union中的哪个数据部分.可以看到lua源代码中定义了很多宏就是这样操作Tvalue数据指针的,比如:</p><pre><code>#define hvalue(o)    check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)</code></pre><p>这个宏定义了如何从TValue指针得到Table结构体:首先判断数据类型是Table,然后将value的gc union中Table *h取出.</p><p>反之,要从一个具体的类型转换再赋值为相应的TValue,Lua源代码中也提供了相应的宏.因为TValue结构体的中的value域是一个union,所以其实随便强制转换为其中的哪一种类型都可以,不过看上去最舒服的写法还是直接转换为公共类型GCObject了,比如:</p><pre><code>#define setsvalue(L,obj,x) \  { TValue *i_o=(obj); \    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \checkliveness(G(L),i_o); }</code></pre><h4 id="GCObject"><a href="#GCObject" class="headerlink" title="GCObject"></a>GCObject</h4><pre><code>union GCObject {  GCheader gch;  union TString ts;  union Udata u;  union Closure cl;  struct Table h;  struct Proto p;  struct UpVal uv;  struct lua_State th;  /* thread */};</code></pre><p>其中的GCheader展开是这样的:</p><pre><code>typedef struct GCheader {  CommonHeader;} GCheader;</code></pre><p>而随便抽在GCObject结构体中的数据类型结构体定义,都发现也包含了一个CommonHeader结构体,比如:</p><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>换言之,在GCObject中,无论是哪个数据结构体,都自己有一份CommonHeader.仔细观察,其实GCObject这个union的内存分布,最开始部分无论如何都是留给CommonHeader的.这样做,就保证了一个存放在TValue结构体中的数据,既可以使用CommonHeader关于GC的部分,也可以使用到自己本身的数据部分了.</p>]]></content>
    
    <summary type="html">
    
      TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int. gc联合体部分就是GCobject
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua栈</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A0%88/"/>
    <id>https://bytemode.github.io/2018/12/15/lua栈/</id>
    <published>2018-12-15T06:56:54.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.</p><p>lua虚拟机在初始化创建lua_State结构体时,会走到stack_init函数中,这个函数主要就是对Lua栈和CallInfo数组的初始化:</p><pre><code>static void stack_init (lua_State *L1, lua_State *L) {  /* initialize CallInfo array */  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);  L1-&gt;ci = L1-&gt;base_ci;  L1-&gt;size_ci = BASIC_CI_SIZE;  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;  /* initialize stack array */  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;  L1-&gt;top = L1-&gt;stack;  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;  /* initialize first ci */  L1-&gt;ci-&gt;func = L1-&gt;top;  setnilvalue(L1-&gt;top++);  /* `function&#39; entry for this `ci&#39; */  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;}</code></pre><p>可以看到的是,初始化了两个数组,分别保存Lua栈和CallInfo结构体数组.<br>其中,与Lua栈相关的lua_State结构体成员变量有base,stack,top,lastfree,stack保存的是数组的初始位置,base会根据每次函数调用的情况发生变化,top指针指向的是当前第一个可用的栈位置,每次向栈中增加/删减元素都要对应的增减top指针,lastfee指针指向的书Lua栈的最后位置.</p><p>CallInfo结构体,是每次有函数调用时都会去初始化的一个结构体,它的成员变量中,也有top,base指针,同样的是指向Lua栈的位置,所不同的是,它关注的仅是函数调用时的相关位置.从代码中可以看出,CallInfo数组是有限制的,换言之,在Lua中的嵌套函数调用层次也是有限制,不能超过一定数量.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215144229849-16830691.png" alt=""></p><p>首先看f_parser函数:</p><pre><code>static void f_parser (lua_State *L, void *ud) {  int i;  Proto *tf;  Closure *cl;  struct SParser *p = cast(struct SParser *, ud);  int c = luaZ_lookahead(p-&gt;z);  luaC_checkGC(L);  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                             &amp;p-&gt;buff, p-&gt;name);  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));  cl-&gt;l.p = tf;  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */    cl-&gt;l.upvals[i] = luaF_newupval(L);  setclvalue(L, L-&gt;top, cl);  incr_top(L);}</code></pre><p>f_parser函数的最后两句,将分析完毕之后的结构Closure指针压入了Lua栈.</p><p>再来看luaD_precall函数,这里为将代码放入Lua虚拟机中执行准备了相关数据,我们只截取其中的一部分来看:</p><pre><code>int luaD_precall (lua_State *L, StkId func, int nresults) {  ….  if (!cl-&gt;isC) {  /* Lua function? prepare its call */    CallInfo *ci;    StkId st, base;    Proto *p = cl-&gt;p;// 1) 根据函数的参数类型,计算出该CallInfo的base指针位置    if (!p-&gt;is_vararg) {  /* no varargs? */      base = func + 1;      if (L-&gt;top &gt; base + p-&gt;numparams)        L-&gt;top = base + p-&gt;numparams;    }    else {  /* vararg function */      int nargs = cast_int(L-&gt;top - func) - 1;      base = adjust_varargs(L, p, nargs);      func = restorestack(L, funcr);  /* previous call may change the stack */}// 2) 分配一个新的CallInfo结构体,用于保存此次函数调用的相关信息:top,base指针,func函数    ci = inc_ci(L);  /* now `enter&#39; new function */    ci-&gt;func = func;    L-&gt;base = ci-&gt;base = base;    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);    // 3) LuaState的PC指针指向函数原型的代码数组    L-&gt;savedpc = p-&gt;code;  /* starting point */    // …..    return PCRLUA;  }</code></pre><p>到这一步,跟某次具体的Lua代码执行相关的代码(保存在Proto的code数组中)和执行时所需环境(Lua栈),就已经准备完毕了.后面就是进入Lua虚拟机的主循环中解释执行代码了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.&lt;/p&gt;
&lt;p&gt;lua虚拟机在初始化创建lua_State结构体
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数与upavalue</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E4%B8%8Eupavalue/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数与upavalue/</id>
    <published>2018-12-15T06:35:14.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。</p><p>函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：</p><pre><code>static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {  FuncState *fs = ls-&gt;fs;  Proto *f = fs-&gt;f;  int oldsize = f-&gt;sizep;  int i;  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,                  MAXARG_Bx, &quot;constant table overflow&quot;);  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;  f-&gt;p[fs-&gt;np++] = func-&gt;f;  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));  for (i=0; if-&gt;nups; i++) {    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);  }}</code></pre><p>注意在这个函数的最后，将遍历upvalue数组，根据该upvalue是否是局部变量，来决定紧跟着的是MOVE指令还是GETUPVAL指令。而这些是如何确定的呢？</p><p>Lua的分析器在解析到一个变量时，会调用singlevaraux函数进行查找：</p><pre><code>static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {  if (fs == NULL) {  /* no more levels? */    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */    return VGLOBAL;  }  else {    int v = searchvar(fs, n);  /* look up at current level */    if (v &gt;= 0) {      init_exp(var, VLOCAL, v);      if (!base)        markupval(fs, v);  /* local will be used as an upval */      return VLOCAL;    }    else {  /* not found at current level; try upper one */      if (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)        return VGLOBAL;      var-&gt;u.s.info = indexupvalue(fs, n, var);  /* else was LOCAL or UPVAL */      var-&gt;k = VUPVAL;  /* upvalue in this level */      return VUPVAL;    }  }}</code></pre><p>可以看到，这个函数是一个递归函数，有以下几种情况：</p><ol><li>在函数的当前层找到该变量，则认为一个LOCAL变量</li><li>在函数的上层找到，则认为一个UPVAL</li><li>最后，则认为是一个全局变量。</li></ol><p>如何定义函数的“层次”？来看一个例子就知道了:</p><pre><code>local a = 1function test1()  local b = 100  function test2()     print(a)     print(b)  endendtest1()</code></pre><p>在这个例子中，函数test2与变量b是同层的，所以在调用函数test2时，singlevaraux查找变量b返回的LOCAL变量；而变量a是更上一层的LOCAL变量，对于函数test2而言，它就是UPVAL。</p><p>明白了解析部分是怎么处理upvalue的，来看看在虚拟机中是如何处理的。<br>对应的代码在lvm.c中的这一部分：</p><pre><code>      case OP_CLOSURE: {        Proto *p;        Closure *ncl;        int nup, j;        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];        nup = p-&gt;nups;        ncl = luaF_newLclosure(L, nup, cl-&gt;env);        ncl-&gt;l.p = p;        for (j=0; jl.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];          else {            lua_assert(GET_OPCODE(*pc) == OP_MOVE);            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));          }        }        setclvalue(L, ra, ncl);        Protect(luaC_checkGC(L));        continue;      }</code></pre><p>当变量是UPVAL时，此时PC指令对应的B参数是函数结构体的upval数组的索引，根据它直接从upval数组中取出值来；否则，PC指令对应的B参数是基于函数基地址base的一个偏移量，根据它得到相应的变量；再调用函数luaF_findupval：</p><pre><code>UpVal *luaF_findupval (lua_State *L, StkId level) {  global_State *g = G(L);  GCObject **pp = &amp;L-&gt;openupval;  UpVal *p;  UpVal *uv;  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) {    lua_assert(p-&gt;v != &amp;p-&gt;u.value);    if (p-&gt;v == level) {  /* found a corresponding upvalue? */      if (isdead(g, obj2gco(p)))  /* is it dead? */        changewhite(obj2gco(p));  /* ressurect it */      return p;    }    pp = &amp;p-&gt;next;  }  uv = luaM_new(L, UpVal);  /* not found: create a new one */  uv-&gt;tt = LUA_TUPVAL;  uv-&gt;marked = luaC_white(g);  uv-&gt;v = level;  /* current value lives in the stack */  uv-&gt;next = *pp;  /* chain it in the proper position */  *pp = obj2gco(uv);  uv-&gt;u.l.prev = &amp;g-&gt;uvhead;  /* double link it in `uvhead&#39; list */  uv-&gt;u.l.next = g-&gt;uvhead.u.l.next;  uv-&gt;u.l.next-&gt;u.l.prev = uv;  g-&gt;uvhead.u.l.next = uv;  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);  return uv;}</code></pre><p>注意到，传入这个函数的参数level，其实是前面已经根据base基址定位到的变量。这个函数分为两个部分：</p><ol><li>首先，遍历当前的openupval数组，查找这个变量。由于这个变量肯定是前面已经定义过的，所以查找的条件就是（(p = ngcotouv(*pp))-&gt;v &gt;= level）。当查找到这个变量时，如果是准备释放的变量，则将它重新置为不可释放。</li><li>如果在openval数组中没有找到，说明之前没有别的地方引用过这个upval。如此则重新分配一个upvalue指向待引用的值。</li><li>最后，当函数调用完毕时，有相应的close指令，将upvalue的引用关系去除。具体见函数luaF_close。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。&lt;/p&gt;
&lt;p&gt;函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua虚拟机概述</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>https://bytemode.github.io/2018/12/15/lua虚拟机概述/</id>
    <published>2018-12-15T05:42:38.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为虚拟机"><a href="#何为虚拟机" class="headerlink" title="何为虚拟机"></a>何为虚拟机</h4><p>用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型的语言,经过前端的处理之后,生成的就是opcode,再将该opcode放在这门语言的虚拟机中执行.虚拟机是作为单独的程序独立存在,而Lua由于是一门嵌入式的语言是附着在宿主环境中的.   </p><h3 id="lua代码到虚拟机执行的流程"><a href="#lua代码到虚拟机执行的流程" class="headerlink" title="lua代码到虚拟机执行的流程"></a>lua代码到虚拟机执行的流程</h3><p><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215140547779-1286988518.png" alt=""></p><p>在Lua中,Lua代码从词法分析到语法分析再到生成opcode,最后进入虚拟机执行的大体流程是什么样子的呢？</p><p>Lua的API中提供了luaL_dofile函数,它实际上是个宏,内部首先调用luaL_loadfile函数,加载Lua代码进行语法,词法分析,生成Lua虚拟机可执行的代码,再调用lua_pcall函数,执行其中的代码:</p><pre><code>    #define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>前半部分调用luaL_loadfile函数对Lua代码进行词法和语法分析,后半部分调用lua_pcall将第一步中分析的结果(也就是opcode)到虚拟机中执行.</p><p>首先来看luaL_loadfile函数,暂时不深入其中研究它如何分析一个Lua代码文件,先看它最后输出了什么.它最终会调用f_parser函数,这是对一个Lua代码进行分析的入口函数:</p><pre><code>    static void f_parser (lua_State *L, void *ud) {      int i;      Proto *tf;      Closure *cl;      struct SParser *p = cast(struct SParser *, ud);      int c = luaZ_lookahead(p-&gt;z);      luaC_checkGC(L);      tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                                 &amp;p-&gt;buff, p-&gt;name);      cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));      cl-&gt;l.p = tf;      for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */        cl-&gt;l.upvals[i] = luaF_newupval(L);      setclvalue(L, L-&gt;top, cl);      incr_top(L);    }</code></pre><p>在完成词法分析之后,返回了Proto类型的指针tf,然后将其绑定在新创建的Closure指针上,初始化UpValue,最后压入Lua栈中.</p><p>不难想像,Lua词法分析之后产生的opcode等相关数据都在这个Proto类型的结构体中.</p><p>再来看lua_pcall函数是如何将产生的opcode放入虚拟机执行的.</p><p>lua_pcall函数中,首先获取需要调用的函数指针:</p><pre><code>    c.func = L-&gt;top - (nargs+1);  /* function to be called */</code></pre><p>这里的nargs是由函数参数传入的,luaL_dofile中调用lua_pcall时这里传入的参数是0,换句话说,这里得到的函数对象指针就是在f_parser函数中最后放入Lua栈的指针.</p><p>继续往下执行,走到luaD_call函数,有这一段代码:</p><pre><code>      if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */        luaV_execute(L, 1);  /* call it */</code></pre><p>进入luaV_execute函数,这里是虚拟机执行代码的主函数:</p><pre><code>    void luaV_execute (lua_State *L, int nexeccalls) {      LClosure *cl;      StkId base;      TValue *k;      const Instruction *pc;     reentry:  /* entry point */      lua_assert(isLua(L-&gt;ci));      pc = L-&gt;savedpc;      cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;      base = L-&gt;base;      k = cl-&gt;p-&gt;k;      /* main loop of interpreter */      for (;;) {        const Instruction i = *pc++;        StkId ra;        if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;            (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {          traceexec(L, pc);          if (L-&gt;status == LUA_YIELD) {  /* did hook yield? */            L-&gt;savedpc = pc - 1;            return;          }          base = L-&gt;base;        }        /* warning!! several calls may realloc the stack and invalidate `ra&#39; */        ra = RA(i);    // 以下是各种opcode的情况处理    }</code></pre><p>可以看到,这里的pc指针里存放的是虚拟机opcode代码,它最开始从L-&gt;savepc初始化而来,而L-&gt;savepc在luaD_precall中赋值:</p><pre><code>    L-&gt;savedpc = p-&gt;code;  /* starting point */</code></pre><p>这里的p就是第一步f_parser中返回的Proto指针.</p><p>回顾一下整个流程:</p><ol><li><p>函数f_parser中,对Lua代码文件的分析返回了Proto指针</p></li><li><p>函数luaD_precall中,将Lua_state的savepc指针指向1中的Proto结构体的code指针</p></li><li><p>函数luaV_execute中,pc指针指向2中的savepc指针,紧跟着就是一个大的循环体,依次取出其中的opcode进行执行.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215141251439-1865045097.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;何为虚拟机&quot;&gt;&lt;a href=&quot;#何为虚拟机&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机&quot;&gt;&lt;/a&gt;何为虚拟机&lt;/h4&gt;&lt;p&gt;用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数定义</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数定义/</id>
    <published>2018-12-15T05:24:49.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="FuncState"><a href="#FuncState" class="headerlink" title="FuncState"></a>FuncState</h4><p>proto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue</p><p>Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的FuncState数据.这个结构体的定义:</p><pre><code>typedef struct FuncState {  Proto *f;  /* current function header */  Table *h;  /* table to find (and reuse) elements in  */  struct FuncState *prev;  /* enclosing function */  struct LexState *ls;  /* lexical state */  struct lua_State *L;  /* copy of the Lua state */  struct BlockCnt *bl;  /* chain of current blocks */  int pc;  /* next position to code (equivalent to `ncode&#39;) */  int lasttarget;   /* `pc&#39; of last `jump target&#39;  */  int jpc;  /* list of pending jumps to `pc&#39; */  int freereg;  /* first free register */  int nk;  /* number of elements in `k&#39;  */  int np;  /* number of elements in `p&#39;  */  short nlocvars;  /* number of elements in `locvars&#39; */  lu_byte nactvar;  /* number of active local variables  */  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */} FuncState;</code></pre><p>其中的Proto结构体数组用于保存函数原型信息,包括函数体代码(opcode),之所以使用数组,是因为在某个函数内,可能存在多个局部函数.而prev指针就是指向这个函数的”父函数体”的指针.</p><p>比如以下代码:</p><pre><code>function fun()   function test()   endend</code></pre><p>那么,在保存test函数原型的Proto数据就存放在保存fun函数的FuncState结构体的p数组中,反之,保存test函数的FuncState.prev指针就指向保存func函数的FuncState指针.</p><p>接着看Funcstate结构体的成员,actvar数组用于保存局部变量,比如函数的参数就是保存在这里.另外还有一个存放upval值的upvalues数组.这里有两种不同的处理.如果这个upval是父函数内的局部变量,则生成的是MOVE指令用于赋值;如果对于父函数而言也是它的upval,则生成GET_UPVAL指令用于赋值.</p><p>当开始处理一个函数的定义时,首先调用open_func函数,创建一个新的Proto结构体用于保存函数原型信息,接着将该函数的FuncState的prev指针指向父函数.<br>最后当函数处理完毕时,调用pushclosure函数将这个新的函数的信息push到父函数的Proto数组中.</p><h4 id="函数也是第一类值-可以存在变量里"><a href="#函数也是第一类值-可以存在变量里" class="headerlink" title="函数也是第一类值 可以存在变量里"></a>函数也是第一类值 可以存在变量里</h4><p>最后,由于函数在Lua中是所谓的”first class type”,所以其实以下两段Lua代码是等价的:</p><pre><code>local function test()  -- 可以testend--以上相当于 local test； test = function() ...  endlocal test = function ()   --不可以调用test 以为第一类之定义完成之后才可以使用end</code></pre><p>也就是说,其实是生成一段代码,用于保存函数test的相关信息,之后再将这些信息赋值给变量test,这里的test可以是local,也可以是global的,这一点跟一般的变量无异.</p><h4 id="函数定义词法分析"><a href="#函数定义词法分析" class="headerlink" title="函数定义词法分析"></a>函数定义词法分析</h4><p>所以在与函数定义相关的词法分析代码中:</p><pre><code>static void funcstat (LexState *ls, int line) {  /* funcstat -&gt; FUNCTION funcname body */  int needself;  expdesc v, b;  luaX_next(ls);  /* skip FUNCTION */  needself = funcname(ls, &amp;v);  body(ls, &amp;b, needself, line);  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);  luaK_fixline(ls-&gt;fs, line);  /* definition `happens&#39; in the first line */}</code></pre><p>上面的变量v首先在funcname函数中获得该函数的函数名,变量b在进入函数body之后可以得到函数体相关的内容.在这之后的luaK_storevar调用,就是把b的值赋值给v,也就是前面提到的函数体赋值给函数名.</p>]]></content>
    
    <summary type="html">
    
      函数是第一类值，函数定义有funcstate结构表示，其中包含父函数指针，函数原型数组信息；actvar局部变量数组，upvalues保存upvalue数组信息。
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua字符串类型</title>
    <link href="https://bytemode.github.io/2018/12/14/lua%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://bytemode.github.io/2018/12/14/lua字符串/</id>
    <published>2018-12-14T14:25:11.000Z</published>
    <updated>2018-12-27T08:12:07.822Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中字符串结构体的定义是:</p><pre><code>typedef union TString {  L_Umaxalign dummy;  /* ensures maximum alignment for strings */  struct {    CommonHeader;    lu_byte reserved;    unsigned int hash;    size_t len;  } tsv;} TString;</code></pre><p>这里TString结构体是一个union, 最开始的L_Umaxalign dummy;起到的是对齐作用.紧跟着是CommonHeader,可以看出TString也是可GC数据类型的一种.</p><p>在Lua中,字符串是一个保存在一个全局的地方,在globale_state的strt里面,这是一个hash数组,专门用于存放字符串:</p><pre><code>typedef struct stringtable {  GCObject **hash;  lu_int32 nuse;  /* number of elements */  int size;} stringtable;</code></pre><p>一个字符串TString,首先根据hash算法算出hash值,这就是stringtable中hash的索引值,如果这里已经有元素,则使用链表串接起来.</p><p>同时,TString中的字段reserved,表示这个字符串是不是保留字符串,比如Lua的关键字,在最开始赋值的时候是这么处理的:</p><pre><code>void luaX_init (lua_State *L) {  int i;  for (i=0; itsv.reserved = cast_byte(i+1);  /* reserved word */  }}</code></pre><p>这里存放的值,是数组luaX_tokens中的索引:</p><pre><code>const char *const luaX_tokens [] = {    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;,    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,    &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,    NULL};</code></pre><p>一方面可以迅速定位到是哪个关键字,另方面如果这个reserved字段不为0,则表示该字符串是不可自动回收的,在GC过程中会略过这个字符串的处理.</p><p>具体查找字符串时,首先计算出hash值,定位到所在的strt中的hash数组所在,再遍历hash桶所在链表,首先比较长度,如果相同再继续逐字节的比较字符串内容:</p><pre><code>TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {  GCObject *o;  unsigned int h = cast(unsigned int, l);  /* seed */  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don&#39;t hash all its chars */  size_t l1;  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-1]));  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];       o != NULL;       o = o-&gt;gch.next) {    TString *ts = rawgco2ts(o);    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0)) {      /* string may be dead */      if (isdead(G(L), o)) changewhite(o);      return ts;    }  }  return newlstr(L, str, l, h);  /* not found */}</code></pre>]]></content>
    
    <summary type="html">
    
      lua字符串结构体是TString，TString里的记录了hash值和字符串长度，真正的字符串是存储在全局globale_state的stringtable里面，这是一个gcobject组成的hash表.
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua-pcall的实现</title>
    <link href="https://bytemode.github.io/2018/12/13/lua-pcall%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://bytemode.github.io/2018/12/13/lua-pcall的实现/</id>
    <published>2018-12-13T05:24:24.000Z</published>
    <updated>2018-12-13T05:30:12.410Z</updated>
    
    <content type="html"><![CDATA[<p>Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。</p><p>对比起一般的函数调用方式，pcall多做了这些事情：</p><p>对函数调用前的Lua堆栈进行保护在调用完毕之后恢复，支持传入出错时的函数在调用出错时调用。</p><p>来依次看这个过程。</p><ol><li>首先看入口函数lua_pcall：</li></ol><pre><code>LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {  struct CallS c;  int status;  ptrdiff_t func;  lua_lock(L);  api_checknelems(L, nargs+1);  checkresults(L, nargs, nresults);  if (errfunc == 0)    func = 0;  else {    StkId o = index2adr(L, errfunc);    api_checkvalidindex(L, o);    func = savestack(L, o);  }  c.func = L-&gt;top - (nargs+1);  /* function to be called */  c.nresults = nresults;  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);  adjustresults(L, nresults);  lua_unlock(L);  return status;}</code></pre><p>lua_pcall函数与lua_call相比，多了第四个参数，该函数用于传入错误处理函数在Lua栈中的地址。所以第一步将根据传入的参数得到它的值在函数栈中的地址。然后根据这些参数调用函数luaD_pcall函数。</p><ol start="2"><li>luaD_pcall的实现</li></ol><pre><code>int luaD_pcall (lua_State *L, Pfunc func, void *u,                ptrdiff_t old_top, ptrdiff_t ef) {  int status;  unsigned short oldnCcalls = L-&gt;nCcalls;  ptrdiff_t old_ci = saveci(L, L-&gt;ci);  lu_byte old_allowhooks = L-&gt;allowhook;  ptrdiff_t old_errfunc = L-&gt;errfunc;  L-&gt;errfunc = ef;  status = luaD_rawrunprotected(L, func, u);  if (status != 0) {  /* an error occurred? */    StkId oldtop = restorestack(L, old_top);    luaF_close(L, oldtop);  /* close eventual pending closures */    luaD_seterrorobj(L, status, oldtop);    L-&gt;nCcalls = oldnCcalls;    L-&gt;ci = restoreci(L, old_ci);    L-&gt;base = L-&gt;ci-&gt;base;    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;    L-&gt;allowhook = old_allowhooks;    restore_stack_limit(L);  }  L-&gt;errfunc = old_errfunc;  return status;}</code></pre><p>这个函数首先将一些需要保存以便以后进行错误恢复的值保存，然后调用函数luaD_rawrunprotected。</p><ol start="3"><li>在luaD_rawrunprotected中，</li></ol><pre><code>int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {  struct lua_longjmp lj;  lj.status = 0;  lj.previous = L-&gt;errorJmp;  /* chain new error handler */  L-&gt;errorJmp = &amp;lj;  LUAI_TRY(L, &amp;lj,    (*f)(L, ud);  );  L-&gt;errorJmp = lj.previous;  /* restore old error handler */  return lj.status;}</code></pre><p>可以看到的是，在Lua中，涉及到这些错误恢复的数据，实际上形成一个链条关系，这个函数首先将之前的错误链保存起来。而LUAI_TRY这个宏，会根据不同的编译器进行实现，比如C++中使用的try…catch，C中使用longjmp等。</p><ol start="4"><li>再来看看真正出错的时候是如何处理的。</li></ol><pre><code>void luaG_errormsg (lua_State *L) {  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */    StkId errfunc = restorestack(L, L-&gt;errfunc);    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);    setobjs2s(L, L-&gt;top, L-&gt;top - 1);  /* move argument */    setobjs2s(L, L-&gt;top - 1, errfunc);  /* push function */    incr_top(L);    luaD_call(L, L-&gt;top - 2, 1);  /* call it */  }  luaD_throw(L, LUA_ERRRUN);}</code></pre><p><strong>首先如果之前保存的errfunc不为空，则首先从Lua栈中得到该函数，如果判断这个地址存放的不是一个函数则直接抛出错误。否则将错误参数压入栈中调用该错误处理函数。最后调用LuaD_throw函数，这个函数与前面的LUAI_TRY宏是对应的。这样就可以回到原来保存的错误恢复地点，恢复调用前的Lua栈，继续执行下去，而不是导致宿主进程退出。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt;
&lt;p&gt;对比起一般的函数调用方式，pcall多做了这些事情：&lt;/p&gt;
&lt;p&gt;对函数调用前的
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表的创建和初始化</title>
    <link href="https://bytemode.github.io/2018/12/13/lua%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://bytemode.github.io/2018/12/13/lua表的创建和初始化/</id>
    <published>2018-12-13T05:11:44.000Z</published>
    <updated>2018-12-13T05:21:36.681Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表的基本实现"><a href="#表的基本实现" class="headerlink" title="表的基本实现"></a>表的基本实现</h4><p>在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为数组部分和hash部分。比如：</p><pre><code>local t = {1,2,3,4,5}</code></pre><p>以上分配一个Lua数组，依次为1到5.</p><p>而如果要初始化hash部分，则需要指定key，有两种方式：</p><pre><code>local t = {a=&quot;test&quot;}local t = {[&quot;a&quot;]=&quot;test&quot;}</code></pre><p>以上都指定了key为”a”的元素对应的值是”test”（注意一些上面两种情况key分别可以加引号和不加引号的）。</p><h5 id="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："><a href="#现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：" class="headerlink" title="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："></a>现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：</h5><ol><li><p>NEWTABLE指令。</p><p>指令域A指定的是所要创建的表在Lua栈中的地址，而B,C则分别指定的是创建表时数组和hash部分的初始大小。</p></li><li><p>SETLIST指令。</p><p>需要特别说明的是，这个指令仅能用于初始化Lua表的数组部分时使用，hash部分没有作用。指令域A同样指定的是所要初始化的表在Lua栈中的地址，B指定的是初始化时数组的数量，而C指定的是BLOCK的数量。这里需要做一个说明。在Lua中有一个特殊的常量，叫FPF（fields per flush），可以简单的理解为，每次调用SETLIST指令时，写入数组的数量最多可以有多少，Lua中这个常量定义为50.于是，假如这里要初始化一个有60个元素的数组，那么将会拆分成两个SETLIST指令，第一个SETLIST指令，B为50，C为1，而第二个SETLIST指令，B为10而C为0.</p></li></ol><h5 id="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"><a href="#实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。" class="headerlink" title="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"></a>实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。</h5><ol><li>lopcodes.h中对这个指令的注释为：</li></ol><pre><code>OP_SETLIST,/*   A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B        */</code></pre><p>需要注意的是，A在这里既指定了表的栈位置，还有另一层含义从”=”右边可知，A在栈中紧跟着的数据是需要初始化给A数组的数据，所以A在这个指令中负担了两个数据的指示。换言之，当在A位置创建了这个Lua表之后，紧跟着这个Lua表的数据（数量由B指定）则是准备初始化给Lua表的数据。</p><ol><li>Lua还要处理某些情况下，数组元素可变的情况，比如:</li></ol><pre><code>local t = {func()}</code></pre><p>可以看到，此时数组元素的数量是不确定的，依赖于函数的返回值，而当解析到这个点时，也并不知道func的具体情况。Lua在这里的处理是将B置为0，表示从A+1位置开始直到这个函数栈的栈顶位置之间的元素全部用来初始化这个Lua表的数组部分。</p><ol start="2"><li>C也有可能为0，但是这种情况很少有，仅当初始化数组的数量非常大的时候出现，这里就不做分析了（因为要模拟这种情况有些蛋疼）。</li></ol><h4 id="Lua源码中相关的实现。"><a href="#Lua源码中相关的实现。" class="headerlink" title="Lua源码中相关的实现。"></a>Lua源码中相关的实现。</h4><p>分析Lua表创建部分的入口函数是lparser.c中的constructor函数。<br>首先，函数调用pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);生成一个NEWTABLE指令，注意在这里，B/C部分都是0，从前面的分析知道，这两部分分别指定的是Lua表的数组和hash部分的初始尺寸，因为在这里这两部分的大小并不知道，所以先填0，而保存在pc中是要保存这个生成的NEWTABLE指令，后面需要对B/C部分进行改写，填充数组和hash部分的尺寸。</p><p>紧跟着，在解析Lua表初始化的整个流程中，使用了结构体ConsControl：</p><pre><code>struct ConsControl {  expdesc v;  /* last list item read */  expdesc *t;  /* table descriptor */  int nh;  /* total number of `record&#39; elements */  int na;  /* total number of array elements */  int tostore;  /* number of array elements pending to be stored */};</code></pre><p>每一项的含义分别是，v表示的是上一个解析到表元素，它可能是一个key-value形式的赋值（此时是初始化一个hash元素），也有可能是单独的元素（此时是初始化一个数组元素）；t是一个指针，存放的是待初始化的Lua表；nh和na分别表示表的hash和数组部分尺寸，解析过程中将用这两个变量记录以便在最后重新填充前面的NEWTABLE的B/C部分；tostore则是存放的当前已经有多少数组元素待存放到Lua表中，当这个值达到FPF时，根据上面的分析则生成一个SETLIST指令，然后重新值0进入下一个元素的处理。</p><pre><code>   checknext(ls, &#39;{&#39;);   do {      lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);      if (ls-&gt;t.token == &#39;}&#39;) break;      closelistfield(fs, &amp;cc);      switch(ls-&gt;t.token) {        case TK_NAME: {  /* may be listfields or recfields */          luaX_lookahead(ls);         if (ls-&gt;lookahead.token != &#39;=&#39;)  /* expression? */           listfield(ls, &amp;cc);         else           recfield(ls, &amp;cc);         break;       }       case &#39;[&#39;: {  /* constructor_item -&gt; recfield */         recfield(ls, &amp;cc);         break;       }       default: {  /* constructor_part -&gt; listfield */         listfield(ls, &amp;cc);         break;       }     }   } while (testnext(ls, &#39;,&#39;) || testnext(ls, &#39;;&#39;));   check_match(ls, &#39;}&#39;, &#39;{&#39;, line);   lastlistfield(fs, &amp;cc);   SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */   SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh));  /* set initial table size */</code></pre><p>这个分析过程的主体部分，是一个循环，循环的终止条件是遇到了”}”符号，则该数组的初始化部分完成。<br>每次循环做以下的事情：</p><ol><li><p>调用closelistfield函数。</p><p>它是对数组元素做处理。首先将上一个分析到的数组元素，写入到当前的Lua栈中，这一点可以结合前面分析SETLIST指令来看。同时，如果当前的tostore数量达到FPF时，则生成SETLIST指令，这一点前面也做了分析。</p></li><li><p>然后就是两种情况的处理：</p><p>hash和数组部分，可以参看最开始Lua表初始化的语法就能知道什么语法是用于初始化hash部分，什么语法是初始化数组部分的了。分别调用的是recfield和listfield函数。</p></li></ol><p>listfield函数相对简单，需要判断当前表的数组元素是不是超过了限制，同时增加na和tostore计数。</p><p>recfield稍微复杂一点，还涉及到另一个指令SETTABLE，暂时跳过下一节再解释，现在知道它肯定会增加na计数就可以了。</p><ol start="3"><li>最后，由于初始化Lua表时，不同的元素之间是以”,”或者”;”做分割的，所以在遇到”}”退出循环之后，还有最后一个元素没有处理，于是还要调用lastlistfield函数进行处理。</li></ol><p>lastlistfield函数要处理的情况，就是前面分析过的，初始化过程中是不是遇到了函数返回值的情况，如果有则生成的SETLIST指令的域B要为0.</p><ol start="4"><li>最后就是根据分析过程中得到的na，nh数量重新填充NEWTABLE指令的B/C域了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;表的基本实现&quot;&gt;&lt;a href=&quot;#表的基本实现&quot; class=&quot;headerlink&quot; title=&quot;表的基本实现&quot;&gt;&lt;/a&gt;表的基本实现&lt;/h4&gt;&lt;p&gt;在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua require机制</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%20require%E6%9C%BA%E5%88%B6/"/>
    <id>https://bytemode.github.io/2018/12/12/lua require机制/</id>
    <published>2018-12-12T13:45:37.000Z</published>
    <updated>2018-12-12T13:46:33.620Z</updated>
    
    <content type="html"><![CDATA[<p>require(modname)</p><p>加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.</p><p>如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader).</p><p>要找到一个加载器,require首先查询package.preloaded[modname].如果它有值,该值(应该是一个函数)就是加载器.</p><p>如果没值require使用package.path中存储的路径查找一个Lua的加载器.如果该查找也失败,它使用package.cpath中</p><p>存储的路径查找一个C语言加载器(C loader).如果还是失败,它尝试使用all-in-one加载器(如下)</p><p>当加载一个C库的时候,require首先使用动态链接工具将应用程序与库连接起来.之后它尝试找到一个该库中的C函数,该函数要被当做加载器使用.这个C函数的名称是字符串”luaopen_”连接着复制的模块名(模块名称中的每个点号”.”都被替换为一个下划线).此外,如果模块名称含有连字符”-“,则第一个连字符的前缀(包括连字符)都被移除.比如,如果模块名称是a.v1-b.c,则函数名称将是luaopen_b_c.</p><p>如果require即没有为模块找到一个Lua库也没有为模块找到一个C库,他将调用all-in-one加载器.该加载器为给定模块的根名称查找C路径找到对应库(原文:this loader searches the C path for a library for the root name of the given module).例如,当require a.b.c时,它将为a查找一个库.如果找到,它查询该库内部为子模块找到一个开放函数(open function);在我们这个例子中将会是luaopen_a_b_c.使用这个便利机制(facility),一个包可以将几个子模块打包进单个的库中,同时每个子模块保存着它本来的开放函数.</p><p>一旦找到一个加载器,require使用单个的参数modname调用加载器.如果加载器返回任何值,require将其赋值给package.loaded[modname].</p><p>如果加载器没有返回值且没有给package.loaded[modname]赋与任何值,则require为该条目赋值为true.</p><p>无论如何,require返回package.loaded[modname]的最终值.</p><p>如果加载或者运行模块有任何错误,或者他不能为模块找到一个加载器,则require发出一个错误信号.</p><p>require函数的实现原理如下:</p><ol><li>–require 函数的实现  </li><li>function require(name)  </li><li>​    if not package.loaded[name] then    –是否在package.loaded中存在name</li><li>​        local loader = findloader(name) –不存在则查找加载器 </li><li>​        if loader == nil then  </li><li>​            error(“unable to load module” .. name)  </li><li>​        end  </li><li>​        package.loaded[name] = true     –加载器不存在 设置true</li><li>​        local res = loader(name)        –加载</li><li>​        if res ~= nil then  </li><li>​            package.loaded[name] = res  –加载返回的值给你 package.loaded</li><li>​        end  </li><li>​    end  </li><li>​    return package.loaded[name]         –返回 package.loaded[name]</li><li>end  </li></ol><p>package.cpath</p><p>由require使用查找C加载器的路径</p><p>Lua初始化C路径package.cpath的方法与初始化Lua路径package.path的相同,使用LUA_CPATH中的环境变量(另外一个默认的路径在luaconf.h中定义)</p><p>package.loaded</p><p>一个用于控制哪些模块已经加载的表,该表由require使用.当require一个模块名为modname的模块且package.loaded[modname]不为false时,require仅返回package.loaded[modname]存储的值.</p><p>package.loadlib(libname,funcname)</p><p>使用C库libname动态链接到宿主程序.在这个库中,寻找函数funcname并将该函数作为一个C函数返回.(所以,funcname必须遵守协议(参见lua_CFunction)).</p><p>这是一个底层函数.它完全绕过了package和module系统.与require不同,它不执行任何路径查找且不自动添加扩展名.libname必须是C库中完整的文件名,如果必要的话还要包含路径和扩展名.funcname必须是原封不动的C库中导出的名字(这可能取决于使用的C编译器和链接器).</p><p>这个函数不被ANSI C支持.就其本身而言,它只在一些平台上才能使用(Windows,Linux,Mac OS X,Solaris,BSD,加上其他支持dlfcn标准的Unix系统)</p><p>package.path</p><p>require用于查找Lua加载器的路径</p><p>在启动时,Lua使用环境变量LUA_PATH或者如果环境变量未定义就使用luaconf.h中定义的默认值来初始化该值.环境变量中的任何”::”都被替换为默认路径.</p><p>路径是一系列由分号隔开的模板(templates).对于每个模板,require将每个模板中的问号替换为filename,filename是modname中每个点都被替换成”目录分隔符”(比如Unix中的”/“)(这句感觉翻译不准确,原文:For each template,require will change each interrogation mark in the template by filename,which is modname with each dot replaced by a “directory separator”(such as “/“ in Unix));之后他将加载产生的文件名.因此,举个例子,如果Lua路径是”./?.lua;./?.lc;/usr/local/?/init.lua”,为模块foo查找一个Lua加载器将会尝试以如下顺序加载文件./foo.lua,./foo.lc和/usr/local/foo/init.lua</p><p>package.preload</p><p>为特定模块存储加载器的一个表(参见require)</p><p>package.seeall(module)</p><p>为module设置一个元表,module的__index只想全局环境(global environment),以便该module继承全局环境中的值.作为函数module中的一个选项来使用.</p><p>在Programming Lua中是这么讲的:</p><p>默认情况下,module不提供外部访问.必须在调用它之前,为需要访问的外部函数或模块声明适当的局部变量.也可以通过继承来实现外部访问,只需在调用module时附加一个选项package.seeall.这个选项等价于如下代码:</p><ol><li>setmetatable(M,{__index = _G})  </li></ol><p>因而只需这么做:</p><ol><li>module(…,package.seeall)  </li></ol><p>module(name,[,…])</p><p>创建一个模块.如果在package.loaded[name]中有表,该表便是创建的模块.否则,如果有一个全局表t其名称与给定名称相同,则该全局表便是创建的模块.否则创建一个新的表t</p><p>lua中import和require的区别</p><p>载入一个模块</p><p>import() 与 require() 功能相同，但具有一定程度的自动化特性。</p><p>假设有如下的目录结构：</p><p>app/</p><p>app/classes/</p><p>app/classes/MyClass.luaapp/classes/MyClassBase.luaapp/classes/data/Data1.luaapp/classes/data/Data2.lua</p><p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p><p>local MyClassBase = require(“app.classes.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = require(“app.classes.data.Data1”)</p><p>local Data2 = require(“app.classes.data.Data2”)</p><p>假如将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p><p>而使用 import()，只需要如下写：</p><p>local MyClassBase = import(“.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = import(“.data.Data1”)</p><p>local Data2 = import(“.data.Data2”)</p><p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p><p>可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p><p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。如果需要在函数中调用 import()，那么就需要指定当前模块名：</p><p># MyClass.lua</p><p># 这里的 … 是隐藏参数，包含了当前模块的名字，所以最好将这行代码写在模块的第一行</p><p>local CURRENT_MODULE_NAME = …</p><p>local function testLoad() local MyClassBase = import(“.MyClassBase”, CURRENT_MODULE_NAME)</p><p># 更多代码</p><p>end</p><p>Parameters</p><p>string moduleName 要载入的模块的名字</p><p>[string currentModuleName]</p><p>当前模块名</p><p>Returns</p><p>module</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;require(modname)&lt;/p&gt;
&lt;p&gt;加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.&lt;/p&gt;
&lt;p&gt;如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
</feed>
