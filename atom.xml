<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小工知识库</title>
  
  <subtitle>coding wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bytemode.github.io/"/>
  <updated>2018-12-27T08:12:07.826Z</updated>
  <id>https://bytemode.github.io/</id>
  
  <author>
    <name>sunfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lua闭包</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E9%97%AD%E5%8C%85/"/>
    <id>https://bytemode.github.io/2018/12/15/lua闭包/</id>
    <published>2018-12-15T10:47:01.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lua中有两种闭包-c闭包和lua闭包"><a href="#lua中有两种闭包-c闭包和lua闭包" class="headerlink" title="lua中有两种闭包, c闭包和lua闭包"></a>lua中有两种闭包, c闭包和lua闭包</h4><p>两种闭包的公共部分:</p><pre><code>#define ClosureHeader CommonHeader;\lu_byte isC; \  是否c闭包lua_byte nupvalues; \ upvalue的个数GCObject* gclist; \struct Table env 闭包的环境</code></pre><p>C闭包的结构</p><pre><code>struct CClosure{   ClosureHeader;   lua_CFunction f;   TValue upvalue[1];}</code></pre><p>结构比较简单, f是一个满足 int lua_func(lua_State*) 类型的c函数</p><p>upvalue是创建C闭包时压入的upvalue, 类型是TValue, 可以得知, upvalue可以是任意的lua类型 </p><p>Lua闭包结构</p><pre><code>struct LClosure{  ClosureHeader;  strcut Proto* p;  UpVal* upvals[1];}</code></pre><p>Proto的结构比较复杂, 这里先不做分析</p><p>统一的闭包结构, 一个联合体, 说明一个闭包要么是C闭包, 要么是lua闭包, 这个是用isC表识出来的.</p><pre><code>union Closure{    CClosure c;    LClosure  l;}</code></pre><p> <strong>闭包 == {功能抽象, upvalue, env}</strong> </p><h4 id="向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的"><a href="#向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的" class="headerlink" title="向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的"></a>向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的</h4><p>流程: </p><ol><li><p>创建一个 sizeof(CClosure) + (n - 1) * sizeof(TValue)大小的内存, 这段内存是 CClosure + TValue[n],,  isC= 1 标示其是一个C闭包.</p></li><li><p>c-&gt;f = f绑定c函数.         ———  <strong>闭包.功能抽象 = f</strong></p></li><li><p>env = 当前闭包的env.  ———- <strong>闭包.env = env</strong></p></li><li><p>把栈上的n个元素赋值到c-&gt;upvalue[]数组中, 顺序是越先入栈的值放在upvalue数组的越开始位置, c-&gt;nupvalues指定改闭包upvalue的个数.  ———- <strong>闭包.upvalue = upvalue</strong></p></li><li><p>弹出栈上n个元素, 并压入新建的Closure到栈顶.</p></li></ol><p>整个流程是: 分配内存, 填写属性, 链入gc监控, 绑定c函数, 绑定upvalue, 绑定env一个C闭包就ok了</p><h4 id="C闭包被调用的过程"><a href="#C闭包被调用的过程" class="headerlink" title="C闭包被调用的过程"></a>C闭包被调用的过程</h4><p>lua 闭包调用信息结构:</p><pre><code>struct CallInfo{    StkId base; ----闭包调用的栈基    StkId func; ----要调用的闭包在栈上的位置    StkId top;  ----闭包的栈使用限制    const Instruction *savedpc; ----如果在本闭包中再次调用别的闭包, 那么该值就保存下一条指令以便在返回时继续执行    int nresults; ----闭包要返回的值个数    int tailcalls;----尾递归用, 暂时不管}</code></pre><p>这个结构是比较简单的, 它的作用就是维护一个函数调用的有关信息, 其实和c函数调用的栈帧是一样的, 重要的信息base –&gt; ebp, func –&gt; 要调用的函数的栈index, savedpc –&gt; eip, top, nresults和tailcalls没有明显的对应.</p><p><strong>在lua初始化的时候, 分配了一个CallInfo数组, 并用L-&gt;base_ci指向该数组第一个元素, 用L-&gt;end_ci指向该数组最后一个指针, 用L-&gt;size_ci记录数组当前的大小, L-&gt;ci记录的是当前被调用的闭包的调用信息.</strong></p><p>下面讲解一个c闭包的调用的过程:<br>情景: c 函数</p><pre><code>int lua_test(lua_State* L){    int a = lua_tonumber(L, 1);    int b = lua_tonumber(L, 2);    a = a + b;    lua_pushnumber(L, a);}</code></pre><p>已经注册到了lua 中, 形成了一个C闭包, 起名为”test”, 下面去调用它<br><code>luaL_dostring(L, &quot;c = test(3, 4)&quot;)</code></p><p>调用过程堆栈变化情况如下：</p><p>1.初始栈</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-828474891656030&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2cCI6%2FKUHKD74rb5zUmgnkHU678%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=21047001409346822&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>2.压入了函数和参数的堆栈 </p><pre><code>lua_getglobal(L, “test”)lua_pushnumber(L, 3)lua_pushnumber(L, 4) </code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/fbb22d3ec714edd9bbe59e9f1a727f5b?fid=1259087893-250528-1072131023144167&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-RE7mQ7%2BV8SIVj7JObpxAupx2Kt0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092046924209033410&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>3.调用lua_test开始时的堆栈    lua_call(L,3, 4) </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/88d243fb39e38c3d56cefd3a5b2e3459?fid=1259087893-250528-712458354988681&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-QKj7KqKkVTuusQ8o0UkkVwLDB%2B0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092063733828165106&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>4.调用结束的堆栈 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/ca3dd633932be0c1bb59256e44276e6d?fid=1259087893-250528-574814416488756&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-4jo1Tky2%2FALRP0b%2Bv49ptjJVAgw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092105420285105960&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><ol start="5"><li>取出结果的栈 lua_setglobal(L, “c”)     </li></ol><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-381860168682101&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-WW5zL3p%2Bf6EDOcBSTdSYtECt4cw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092179093472688280&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><h4 id="lua-call函数的过程"><a href="#lua-call函数的过程" class="headerlink" title="lua_call函数的过程"></a>lua_call函数的过程</h4><ol><li>lua具有很强一致性, 不管是dostring, 还是dofile, 都会形成一个闭包, 也就是说, 闭包是lua中用来组织结构的基本构件, 这个特点使得lua中的结构具有一致性, 是一种简明而强大的概念.</li><li>根据1， a = test(3, 4)其实是被组织成为一个闭包放在lua栈顶[方便期间, 给这个lua闭包起名为bb], 也就说dostring真正调用的是bb闭包, 然后bb闭包执行时才调用的是test[保存当前信息到当前函数的CallInfo中]</li><li>在调用test的时刻, L-&gt;ci记载着bb闭包的调用信息, 所以, 先把下一个要执行的指令放在L-&gt;ci-&gt;savedpc中, 以供从test返回后继续执行.</li><li>取栈上的test C闭包 cl, 用 cl-&gt;isC == 1断定它的确是一个C闭包[进入一个新的CallInfo, 布置堆栈]</li><li><p>从L中新分配一个CallInfo ci来记录test的调用信息, 并把它的值设置到L-&gt;ci, 这表明一个新的函数调用开始了, 这里还要指定test在栈中的位置, L-&gt;base = ci-&gt;base = ci-&gt;func+1, 注意, 这几个赋值很重要, 导致的堆栈状态由图2转化到图3, 从图中可以看出, L-&gt;base指向了第一个参数, ci-&gt;base也指向了第一个参数, 所以在test中, 我们调用lua_gettop函数返回的值就是2， 因为在调用它的时候, 它的栈帧上只有2个元素, 实现了lua向c语言中传参数.<br>[调用实际的函数]</p></li><li><p>安排好堆栈, 下面就是根据L-&gt;ci-&gt;func指向的栈上的闭包(及test的C闭包), 找到对应的cl-&gt;c-&gt;f, 并调用, 就进入了c函数lua_test [获取返回值调整堆栈, 返回原来的CallInfo]</p></li><li><p>根据lua_test的返回值, 把test闭包和参数弹出栈, 并把返回值压入并调整L-&gt;top</p></li><li><p>恢复 L-&gt;base, L-&gt;ci 和 L-&gt;savedpc, 继续执行.</p></li></ol><h4 id="调用一个新的闭包时："><a href="#调用一个新的闭包时：" class="headerlink" title="调用一个新的闭包时："></a>调用一个新的闭包时：</h4><ol><li>保存当前信息到当前函数的CallInfo中 （CallInfo函数调用的状态信息）</li><li>进入一个新的CallInfo, 布置堆栈  </li><li>调用实际的函数  </li><li>获取返回值调整堆栈, 返回原来的CallInfo</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;lua中有两种闭包-c闭包和lua闭包&quot;&gt;&lt;a href=&quot;#lua中有两种闭包-c闭包和lua闭包&quot; class=&quot;headerlink&quot; title=&quot;lua中有两种闭包, c闭包和lua闭包&quot;&gt;&lt;/a&gt;lua中有两种闭包, c闭包和lua闭包&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua模块注册</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C/"/>
    <id>https://bytemode.github.io/2018/12/15/lua模块注册/</id>
    <published>2018-12-15T10:19:25.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<p>Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.</p><h4 id="相关的函数index2adr"><a href="#相关的函数index2adr" class="headerlink" title="相关的函数index2adr"></a>相关的函数index2adr</h4><pre><code>static TValue *index2adr (lua_State *L, int idx) {  if (idx &gt; 0) {    TValue *o = L-&gt;base + (idx - 1);    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);    if (o &gt;= L-&gt;top) return cast(TValue *, luaO_nilobject);    else return o;  }  else if (idx &gt; LUA_REGISTRYINDEX) {    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);    return L-&gt;top + idx;  }  else switch (idx) {  /* pseudo-indices */    case LUA_REGISTRYINDEX: return registry(L);    case LUA_ENVIRONINDEX: {      Closure *func = curr_func(L);      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);      return &amp;L-&gt;env;    }    case LUA_GLOBALSINDEX: return gt(L);    default: {      Closure *func = curr_func(L);      idx = LUA_GLOBALSINDEX - idx;      return (idx &lt;= func-&gt;c.nupvalues)                ? &amp;func-&gt;c.upvalue[idx-1]                : cast(TValue *, luaO_nilobject);    }  }}</code></pre><p>一个Lua函数栈由两个指针base和top来指定,base指向函数栈底,top则指向栈顶.<br>回到index2addr函数中,几种情况:</p><ol><li>如果索引为正,则从函数栈底为起始位置向上查找数据</li><li>如果索引为负,则从函数栈顶为起始位置向下查找数据</li><li>紧跟着是几种特殊的索引值,都定义了非常大的数据,由于Lua栈限定了函数的栈尺寸,所以不会有那么大的索引,大可放心使用.</li></ol><p>索引值为LUA_REGISTRYINDEX时,则返回的是全局数据global_state的l_registry表;如果索引值为LUA_GLOBALSINDEX,则返回该Lua_State的l_gt表.</p><h4 id="lua模块注册"><a href="#lua模块注册" class="headerlink" title="lua模块注册"></a>lua模块注册</h4><p>Lua内部所有模块的注册都在linit.c的函数luaL_openlibs中提供.可以看到的是,它依次访问一个数组,数组中定义了每个模块的模块名及相应的模块注册函数,依次调用函数就完成了模块的注册.</p><pre><code>static const luaL_Reg lualibs[] = {  {&quot;&quot;, luaopen_base},  {LUA_LOADLIBNAME, luaopen_package},  {LUA_TABLIBNAME, luaopen_table},  {LUA_IOLIBNAME, luaopen_io},  {LUA_OSLIBNAME, luaopen_os},  {LUA_STRLIBNAME, luaopen_string},  {LUA_MATHLIBNAME, luaopen_math},  {LUA_DBLIBNAME, luaopen_debug},  {NULL, NULL}};LUALIB_API void luaL_openlibs (lua_State *L) {  const luaL_Reg *lib = lualibs;  for (; lib-&gt;func; lib++) {    lua_pushcfunction(L, lib-&gt;func);    lua_pushstring(L, lib-&gt;name);    lua_call(L, 1, 0);  }}</code></pre><p>我没有详细的查看每个模块的注册函数,不过还是以最简单的例子来讲解,就是最常用的print函数.</p><p>由于这个函数没有前缀,因此的它所在的模块是””,也就是一个空字符串,因此它是在base模块中注册的,调用的注册函数是luaopen_base.</p><p>紧跟着继续看luaopen_base内部调用的第一个函数base_open:</p><pre><code>static void base_open (lua_State *L) {  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);  /* open lib into global table */  luaL_register(L, &quot;_G&quot;, base_funcs);  // ....}</code></pre><p>首先来看最前面的两句:</p><pre><code>  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);</code></pre><p>这两句首先将LUA_GLOBALSINDEX对应的值压入栈中,其次调用”lua_setglobal(L, “_G”);”,这句代码的意思是在Lua_state的l_gt表中,当查找”_G”时,查找到的是索引值为LUA_GLOBALSINDEX的表.如果觉得有点绕,可以简单这个理解,在Lua中的G表,也就是全局表,满足这个等式”_G = _G[“_G”]“,也就是这个叫”_G”的表,内部有一个key为”_G”的表是指向自己的.怀疑这个结论的,可以在Lua命令行中执行print(_G)和print(_G[“_G”])看看输出结果是不是一致的.</p><p>Lua中要这么处理的理由是:为了让G表和处理其它表使用同样的机制.查找一个变量时,最终会一直查到G表中,这是很自然的事情;所以为了也能按照这个机制顺利的查找到自己,于是在G表中有一个同名成员指向自己.</p><p>好了,前面两句的作用已经分析完毕.其结果有两个:</p><ol><li>_G = _G[“_G”]</li><li>_G表的值压入函数栈中方便了下面的调用.</li></ol><p>继续看下面的语句:<br><strong>luaL_register(L, “_G”, base_funcs);</strong><br><strong>它最终会将base_funcs中的函数注册到G表中,但是里面还有些细节需要看看的.</strong></p><pre><code>LUALIB_API void luaI_openlib (lua_State *L, const char *libname,                              const luaL_Reg *l, int nup) {  if (libname) {    int size = libsize(l);    /* check whether lib already exists */    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */    if (!lua_istable(L, -1)) {  /* not found? */      lua_pop(L, 1);  /* remove previous result */      /* try global variable (and create one if it does not exist) */      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)        luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);      lua_pushvalue(L, -1);      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */    }    lua_remove(L, -2);  /* remove _LOADED table */    lua_insert(L, -(nup+1));  /* move library table to below upvalues */  }// ...}</code></pre><p>注册这些函数之前,首先会到l_registry表的成员_LOADED表中查找该库,如果不存在则再在G表中查找这个库,不存在则创建一个表.因此,不管是lua中内部的库或者是外部使用require引用的库,都会走这个流程并最终在G表和l_registry[“_LOADED”]中存放该库的表.最后,再遍历传进来的函数指针数组,完成库函数的注册.</p><p>比如,注册os.print时,首先将print函数绑定在一个函数指针上,再去l_registry[“_LOADED”]和G表中查询该名为”os”的库是否存在,不存在则创建一个表,即:<br>G[“os”] = {}</p><p>紧跟着注册print函数,即: G[“os”][“print”] = 待注册的函数指针.这样,在调用lua代码os.print(1)时,首先根据”os”到G表中查找对应的表,再在这个表中查找”print”成员得到函数指针,最后完成函数的调用.</p><h4 id="注册外部模块"><a href="#注册外部模块" class="headerlink" title="注册外部模块"></a>注册外部模块</h4><p><strong>luaL_newlibtable</strong> 它仅仅是创建了一个table,然后把数组里的函数放进去而已 </p><p><strong>luaL_setfuncs</strong>它把数组l中的所有函数注册入<strong>栈顶</strong>的table，并给所有函数绑上<strong>nup</strong>个<strong>upvalue</strong> </p><p>define luaL_newlibtable(L, l)</p><pre><code>lua_createtble(L, 0, sizeof(l)/sizeof((l)[0]) - 1)</code></pre><p>define luaL_newlib(L, l)</p><pre><code>(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0)</code></pre><pre><code>LUALIB_API void luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup){    luaL_checkversion(L);    luaL_checkstack(L, nup, &quot;too_many_upvalue&quot;);    for(; l-&gt;name != NULL; i++){/* fill the table with given functions*/        int i;        for(i = 0; i &lt; nup; i++)/copy upvalues to the top/            lua_pushvalue(L, -nup);        lua_pushclosure(L, l-&gt;func, nup);/closure with those upvalues/        lua_setfield(L, -(nup + 2), l-&gt;name);    }    lua_pop(L, nup);/remove upvalues/}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.&lt;/p&gt;
&lt;h4 id=&quot;相关的函数index2adr&quot;&gt;&lt;a href=&quot;#相关的函数index2adr&quot; class=&quot;headerlink&quot; title=&quot;相关的函数in
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua协程</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%8D%8F%E7%A8%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua协程/</id>
    <published>2018-12-15T09:56:15.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器领域，使用Lua协程最好的范例就是ngx_lua了</p><p>来看看Lua协程内部是如何实现的。</p><p>本质上，每个Lua协程其实也是对应一个LuaState指针，所以其实它内部也是一个完整的Lua虚拟机—有完整的Lua堆栈结构，函数调用栈等等等等，绝大部分之前对Lua虚拟机的分析都可以直接套用到Lua协程中。于是，由Lua虚拟机管理着这些隶属于它的协程，当需要暂停当前运行协程的时候，就保存它的运行环境，切换到别的协程继续执行。很简单的实现。</p><p>来看看相关的API。</p><ol><li>lua_newthread</li></ol><p>创建一个Lua协程，最终会调用的API是luaE_newthread，Lua协程在Lua中也是一个独立的Lua类型数据，它的类型是LUA_TTHREAD，创建完毕之后会照例初始化Lua的栈等结构，有一点需要注意的是，调用preinit_state初始化Lua协程的时候，传入的global表指针是来自于Lua虚拟机，换句话说，任何在Lua协程修改的全局变量，也会影响到其他的Lua协程包括Lua虚拟机本身。</p><ol start="2"><li>加载一个Lua文件并且执行</li></ol><p>对于一般的Lua虚拟机，大可以直接调用luaL_dofile即可，它其实是一个宏：</p><pre><code>#define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>展开来也就是当调用luaL_loadfile函数完成对该Lua文件的解析，并且没有错误时，调用lua_pcall函数执行这个Lua脚本。</p><p>但是对于Lua协程而言，却不能这么做，需要调用luaL_loadfile然后再调用lua_resume函数。所以两者的区别在于lua_pcall函数和lua_resume函数。来看看lua_resume函数的实现。这个函数做的几件事情：首先查看当前Lua协程的状态对不对，然后修改计数器：</p><pre><code> L-&gt;baseCcalls = ++L-&gt;nCcalls;</code></pre><p>其次调用status = luaD_rawrunprotected(L, resume, L-&gt;top – nargs);，可以看到这个保护Lua函数堆栈的调用luaD_rawrunprotected最终调用了函数resume:</p><pre><code>static void resume (lua_State *L, void *ud) {  StkId firstArg = cast(StkId, ud);  CallInfo *ci = L-&gt;ci;  if (L-&gt;status == 0) {  /* start coroutine? */    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)      return;  }  else {  /* resuming from previous yield */    lua_assert(L-&gt;status == LUA_YIELD);    L-&gt;status = 0;    if (!f_isLua(ci)) {  /* `common&#39; yield? */      /* finish interrupted execution of `OP_CALL&#39; */      lua_assert(GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||                 GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);      if (luaD_poscall(L, firstArg))  /* complete it... */        L-&gt;top = L-&gt;ci-&gt;top;  /* and correct top if not multiple results */    }    else  /* yielded inside a hook: just continue its execution */      L-&gt;base = L-&gt;ci-&gt;base;  }  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));}</code></pre><p>这个函数将执行Lua代码的流程划分成了几个阶段，如果调用</p><pre><code>luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA</code></pre><p>那么说明这次调用返回的结果小于0，可以跟进luaD_precall函数看看什么情况下会出现这样的情况：</p><pre><code>    n = (*curr_func(L)-&gt;c.f)(L);  /* do the actual call */    lua_lock(L);    if (n &lt; 0)  /* yielding? */      return PCRYIELD;    else {      luaD_poscall(L, L-&gt;top - n);      return PCRC;    }</code></pre><p>继续回到resume函数中，如果之前该Lua协程的状态是YIELD，那么说明之前被中断了，则调用luaD_poscall完成这个函数的调用。<br>然后紧跟着调用luaV_execute继续Lua虚拟机的继续执行。</p><p>可以看到，resume函数做的事情其实有那么几件：</p><ol><li>如果调用C函数时被YIELD了，则直接返回</li><li>如果之前被YIELD了，则调用luaD_poscall完成这个函数的执行，接着调用luaV_execute继续Lua虚拟机的执行。</li></ol><p>因此，这个函数对于函数执行中可能出现的YIELD，有充分的准备和判断，因此它不像一般的pcall那样，一股脑的往下执行，而是会在出现YIELD的时候保存现场返回，在继续执行的时候恢复现场。<br>3）同时，由于resume函数是由luaD_rawrunprotected进行保护调用的，即使执行出错，也不会造成整个程序的退出。</p><p>这就是Lua协程中，比一般的Lua操作过程做的更多的地方。</p><p>最后给出一个Lua协程的例子：<br>co.lua</p><pre><code>print(&quot;before&quot;)test(&quot;123&quot;)print(&quot;after resume&quot;)</code></pre><p>co.c</p><pre><code> #include     #include &quot;lua.h&quot;    #include &quot;lualib.h&quot;    #include &quot;lauxlib.h&quot;    static int panic(lua_State *state) {      printf(&quot;PANIC: unprotected error in call to Lua API (%s)\n&quot;,              lua_tostring(state, -1));      return 0;    }    static int test(lua_State *state) {      printf(&quot;in test\n&quot;);      printf(&quot;yielding\n&quot;);      return lua_yield(state, 0);    }    int main(int argc, char *argv[]) {      char *name = NULL;      name = &quot;co.lua&quot;;      lua_State*  L1 = NULL;      L1 = lua_open();      lua_atpanic(L1, panic);      luaL_openlibs( L1 );      lua_register(L1, &quot;test&quot;, test);      lua_State*  L = lua_newthread(L1);      luaL_loadfile(L, name);      lua_resume(L, 0);      printf(&quot;sleeping\n&quot;);      sleep(1);      lua_resume(L, 0);      printf(&quot;after resume test\n&quot;);      return 0;    }</code></pre><p>你可以使用coroutine.create来创建协程,协程有三种状态：挂起，运行，停止。创建后是挂起状态，即不自动运行。status函数可以查看当前状态。协程真正强大的地方在于他可以通过yield函数将一段正在运行的代码挂起。</p><p>lua的resume-yield可以互相交换数据</p><pre><code>co = coroutine.create(function (a, b)     coroutine.yield(a+b, a-b)end)print(coroutine.resume(co, 3, 8))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表类型</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%A1%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua表类型/</id>
    <published>2018-12-15T09:51:02.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lua的表的定义"><a href="#Lua的表的定义" class="headerlink" title="Lua的表的定义:"></a>Lua的表的定义:</h4><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>这里将Table分为了两个部分:数组部分,array指针指向数组部分的首地址,sizearray是数组的尺寸,绝大部分(注意:不是全部)正整数为key的数据都存放在数组部分;node指针指向一个hash桶,对于不能存放在数组部分的数据,都存放在hash中.如下图所示:<br><img src="https://thumbnail0.baidupcs.com/thumbnail/46eff62f24b48c0dd2380abaa949cb84?fid=1259087893-250528-534280502274275&amp;time=1544864400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-KcBURzIEUOljxyzUWcN5%2FL3uieo%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=17866885042028318&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>hash部分需要特别注意的一点是:在物理上,所有hash部分的数据,其实是存放一块连续的内存中的,即node指针指向的数组;但是从逻辑上来看,如果几块数据在同一个hash桶上,那么又是通过next指针串联起来的.<br>以图中的示例来分析,node数组的第一个和第三个元素,在物理上是第一和第三个元素,但是在逻辑上,它们是通过next指针串联起来的.</p><h4 id="Table查找数据"><a href="#Table查找数据" class="headerlink" title="Table查找数据"></a>Table查找数据</h4><p>有了以上的了解,从Table中查找一个数据的伪代码就很显而易见了:</p><p>如果输入的Key是一个正整数,并且它的值 &gt; 0 &amp;&amp; &lt;= 数组大小<br>    尝试在数组部分查找<br>否则尝试在Hash部分进行查找:<br>    计算出该Key的Hash值(ltable.c中的mainposition函数),根据此Hash值访问node数组得到Hash桶所在位置<br>    遍历该Hash桶下的所有链表元素,直到找到该Key为止<br>以上已经明白了Table的大致结构,来看看Table中如果新加入新的数据会怎么处理.这里有一些内容,要留到后面讲解到Lua虚拟机的时候才触及,这里先讲解一下,当新插入数据时,Table内的数组和Hash部分,做了哪些变化.</p><p>这部分中,核心的算法在ltable.c的rehash函数中,这个函数是计算当新添加数据时,数组和hash重新分配之后各自的尺寸是多少,伪代码如下:</p><p>首先分配一个位图nums,将其中的所有位置0,这个位图的意义在于:nums数组中第i个元素存放的是key在2^(i-1), 2^i之间的元素数量<br>遍历lua Table中的数组部分,计算在数组部分中的元素数量,更新对应的nums数组元素数量.(numusearray函数)<br>遍历lua Table中的Hash部分,因为其中也可能存放了正整数,也根据这里的正整数数量更新对应的nums数组元素数量.(numusehash函数)<br>此时nums数组已经有了当前这个Table中所有正整数的分配统计,逐个遍历nums数组,如果当前已经有的根据新的数组大小和Hash大小重新分配table的大小(computesizes函数)<br>这里要特别讲解的是computesizes函数,在前面的两个函数调用numusearray函数和numusehash函数之后,此时在nums位图中,已经存放了所有有关整数key的信息,即在[2^(i-1), 2^i]范围内,有多少数据.前面曾经提到过,并不是所有的正整数,都会存放在数组部分的,即使它曾经在,也有可能在之后被分配到hash部分,那么判断的依据是什么?到底怎样的数据,在重新分配之后会从数组部分挪到hash部分?<br>来看computesizes函数的实现:</p><pre><code>static int computesizes (int nums[], int *narray) {  int i;  int twotoi;  /* 2^i */  int a = 0;  /* number of elements smaller than 2^i */  int na = 0;  /* number of elements to go to array part */  int n = 0;  /* optimal size for array part */  for (i = 0, twotoi = 1; twotoi/2 &lt; *narray; i++, twotoi *= 2) {    if (nums[i] &gt; 0) {      a += nums[i];      if (a &gt; twotoi/2) {  /* more than half elements present? */        n = twotoi;  /* optimal size (till now) */        na = a;  /* all elements smaller than n will go to array part */      }    }    if (a == *narray) break;  /* all elements already counted */  }  *narray = n;  lua_assert(*narray/2 &lt;= na &amp;&amp; na &lt;= *narray);  return na;}</code></pre><p>注意到这样的细节:这个函数在遍历nums位图数组的时候,会将当前数据数量存放在变量a中,如果a &gt; twotoi/2,也就是当前有一半以上的空间被利用上了,那么这部分数据会继续留在数组部分,否则就会在之后挪到hash部分了.</p><h4 id="纯粹的使用数组或者hash表性能更高"><a href="#纯粹的使用数组或者hash表性能更高" class="headerlink" title="纯粹的使用数组或者hash表性能更高"></a>纯粹的使用数组或者hash表性能更高</h4><p>为了证实这里的判断,简单的写一段lua代码做为实验:</p><pre><code>function print_ipairs(t)  print(&quot;in print_ipairs&quot;)  for k, v in ipairs(t) do    print(k)  endend function print_pairs(t)  print(&quot;in print_pairs&quot;)  for k, v in pairs(t) do    print(k)  endend a = {}a={1,2,3,4,5,6,7,8,9,10}print_ipairs(a)a[2] = nila[3] = nila[4] = nila[6] = nila[&quot;k&quot;] = &quot;e&quot;print_ipairs(a)print_pairs(a)输出为:in print_ipairs12345678910in print_ipairs1in print_pairs17810k59</code></pre><p>在这里,首先对表a赋值,有1-10共十个元素,通过调用函数print_ipairs可知,这些元素都是存放在数组部分的,这是因为ipairs取的是Table的数组部分元素.<br>在这之后,人为的将其中2,3,4,6元素删除,造成原来数组不满一半元素被利用上的现象,然后再插入一个新key “k”,以让这个Table重新分配空间.再此之后,再次调用ipairs遍历a的数组部分,可以看到只有1被打印出来了,也就是说,在重新分配空间之后,除去已经被删除的2,3,4,6之外,只有1还在数组里面,剩下的5,7,8,9,10已经不在数组部分了.紧接着调用pairs遍历这个表,可以看出这些已经不在数组部分的值又被打印出来了,并且它们的顺序已经被打乱,不再按照数字大小顺序来排列了,它们在这次重新分配中被挪动到了hash部分.</p><p>这个实验既验证了我们前面的分析,同时也告诉我们,Table的重新分配,实际上代价是很大的,因此不建议在实际程序中,一个Table即有数组部分,也有Hash部分,纯粹一些,性能上会有提升.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Lua的表的定义&quot;&gt;&lt;a href=&quot;#Lua的表的定义&quot; class=&quot;headerlink&quot; title=&quot;Lua的表的定义:&quot;&gt;&lt;/a&gt;Lua的表的定义:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef struct Table {
  CommonHeade
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua通用数据类型</title>
    <link href="https://bytemode.github.io/2018/12/15/LUA%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/LUA的通用数据类型/</id>
    <published>2018-12-15T06:57:00.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TValue结构"><a href="#TValue结构" class="headerlink" title="TValue结构"></a>TValue结构</h4><p>TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.很容易想到,在面向对象中,这个结构体是一个基类,派生出来的都是其他的子类.</p><p>TValue结构体内部有几个宏, 展开之后就是这样的:</p><pre><code>typedef struct lua_TValue {    union {      union GCObject {        struct GCheader {          GCObject *next; lu_byte tt; lu_byte marked;        } gch;        union TString ts;        union Udata u;        union Closure cl;        struct Table h;        struct Proto p;        struct UpVal uv;        struct lua_State th;  /* thread */      } gc;      void *p;      lua_Number n;      int b;    } value;    int tt;} TValue;</code></pre><p>这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int.</p><h4 id="gc-union"><a href="#gc-union" class="headerlink" title="gc union"></a>gc union</h4><p>gc union的定义,可以看到各种可gc的类型(Tstring,Udata..etc)和一个GCHeader放在 一起,也就是说,当这部分还是数据的时候,数据部分启用,否则就是gc部分了.这里的GCHeader包括了三个部分:next指针将可gc的数据串联成链表,tt表示数据类型,marked存放的gc处理时的颜色值.<br>这是另一种方式的使用C语言实现的面向对象,对外部而言,TValue结构体可以看作是”基类”,真正进行处理时,再根据数据类型决定到底使用value union中的哪个数据部分.可以看到lua源代码中定义了很多宏就是这样操作Tvalue数据指针的,比如:</p><pre><code>#define hvalue(o)    check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)</code></pre><p>这个宏定义了如何从TValue指针得到Table结构体:首先判断数据类型是Table,然后将value的gc union中Table *h取出.</p><p>反之,要从一个具体的类型转换再赋值为相应的TValue,Lua源代码中也提供了相应的宏.因为TValue结构体的中的value域是一个union,所以其实随便强制转换为其中的哪一种类型都可以,不过看上去最舒服的写法还是直接转换为公共类型GCObject了,比如:</p><pre><code>#define setsvalue(L,obj,x) \  { TValue *i_o=(obj); \    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \checkliveness(G(L),i_o); }</code></pre><h4 id="GCObject"><a href="#GCObject" class="headerlink" title="GCObject"></a>GCObject</h4><pre><code>union GCObject {  GCheader gch;  union TString ts;  union Udata u;  union Closure cl;  struct Table h;  struct Proto p;  struct UpVal uv;  struct lua_State th;  /* thread */};</code></pre><p>其中的GCheader展开是这样的:</p><pre><code>typedef struct GCheader {  CommonHeader;} GCheader;</code></pre><p>而随便抽在GCObject结构体中的数据类型结构体定义,都发现也包含了一个CommonHeader结构体,比如:</p><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>换言之,在GCObject中,无论是哪个数据结构体,都自己有一份CommonHeader.仔细观察,其实GCObject这个union的内存分布,最开始部分无论如何都是留给CommonHeader的.这样做,就保证了一个存放在TValue结构体中的数据,既可以使用CommonHeader关于GC的部分,也可以使用到自己本身的数据部分了.</p>]]></content>
    
    <summary type="html">
    
      TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int. gc联合体部分就是GCobject
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua栈</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A0%88/"/>
    <id>https://bytemode.github.io/2018/12/15/lua栈/</id>
    <published>2018-12-15T06:56:54.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.</p><p>lua虚拟机在初始化创建lua_State结构体时,会走到stack_init函数中,这个函数主要就是对Lua栈和CallInfo数组的初始化:</p><pre><code>static void stack_init (lua_State *L1, lua_State *L) {  /* initialize CallInfo array */  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);  L1-&gt;ci = L1-&gt;base_ci;  L1-&gt;size_ci = BASIC_CI_SIZE;  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;  /* initialize stack array */  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;  L1-&gt;top = L1-&gt;stack;  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;  /* initialize first ci */  L1-&gt;ci-&gt;func = L1-&gt;top;  setnilvalue(L1-&gt;top++);  /* `function&#39; entry for this `ci&#39; */  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;}</code></pre><p>可以看到的是,初始化了两个数组,分别保存Lua栈和CallInfo结构体数组.<br>其中,与Lua栈相关的lua_State结构体成员变量有base,stack,top,lastfree,stack保存的是数组的初始位置,base会根据每次函数调用的情况发生变化,top指针指向的是当前第一个可用的栈位置,每次向栈中增加/删减元素都要对应的增减top指针,lastfee指针指向的书Lua栈的最后位置.</p><p>CallInfo结构体,是每次有函数调用时都会去初始化的一个结构体,它的成员变量中,也有top,base指针,同样的是指向Lua栈的位置,所不同的是,它关注的仅是函数调用时的相关位置.从代码中可以看出,CallInfo数组是有限制的,换言之,在Lua中的嵌套函数调用层次也是有限制,不能超过一定数量.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215144229849-16830691.png" alt=""></p><p>首先看f_parser函数:</p><pre><code>static void f_parser (lua_State *L, void *ud) {  int i;  Proto *tf;  Closure *cl;  struct SParser *p = cast(struct SParser *, ud);  int c = luaZ_lookahead(p-&gt;z);  luaC_checkGC(L);  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                             &amp;p-&gt;buff, p-&gt;name);  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));  cl-&gt;l.p = tf;  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */    cl-&gt;l.upvals[i] = luaF_newupval(L);  setclvalue(L, L-&gt;top, cl);  incr_top(L);}</code></pre><p>f_parser函数的最后两句,将分析完毕之后的结构Closure指针压入了Lua栈.</p><p>再来看luaD_precall函数,这里为将代码放入Lua虚拟机中执行准备了相关数据,我们只截取其中的一部分来看:</p><pre><code>int luaD_precall (lua_State *L, StkId func, int nresults) {  ….  if (!cl-&gt;isC) {  /* Lua function? prepare its call */    CallInfo *ci;    StkId st, base;    Proto *p = cl-&gt;p;// 1) 根据函数的参数类型,计算出该CallInfo的base指针位置    if (!p-&gt;is_vararg) {  /* no varargs? */      base = func + 1;      if (L-&gt;top &gt; base + p-&gt;numparams)        L-&gt;top = base + p-&gt;numparams;    }    else {  /* vararg function */      int nargs = cast_int(L-&gt;top - func) - 1;      base = adjust_varargs(L, p, nargs);      func = restorestack(L, funcr);  /* previous call may change the stack */}// 2) 分配一个新的CallInfo结构体,用于保存此次函数调用的相关信息:top,base指针,func函数    ci = inc_ci(L);  /* now `enter&#39; new function */    ci-&gt;func = func;    L-&gt;base = ci-&gt;base = base;    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);    // 3) LuaState的PC指针指向函数原型的代码数组    L-&gt;savedpc = p-&gt;code;  /* starting point */    // …..    return PCRLUA;  }</code></pre><p>到这一步,跟某次具体的Lua代码执行相关的代码(保存在Proto的code数组中)和执行时所需环境(Lua栈),就已经准备完毕了.后面就是进入Lua虚拟机的主循环中解释执行代码了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.&lt;/p&gt;
&lt;p&gt;lua虚拟机在初始化创建lua_State结构体
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数与upavalue</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E4%B8%8Eupavalue/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数与upavalue/</id>
    <published>2018-12-15T06:35:14.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。</p><p>函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：</p><pre><code>static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {  FuncState *fs = ls-&gt;fs;  Proto *f = fs-&gt;f;  int oldsize = f-&gt;sizep;  int i;  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,                  MAXARG_Bx, &quot;constant table overflow&quot;);  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;  f-&gt;p[fs-&gt;np++] = func-&gt;f;  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));  for (i=0; if-&gt;nups; i++) {    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);  }}</code></pre><p>注意在这个函数的最后，将遍历upvalue数组，根据该upvalue是否是局部变量，来决定紧跟着的是MOVE指令还是GETUPVAL指令。而这些是如何确定的呢？</p><p>Lua的分析器在解析到一个变量时，会调用singlevaraux函数进行查找：</p><pre><code>static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {  if (fs == NULL) {  /* no more levels? */    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */    return VGLOBAL;  }  else {    int v = searchvar(fs, n);  /* look up at current level */    if (v &gt;= 0) {      init_exp(var, VLOCAL, v);      if (!base)        markupval(fs, v);  /* local will be used as an upval */      return VLOCAL;    }    else {  /* not found at current level; try upper one */      if (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)        return VGLOBAL;      var-&gt;u.s.info = indexupvalue(fs, n, var);  /* else was LOCAL or UPVAL */      var-&gt;k = VUPVAL;  /* upvalue in this level */      return VUPVAL;    }  }}</code></pre><p>可以看到，这个函数是一个递归函数，有以下几种情况：</p><ol><li>在函数的当前层找到该变量，则认为一个LOCAL变量</li><li>在函数的上层找到，则认为一个UPVAL</li><li>最后，则认为是一个全局变量。</li></ol><p>如何定义函数的“层次”？来看一个例子就知道了:</p><pre><code>local a = 1function test1()  local b = 100  function test2()     print(a)     print(b)  endendtest1()</code></pre><p>在这个例子中，函数test2与变量b是同层的，所以在调用函数test2时，singlevaraux查找变量b返回的LOCAL变量；而变量a是更上一层的LOCAL变量，对于函数test2而言，它就是UPVAL。</p><p>明白了解析部分是怎么处理upvalue的，来看看在虚拟机中是如何处理的。<br>对应的代码在lvm.c中的这一部分：</p><pre><code>      case OP_CLOSURE: {        Proto *p;        Closure *ncl;        int nup, j;        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];        nup = p-&gt;nups;        ncl = luaF_newLclosure(L, nup, cl-&gt;env);        ncl-&gt;l.p = p;        for (j=0; jl.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];          else {            lua_assert(GET_OPCODE(*pc) == OP_MOVE);            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));          }        }        setclvalue(L, ra, ncl);        Protect(luaC_checkGC(L));        continue;      }</code></pre><p>当变量是UPVAL时，此时PC指令对应的B参数是函数结构体的upval数组的索引，根据它直接从upval数组中取出值来；否则，PC指令对应的B参数是基于函数基地址base的一个偏移量，根据它得到相应的变量；再调用函数luaF_findupval：</p><pre><code>UpVal *luaF_findupval (lua_State *L, StkId level) {  global_State *g = G(L);  GCObject **pp = &amp;L-&gt;openupval;  UpVal *p;  UpVal *uv;  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) {    lua_assert(p-&gt;v != &amp;p-&gt;u.value);    if (p-&gt;v == level) {  /* found a corresponding upvalue? */      if (isdead(g, obj2gco(p)))  /* is it dead? */        changewhite(obj2gco(p));  /* ressurect it */      return p;    }    pp = &amp;p-&gt;next;  }  uv = luaM_new(L, UpVal);  /* not found: create a new one */  uv-&gt;tt = LUA_TUPVAL;  uv-&gt;marked = luaC_white(g);  uv-&gt;v = level;  /* current value lives in the stack */  uv-&gt;next = *pp;  /* chain it in the proper position */  *pp = obj2gco(uv);  uv-&gt;u.l.prev = &amp;g-&gt;uvhead;  /* double link it in `uvhead&#39; list */  uv-&gt;u.l.next = g-&gt;uvhead.u.l.next;  uv-&gt;u.l.next-&gt;u.l.prev = uv;  g-&gt;uvhead.u.l.next = uv;  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);  return uv;}</code></pre><p>注意到，传入这个函数的参数level，其实是前面已经根据base基址定位到的变量。这个函数分为两个部分：</p><ol><li>首先，遍历当前的openupval数组，查找这个变量。由于这个变量肯定是前面已经定义过的，所以查找的条件就是（(p = ngcotouv(*pp))-&gt;v &gt;= level）。当查找到这个变量时，如果是准备释放的变量，则将它重新置为不可释放。</li><li>如果在openval数组中没有找到，说明之前没有别的地方引用过这个upval。如此则重新分配一个upvalue指向待引用的值。</li><li>最后，当函数调用完毕时，有相应的close指令，将upvalue的引用关系去除。具体见函数luaF_close。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。&lt;/p&gt;
&lt;p&gt;函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua虚拟机概述</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>https://bytemode.github.io/2018/12/15/lua虚拟机概述/</id>
    <published>2018-12-15T05:42:38.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为虚拟机"><a href="#何为虚拟机" class="headerlink" title="何为虚拟机"></a>何为虚拟机</h4><p>用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型的语言,经过前端的处理之后,生成的就是opcode,再将该opcode放在这门语言的虚拟机中执行.虚拟机是作为单独的程序独立存在,而Lua由于是一门嵌入式的语言是附着在宿主环境中的.   </p><h3 id="lua代码到虚拟机执行的流程"><a href="#lua代码到虚拟机执行的流程" class="headerlink" title="lua代码到虚拟机执行的流程"></a>lua代码到虚拟机执行的流程</h3><p><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215140547779-1286988518.png" alt=""></p><p>在Lua中,Lua代码从词法分析到语法分析再到生成opcode,最后进入虚拟机执行的大体流程是什么样子的呢？</p><p>Lua的API中提供了luaL_dofile函数,它实际上是个宏,内部首先调用luaL_loadfile函数,加载Lua代码进行语法,词法分析,生成Lua虚拟机可执行的代码,再调用lua_pcall函数,执行其中的代码:</p><pre><code>    #define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>前半部分调用luaL_loadfile函数对Lua代码进行词法和语法分析,后半部分调用lua_pcall将第一步中分析的结果(也就是opcode)到虚拟机中执行.</p><p>首先来看luaL_loadfile函数,暂时不深入其中研究它如何分析一个Lua代码文件,先看它最后输出了什么.它最终会调用f_parser函数,这是对一个Lua代码进行分析的入口函数:</p><pre><code>    static void f_parser (lua_State *L, void *ud) {      int i;      Proto *tf;      Closure *cl;      struct SParser *p = cast(struct SParser *, ud);      int c = luaZ_lookahead(p-&gt;z);      luaC_checkGC(L);      tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                                 &amp;p-&gt;buff, p-&gt;name);      cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));      cl-&gt;l.p = tf;      for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */        cl-&gt;l.upvals[i] = luaF_newupval(L);      setclvalue(L, L-&gt;top, cl);      incr_top(L);    }</code></pre><p>在完成词法分析之后,返回了Proto类型的指针tf,然后将其绑定在新创建的Closure指针上,初始化UpValue,最后压入Lua栈中.</p><p>不难想像,Lua词法分析之后产生的opcode等相关数据都在这个Proto类型的结构体中.</p><p>再来看lua_pcall函数是如何将产生的opcode放入虚拟机执行的.</p><p>lua_pcall函数中,首先获取需要调用的函数指针:</p><pre><code>    c.func = L-&gt;top - (nargs+1);  /* function to be called */</code></pre><p>这里的nargs是由函数参数传入的,luaL_dofile中调用lua_pcall时这里传入的参数是0,换句话说,这里得到的函数对象指针就是在f_parser函数中最后放入Lua栈的指针.</p><p>继续往下执行,走到luaD_call函数,有这一段代码:</p><pre><code>      if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */        luaV_execute(L, 1);  /* call it */</code></pre><p>进入luaV_execute函数,这里是虚拟机执行代码的主函数:</p><pre><code>    void luaV_execute (lua_State *L, int nexeccalls) {      LClosure *cl;      StkId base;      TValue *k;      const Instruction *pc;     reentry:  /* entry point */      lua_assert(isLua(L-&gt;ci));      pc = L-&gt;savedpc;      cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;      base = L-&gt;base;      k = cl-&gt;p-&gt;k;      /* main loop of interpreter */      for (;;) {        const Instruction i = *pc++;        StkId ra;        if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;            (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {          traceexec(L, pc);          if (L-&gt;status == LUA_YIELD) {  /* did hook yield? */            L-&gt;savedpc = pc - 1;            return;          }          base = L-&gt;base;        }        /* warning!! several calls may realloc the stack and invalidate `ra&#39; */        ra = RA(i);    // 以下是各种opcode的情况处理    }</code></pre><p>可以看到,这里的pc指针里存放的是虚拟机opcode代码,它最开始从L-&gt;savepc初始化而来,而L-&gt;savepc在luaD_precall中赋值:</p><pre><code>    L-&gt;savedpc = p-&gt;code;  /* starting point */</code></pre><p>这里的p就是第一步f_parser中返回的Proto指针.</p><p>回顾一下整个流程:</p><ol><li><p>函数f_parser中,对Lua代码文件的分析返回了Proto指针</p></li><li><p>函数luaD_precall中,将Lua_state的savepc指针指向1中的Proto结构体的code指针</p></li><li><p>函数luaV_execute中,pc指针指向2中的savepc指针,紧跟着就是一个大的循环体,依次取出其中的opcode进行执行.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215141251439-1865045097.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;何为虚拟机&quot;&gt;&lt;a href=&quot;#何为虚拟机&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机&quot;&gt;&lt;/a&gt;何为虚拟机&lt;/h4&gt;&lt;p&gt;用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数定义</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数定义/</id>
    <published>2018-12-15T05:24:49.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="FuncState"><a href="#FuncState" class="headerlink" title="FuncState"></a>FuncState</h4><p>proto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue</p><p>Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的FuncState数据.这个结构体的定义:</p><pre><code>typedef struct FuncState {  Proto *f;  /* current function header */  Table *h;  /* table to find (and reuse) elements in  */  struct FuncState *prev;  /* enclosing function */  struct LexState *ls;  /* lexical state */  struct lua_State *L;  /* copy of the Lua state */  struct BlockCnt *bl;  /* chain of current blocks */  int pc;  /* next position to code (equivalent to `ncode&#39;) */  int lasttarget;   /* `pc&#39; of last `jump target&#39;  */  int jpc;  /* list of pending jumps to `pc&#39; */  int freereg;  /* first free register */  int nk;  /* number of elements in `k&#39;  */  int np;  /* number of elements in `p&#39;  */  short nlocvars;  /* number of elements in `locvars&#39; */  lu_byte nactvar;  /* number of active local variables  */  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */} FuncState;</code></pre><p>其中的Proto结构体数组用于保存函数原型信息,包括函数体代码(opcode),之所以使用数组,是因为在某个函数内,可能存在多个局部函数.而prev指针就是指向这个函数的”父函数体”的指针.</p><p>比如以下代码:</p><pre><code>function fun()   function test()   endend</code></pre><p>那么,在保存test函数原型的Proto数据就存放在保存fun函数的FuncState结构体的p数组中,反之,保存test函数的FuncState.prev指针就指向保存func函数的FuncState指针.</p><p>接着看Funcstate结构体的成员,actvar数组用于保存局部变量,比如函数的参数就是保存在这里.另外还有一个存放upval值的upvalues数组.这里有两种不同的处理.如果这个upval是父函数内的局部变量,则生成的是MOVE指令用于赋值;如果对于父函数而言也是它的upval,则生成GET_UPVAL指令用于赋值.</p><p>当开始处理一个函数的定义时,首先调用open_func函数,创建一个新的Proto结构体用于保存函数原型信息,接着将该函数的FuncState的prev指针指向父函数.<br>最后当函数处理完毕时,调用pushclosure函数将这个新的函数的信息push到父函数的Proto数组中.</p><h4 id="函数也是第一类值-可以存在变量里"><a href="#函数也是第一类值-可以存在变量里" class="headerlink" title="函数也是第一类值 可以存在变量里"></a>函数也是第一类值 可以存在变量里</h4><p>最后,由于函数在Lua中是所谓的”first class type”,所以其实以下两段Lua代码是等价的:</p><pre><code>local function test()  -- 可以testend--以上相当于 local test； test = function() ...  endlocal test = function ()   --不可以调用test 以为第一类之定义完成之后才可以使用end</code></pre><p>也就是说,其实是生成一段代码,用于保存函数test的相关信息,之后再将这些信息赋值给变量test,这里的test可以是local,也可以是global的,这一点跟一般的变量无异.</p><h4 id="函数定义词法分析"><a href="#函数定义词法分析" class="headerlink" title="函数定义词法分析"></a>函数定义词法分析</h4><p>所以在与函数定义相关的词法分析代码中:</p><pre><code>static void funcstat (LexState *ls, int line) {  /* funcstat -&gt; FUNCTION funcname body */  int needself;  expdesc v, b;  luaX_next(ls);  /* skip FUNCTION */  needself = funcname(ls, &amp;v);  body(ls, &amp;b, needself, line);  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);  luaK_fixline(ls-&gt;fs, line);  /* definition `happens&#39; in the first line */}</code></pre><p>上面的变量v首先在funcname函数中获得该函数的函数名,变量b在进入函数body之后可以得到函数体相关的内容.在这之后的luaK_storevar调用,就是把b的值赋值给v,也就是前面提到的函数体赋值给函数名.</p>]]></content>
    
    <summary type="html">
    
      函数是第一类值，函数定义有funcstate结构表示，其中包含父函数指针，函数原型数组信息；actvar局部变量数组，upvalues保存upvalue数组信息。
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua字符串类型</title>
    <link href="https://bytemode.github.io/2018/12/14/lua%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://bytemode.github.io/2018/12/14/lua字符串/</id>
    <published>2018-12-14T14:25:11.000Z</published>
    <updated>2018-12-27T08:12:07.822Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中字符串结构体的定义是:</p><pre><code>typedef union TString {  L_Umaxalign dummy;  /* ensures maximum alignment for strings */  struct {    CommonHeader;    lu_byte reserved;    unsigned int hash;    size_t len;  } tsv;} TString;</code></pre><p>这里TString结构体是一个union, 最开始的L_Umaxalign dummy;起到的是对齐作用.紧跟着是CommonHeader,可以看出TString也是可GC数据类型的一种.</p><p>在Lua中,字符串是一个保存在一个全局的地方,在globale_state的strt里面,这是一个hash数组,专门用于存放字符串:</p><pre><code>typedef struct stringtable {  GCObject **hash;  lu_int32 nuse;  /* number of elements */  int size;} stringtable;</code></pre><p>一个字符串TString,首先根据hash算法算出hash值,这就是stringtable中hash的索引值,如果这里已经有元素,则使用链表串接起来.</p><p>同时,TString中的字段reserved,表示这个字符串是不是保留字符串,比如Lua的关键字,在最开始赋值的时候是这么处理的:</p><pre><code>void luaX_init (lua_State *L) {  int i;  for (i=0; itsv.reserved = cast_byte(i+1);  /* reserved word */  }}</code></pre><p>这里存放的值,是数组luaX_tokens中的索引:</p><pre><code>const char *const luaX_tokens [] = {    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;,    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,    &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,    NULL};</code></pre><p>一方面可以迅速定位到是哪个关键字,另方面如果这个reserved字段不为0,则表示该字符串是不可自动回收的,在GC过程中会略过这个字符串的处理.</p><p>具体查找字符串时,首先计算出hash值,定位到所在的strt中的hash数组所在,再遍历hash桶所在链表,首先比较长度,如果相同再继续逐字节的比较字符串内容:</p><pre><code>TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {  GCObject *o;  unsigned int h = cast(unsigned int, l);  /* seed */  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don&#39;t hash all its chars */  size_t l1;  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-1]));  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];       o != NULL;       o = o-&gt;gch.next) {    TString *ts = rawgco2ts(o);    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0)) {      /* string may be dead */      if (isdead(G(L), o)) changewhite(o);      return ts;    }  }  return newlstr(L, str, l, h);  /* not found */}</code></pre>]]></content>
    
    <summary type="html">
    
      lua字符串结构体是TString，TString里的记录了hash值和字符串长度，真正的字符串是存储在全局globale_state的stringtable里面，这是一个gcobject组成的hash表.
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua-pcall的实现</title>
    <link href="https://bytemode.github.io/2018/12/13/lua-pcall%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://bytemode.github.io/2018/12/13/lua-pcall的实现/</id>
    <published>2018-12-13T05:24:24.000Z</published>
    <updated>2018-12-13T05:30:12.410Z</updated>
    
    <content type="html"><![CDATA[<p>Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。</p><p>对比起一般的函数调用方式，pcall多做了这些事情：</p><p>对函数调用前的Lua堆栈进行保护在调用完毕之后恢复，支持传入出错时的函数在调用出错时调用。</p><p>来依次看这个过程。</p><ol><li>首先看入口函数lua_pcall：</li></ol><pre><code>LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {  struct CallS c;  int status;  ptrdiff_t func;  lua_lock(L);  api_checknelems(L, nargs+1);  checkresults(L, nargs, nresults);  if (errfunc == 0)    func = 0;  else {    StkId o = index2adr(L, errfunc);    api_checkvalidindex(L, o);    func = savestack(L, o);  }  c.func = L-&gt;top - (nargs+1);  /* function to be called */  c.nresults = nresults;  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);  adjustresults(L, nresults);  lua_unlock(L);  return status;}</code></pre><p>lua_pcall函数与lua_call相比，多了第四个参数，该函数用于传入错误处理函数在Lua栈中的地址。所以第一步将根据传入的参数得到它的值在函数栈中的地址。然后根据这些参数调用函数luaD_pcall函数。</p><ol start="2"><li>luaD_pcall的实现</li></ol><pre><code>int luaD_pcall (lua_State *L, Pfunc func, void *u,                ptrdiff_t old_top, ptrdiff_t ef) {  int status;  unsigned short oldnCcalls = L-&gt;nCcalls;  ptrdiff_t old_ci = saveci(L, L-&gt;ci);  lu_byte old_allowhooks = L-&gt;allowhook;  ptrdiff_t old_errfunc = L-&gt;errfunc;  L-&gt;errfunc = ef;  status = luaD_rawrunprotected(L, func, u);  if (status != 0) {  /* an error occurred? */    StkId oldtop = restorestack(L, old_top);    luaF_close(L, oldtop);  /* close eventual pending closures */    luaD_seterrorobj(L, status, oldtop);    L-&gt;nCcalls = oldnCcalls;    L-&gt;ci = restoreci(L, old_ci);    L-&gt;base = L-&gt;ci-&gt;base;    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;    L-&gt;allowhook = old_allowhooks;    restore_stack_limit(L);  }  L-&gt;errfunc = old_errfunc;  return status;}</code></pre><p>这个函数首先将一些需要保存以便以后进行错误恢复的值保存，然后调用函数luaD_rawrunprotected。</p><ol start="3"><li>在luaD_rawrunprotected中，</li></ol><pre><code>int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {  struct lua_longjmp lj;  lj.status = 0;  lj.previous = L-&gt;errorJmp;  /* chain new error handler */  L-&gt;errorJmp = &amp;lj;  LUAI_TRY(L, &amp;lj,    (*f)(L, ud);  );  L-&gt;errorJmp = lj.previous;  /* restore old error handler */  return lj.status;}</code></pre><p>可以看到的是，在Lua中，涉及到这些错误恢复的数据，实际上形成一个链条关系，这个函数首先将之前的错误链保存起来。而LUAI_TRY这个宏，会根据不同的编译器进行实现，比如C++中使用的try…catch，C中使用longjmp等。</p><ol start="4"><li>再来看看真正出错的时候是如何处理的。</li></ol><pre><code>void luaG_errormsg (lua_State *L) {  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */    StkId errfunc = restorestack(L, L-&gt;errfunc);    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);    setobjs2s(L, L-&gt;top, L-&gt;top - 1);  /* move argument */    setobjs2s(L, L-&gt;top - 1, errfunc);  /* push function */    incr_top(L);    luaD_call(L, L-&gt;top - 2, 1);  /* call it */  }  luaD_throw(L, LUA_ERRRUN);}</code></pre><p><strong>首先如果之前保存的errfunc不为空，则首先从Lua栈中得到该函数，如果判断这个地址存放的不是一个函数则直接抛出错误。否则将错误参数压入栈中调用该错误处理函数。最后调用LuaD_throw函数，这个函数与前面的LUAI_TRY宏是对应的。这样就可以回到原来保存的错误恢复地点，恢复调用前的Lua栈，继续执行下去，而不是导致宿主进程退出。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt;
&lt;p&gt;对比起一般的函数调用方式，pcall多做了这些事情：&lt;/p&gt;
&lt;p&gt;对函数调用前的
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表的创建和初始化</title>
    <link href="https://bytemode.github.io/2018/12/13/lua%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://bytemode.github.io/2018/12/13/lua表的创建和初始化/</id>
    <published>2018-12-13T05:11:44.000Z</published>
    <updated>2018-12-13T05:21:36.681Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表的基本实现"><a href="#表的基本实现" class="headerlink" title="表的基本实现"></a>表的基本实现</h4><p>在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为数组部分和hash部分。比如：</p><pre><code>local t = {1,2,3,4,5}</code></pre><p>以上分配一个Lua数组，依次为1到5.</p><p>而如果要初始化hash部分，则需要指定key，有两种方式：</p><pre><code>local t = {a=&quot;test&quot;}local t = {[&quot;a&quot;]=&quot;test&quot;}</code></pre><p>以上都指定了key为”a”的元素对应的值是”test”（注意一些上面两种情况key分别可以加引号和不加引号的）。</p><h5 id="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："><a href="#现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：" class="headerlink" title="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："></a>现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：</h5><ol><li><p>NEWTABLE指令。</p><p>指令域A指定的是所要创建的表在Lua栈中的地址，而B,C则分别指定的是创建表时数组和hash部分的初始大小。</p></li><li><p>SETLIST指令。</p><p>需要特别说明的是，这个指令仅能用于初始化Lua表的数组部分时使用，hash部分没有作用。指令域A同样指定的是所要初始化的表在Lua栈中的地址，B指定的是初始化时数组的数量，而C指定的是BLOCK的数量。这里需要做一个说明。在Lua中有一个特殊的常量，叫FPF（fields per flush），可以简单的理解为，每次调用SETLIST指令时，写入数组的数量最多可以有多少，Lua中这个常量定义为50.于是，假如这里要初始化一个有60个元素的数组，那么将会拆分成两个SETLIST指令，第一个SETLIST指令，B为50，C为1，而第二个SETLIST指令，B为10而C为0.</p></li></ol><h5 id="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"><a href="#实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。" class="headerlink" title="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"></a>实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。</h5><ol><li>lopcodes.h中对这个指令的注释为：</li></ol><pre><code>OP_SETLIST,/*   A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B        */</code></pre><p>需要注意的是，A在这里既指定了表的栈位置，还有另一层含义从”=”右边可知，A在栈中紧跟着的数据是需要初始化给A数组的数据，所以A在这个指令中负担了两个数据的指示。换言之，当在A位置创建了这个Lua表之后，紧跟着这个Lua表的数据（数量由B指定）则是准备初始化给Lua表的数据。</p><ol><li>Lua还要处理某些情况下，数组元素可变的情况，比如:</li></ol><pre><code>local t = {func()}</code></pre><p>可以看到，此时数组元素的数量是不确定的，依赖于函数的返回值，而当解析到这个点时，也并不知道func的具体情况。Lua在这里的处理是将B置为0，表示从A+1位置开始直到这个函数栈的栈顶位置之间的元素全部用来初始化这个Lua表的数组部分。</p><ol start="2"><li>C也有可能为0，但是这种情况很少有，仅当初始化数组的数量非常大的时候出现，这里就不做分析了（因为要模拟这种情况有些蛋疼）。</li></ol><h4 id="Lua源码中相关的实现。"><a href="#Lua源码中相关的实现。" class="headerlink" title="Lua源码中相关的实现。"></a>Lua源码中相关的实现。</h4><p>分析Lua表创建部分的入口函数是lparser.c中的constructor函数。<br>首先，函数调用pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);生成一个NEWTABLE指令，注意在这里，B/C部分都是0，从前面的分析知道，这两部分分别指定的是Lua表的数组和hash部分的初始尺寸，因为在这里这两部分的大小并不知道，所以先填0，而保存在pc中是要保存这个生成的NEWTABLE指令，后面需要对B/C部分进行改写，填充数组和hash部分的尺寸。</p><p>紧跟着，在解析Lua表初始化的整个流程中，使用了结构体ConsControl：</p><pre><code>struct ConsControl {  expdesc v;  /* last list item read */  expdesc *t;  /* table descriptor */  int nh;  /* total number of `record&#39; elements */  int na;  /* total number of array elements */  int tostore;  /* number of array elements pending to be stored */};</code></pre><p>每一项的含义分别是，v表示的是上一个解析到表元素，它可能是一个key-value形式的赋值（此时是初始化一个hash元素），也有可能是单独的元素（此时是初始化一个数组元素）；t是一个指针，存放的是待初始化的Lua表；nh和na分别表示表的hash和数组部分尺寸，解析过程中将用这两个变量记录以便在最后重新填充前面的NEWTABLE的B/C部分；tostore则是存放的当前已经有多少数组元素待存放到Lua表中，当这个值达到FPF时，根据上面的分析则生成一个SETLIST指令，然后重新值0进入下一个元素的处理。</p><pre><code>   checknext(ls, &#39;{&#39;);   do {      lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);      if (ls-&gt;t.token == &#39;}&#39;) break;      closelistfield(fs, &amp;cc);      switch(ls-&gt;t.token) {        case TK_NAME: {  /* may be listfields or recfields */          luaX_lookahead(ls);         if (ls-&gt;lookahead.token != &#39;=&#39;)  /* expression? */           listfield(ls, &amp;cc);         else           recfield(ls, &amp;cc);         break;       }       case &#39;[&#39;: {  /* constructor_item -&gt; recfield */         recfield(ls, &amp;cc);         break;       }       default: {  /* constructor_part -&gt; listfield */         listfield(ls, &amp;cc);         break;       }     }   } while (testnext(ls, &#39;,&#39;) || testnext(ls, &#39;;&#39;));   check_match(ls, &#39;}&#39;, &#39;{&#39;, line);   lastlistfield(fs, &amp;cc);   SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */   SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh));  /* set initial table size */</code></pre><p>这个分析过程的主体部分，是一个循环，循环的终止条件是遇到了”}”符号，则该数组的初始化部分完成。<br>每次循环做以下的事情：</p><ol><li><p>调用closelistfield函数。</p><p>它是对数组元素做处理。首先将上一个分析到的数组元素，写入到当前的Lua栈中，这一点可以结合前面分析SETLIST指令来看。同时，如果当前的tostore数量达到FPF时，则生成SETLIST指令，这一点前面也做了分析。</p></li><li><p>然后就是两种情况的处理：</p><p>hash和数组部分，可以参看最开始Lua表初始化的语法就能知道什么语法是用于初始化hash部分，什么语法是初始化数组部分的了。分别调用的是recfield和listfield函数。</p></li></ol><p>listfield函数相对简单，需要判断当前表的数组元素是不是超过了限制，同时增加na和tostore计数。</p><p>recfield稍微复杂一点，还涉及到另一个指令SETTABLE，暂时跳过下一节再解释，现在知道它肯定会增加na计数就可以了。</p><ol start="3"><li>最后，由于初始化Lua表时，不同的元素之间是以”,”或者”;”做分割的，所以在遇到”}”退出循环之后，还有最后一个元素没有处理，于是还要调用lastlistfield函数进行处理。</li></ol><p>lastlistfield函数要处理的情况，就是前面分析过的，初始化过程中是不是遇到了函数返回值的情况，如果有则生成的SETLIST指令的域B要为0.</p><ol start="4"><li>最后就是根据分析过程中得到的na，nh数量重新填充NEWTABLE指令的B/C域了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;表的基本实现&quot;&gt;&lt;a href=&quot;#表的基本实现&quot; class=&quot;headerlink&quot; title=&quot;表的基本实现&quot;&gt;&lt;/a&gt;表的基本实现&lt;/h4&gt;&lt;p&gt;在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua require机制</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%20require%E6%9C%BA%E5%88%B6/"/>
    <id>https://bytemode.github.io/2018/12/12/lua require机制/</id>
    <published>2018-12-12T13:45:37.000Z</published>
    <updated>2018-12-12T13:46:33.620Z</updated>
    
    <content type="html"><![CDATA[<p>require(modname)</p><p>加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.</p><p>如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader).</p><p>要找到一个加载器,require首先查询package.preloaded[modname].如果它有值,该值(应该是一个函数)就是加载器.</p><p>如果没值require使用package.path中存储的路径查找一个Lua的加载器.如果该查找也失败,它使用package.cpath中</p><p>存储的路径查找一个C语言加载器(C loader).如果还是失败,它尝试使用all-in-one加载器(如下)</p><p>当加载一个C库的时候,require首先使用动态链接工具将应用程序与库连接起来.之后它尝试找到一个该库中的C函数,该函数要被当做加载器使用.这个C函数的名称是字符串”luaopen_”连接着复制的模块名(模块名称中的每个点号”.”都被替换为一个下划线).此外,如果模块名称含有连字符”-“,则第一个连字符的前缀(包括连字符)都被移除.比如,如果模块名称是a.v1-b.c,则函数名称将是luaopen_b_c.</p><p>如果require即没有为模块找到一个Lua库也没有为模块找到一个C库,他将调用all-in-one加载器.该加载器为给定模块的根名称查找C路径找到对应库(原文:this loader searches the C path for a library for the root name of the given module).例如,当require a.b.c时,它将为a查找一个库.如果找到,它查询该库内部为子模块找到一个开放函数(open function);在我们这个例子中将会是luaopen_a_b_c.使用这个便利机制(facility),一个包可以将几个子模块打包进单个的库中,同时每个子模块保存着它本来的开放函数.</p><p>一旦找到一个加载器,require使用单个的参数modname调用加载器.如果加载器返回任何值,require将其赋值给package.loaded[modname].</p><p>如果加载器没有返回值且没有给package.loaded[modname]赋与任何值,则require为该条目赋值为true.</p><p>无论如何,require返回package.loaded[modname]的最终值.</p><p>如果加载或者运行模块有任何错误,或者他不能为模块找到一个加载器,则require发出一个错误信号.</p><p>require函数的实现原理如下:</p><ol><li>–require 函数的实现  </li><li>function require(name)  </li><li>​    if not package.loaded[name] then    –是否在package.loaded中存在name</li><li>​        local loader = findloader(name) –不存在则查找加载器 </li><li>​        if loader == nil then  </li><li>​            error(“unable to load module” .. name)  </li><li>​        end  </li><li>​        package.loaded[name] = true     –加载器不存在 设置true</li><li>​        local res = loader(name)        –加载</li><li>​        if res ~= nil then  </li><li>​            package.loaded[name] = res  –加载返回的值给你 package.loaded</li><li>​        end  </li><li>​    end  </li><li>​    return package.loaded[name]         –返回 package.loaded[name]</li><li>end  </li></ol><p>package.cpath</p><p>由require使用查找C加载器的路径</p><p>Lua初始化C路径package.cpath的方法与初始化Lua路径package.path的相同,使用LUA_CPATH中的环境变量(另外一个默认的路径在luaconf.h中定义)</p><p>package.loaded</p><p>一个用于控制哪些模块已经加载的表,该表由require使用.当require一个模块名为modname的模块且package.loaded[modname]不为false时,require仅返回package.loaded[modname]存储的值.</p><p>package.loadlib(libname,funcname)</p><p>使用C库libname动态链接到宿主程序.在这个库中,寻找函数funcname并将该函数作为一个C函数返回.(所以,funcname必须遵守协议(参见lua_CFunction)).</p><p>这是一个底层函数.它完全绕过了package和module系统.与require不同,它不执行任何路径查找且不自动添加扩展名.libname必须是C库中完整的文件名,如果必要的话还要包含路径和扩展名.funcname必须是原封不动的C库中导出的名字(这可能取决于使用的C编译器和链接器).</p><p>这个函数不被ANSI C支持.就其本身而言,它只在一些平台上才能使用(Windows,Linux,Mac OS X,Solaris,BSD,加上其他支持dlfcn标准的Unix系统)</p><p>package.path</p><p>require用于查找Lua加载器的路径</p><p>在启动时,Lua使用环境变量LUA_PATH或者如果环境变量未定义就使用luaconf.h中定义的默认值来初始化该值.环境变量中的任何”::”都被替换为默认路径.</p><p>路径是一系列由分号隔开的模板(templates).对于每个模板,require将每个模板中的问号替换为filename,filename是modname中每个点都被替换成”目录分隔符”(比如Unix中的”/“)(这句感觉翻译不准确,原文:For each template,require will change each interrogation mark in the template by filename,which is modname with each dot replaced by a “directory separator”(such as “/“ in Unix));之后他将加载产生的文件名.因此,举个例子,如果Lua路径是”./?.lua;./?.lc;/usr/local/?/init.lua”,为模块foo查找一个Lua加载器将会尝试以如下顺序加载文件./foo.lua,./foo.lc和/usr/local/foo/init.lua</p><p>package.preload</p><p>为特定模块存储加载器的一个表(参见require)</p><p>package.seeall(module)</p><p>为module设置一个元表,module的__index只想全局环境(global environment),以便该module继承全局环境中的值.作为函数module中的一个选项来使用.</p><p>在Programming Lua中是这么讲的:</p><p>默认情况下,module不提供外部访问.必须在调用它之前,为需要访问的外部函数或模块声明适当的局部变量.也可以通过继承来实现外部访问,只需在调用module时附加一个选项package.seeall.这个选项等价于如下代码:</p><ol><li>setmetatable(M,{__index = _G})  </li></ol><p>因而只需这么做:</p><ol><li>module(…,package.seeall)  </li></ol><p>module(name,[,…])</p><p>创建一个模块.如果在package.loaded[name]中有表,该表便是创建的模块.否则,如果有一个全局表t其名称与给定名称相同,则该全局表便是创建的模块.否则创建一个新的表t</p><p>lua中import和require的区别</p><p>载入一个模块</p><p>import() 与 require() 功能相同，但具有一定程度的自动化特性。</p><p>假设有如下的目录结构：</p><p>app/</p><p>app/classes/</p><p>app/classes/MyClass.luaapp/classes/MyClassBase.luaapp/classes/data/Data1.luaapp/classes/data/Data2.lua</p><p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p><p>local MyClassBase = require(“app.classes.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = require(“app.classes.data.Data1”)</p><p>local Data2 = require(“app.classes.data.Data2”)</p><p>假如将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p><p>而使用 import()，只需要如下写：</p><p>local MyClassBase = import(“.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = import(“.data.Data1”)</p><p>local Data2 = import(“.data.Data2”)</p><p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p><p>可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p><p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。如果需要在函数中调用 import()，那么就需要指定当前模块名：</p><p># MyClass.lua</p><p># 这里的 … 是隐藏参数，包含了当前模块的名字，所以最好将这行代码写在模块的第一行</p><p>local CURRENT_MODULE_NAME = …</p><p>local function testLoad() local MyClassBase = import(“.MyClassBase”, CURRENT_MODULE_NAME)</p><p># 更多代码</p><p>end</p><p>Parameters</p><p>string moduleName 要载入的模块的名字</p><p>[string currentModuleName]</p><p>当前模块名</p><p>Returns</p><p>module</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;require(modname)&lt;/p&gt;
&lt;p&gt;加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.&lt;/p&gt;
&lt;p&gt;如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua错误跟踪</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E9%94%99%E8%AF%AF%E8%B7%9F%E8%B8%AA/"/>
    <id>https://bytemode.github.io/2018/12/12/lua错误跟踪/</id>
    <published>2018-12-12T13:35:21.000Z</published>
    <updated>2018-12-12T14:47:33.220Z</updated>
    
    <content type="html"><![CDATA[<p>pcall() xpcall()  debug.traceback() debug.debug() assert()</p><p>错误</p><p>Errare humanum est（拉丁谚语：犯错是人的本性）。所以我们要尽可能的防止错误的发生，Lua经常作为扩展语言嵌入在别的应用中，所以不能当错误发生时简单的崩溃或者退出。相反，当错误发生时Lua结束当前的chunk并返回到应用中。</p><p>当Lua遇到不期望的情况时就会抛出错误，比如：两个非数字进行相加；调用一个非函数的变量；访问表中不存在的值等（可以通过metatables修改这种行为，后面介绍）。你也可以通过调用error函数显式地抛出错误，error的参数是要抛出的错误信息。</p><p>print “enter a number:”</p><p>n = io.read(“*number”)</p><p>if not n then error(“invalid input”) end</p><p>Lua提供了专门的内置函数assert来完成上面类似的功能：</p><p>print “enter a number:”</p><p>n = assert(io.read(“*number”), “invalid input”)</p><p>assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。第二个参数是可选的。注意，assert会首先处理两个参数，然后才调用函数，所以下面代码，无论n是否为数字，字符串连接操作总会执行：</p><p>n = io.read()</p><p>assert(tonumber(n), “invalid input: “ .. n .. “ is not a number”)</p><p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。选择哪一种方式，没有固定的规则，不过基本的原则是：对于程序逻辑上能够避免的异常，以抛出错误的方式处理之，否则返回错误代码。</p><p>例如sin函数，假定我们让sin碰到错误时返回错误代码，则使用sin的代码可能变为：</p><p>local res = math.sin(x)</p><p>if not res then      – error</p><p>​    …</p><p>当然，我们也可以在调用sin前检查x是否为数字：</p><p>if not tonumber(x) then     – error: x is not a number</p><p>​    …</p><p>而事实上，我们既不是检查参数也不是检查返回结果，因为参数错误可能意味着我们的程序某个地方存在问题，这种情况下，处理异常最简单最实际的方式是抛出错误并且终止代码的运行。</p><p>再来看一个例子。io.open函数用于打开文件，如果文件不存在，结果会如何？很多系统中，我们通过“试着去打开文件”来判断文件是否存在。所以如果io.open不能打开文件（由于文件不存在或者没有权限），函数返回nil和错误信息。依据这种方式，我们可以通过与用户交互（比如：是否要打开另一个文件）合理地处理问题：</p><pre><code>local file, msgrepeat    print &quot;enter a file name:&quot;    local name = io.read()    if not name then return end     -- no input    file, msg = io.open(name, &quot;r&quot;)    if not file then print(msg) enduntil file</code></pre><p>如果你想偷懒不想处理这些情况，又想代码安全的运行，可以使用assert：</p><p>file = assert(io.open(name, “r”))</p><p>Lua中有一个习惯：如果io.open失败，assert将抛出错误。</p><p>file = assert(io.open(“no-file”, “r”))</p><p>​       –&gt; stdin:1: no-file: No such file or directory</p><p>注意：io.open返回的第二个结果（错误信息）会作为assert的第二个参数。</p><p>虽然你可以使用任何类型的值作为错误信息，通常情况下，我们使用字符串来描述遇到的错误。如果遇到内部错误（比如对一个非table的值使用索引下标访问）Lua将自己产生错误信息，否则Lua使用传递给error函数的参数作为错误信息。不管在什么情况下，Lua都尽可能清楚的描述问题发生的缘由。</p><p>local status, err = pcall(function () a = ‘a’+1 end)</p><p>print(err)</p><p>–&gt; stdin:1: attempt to perform arithmetic on a string value</p><p>local status, err = pcall(function () error(“my error”) end)</p><p>print(err)</p><p>–&gt; stdin:1: my error</p><p>例子中错误信息给出了文件名（stdin）与行号。</p><p>函数error还可以有第二个参数，表示错误发生的层级。比如，你写了一个函数用来检查“error是否被正确调用”：</p><pre><code>function foo (str)    if type(str) ~= &quot;string&quot; then       error(&quot;string expected&quot;)    end    ...end</code></pre><p>可有人这样调用此函数：</p><p>foo({x=1})</p><p>Lua会指出发生错误的是foo而不是error，实际上，错误是调用error时产生的。为了纠正这个问题，修改前面的代码让error报告错误发生在第二级（你自己的函数是第一级）如下：</p><pre><code>function foo (str)    if type(str) ~= &quot;string&quot; then       error(&quot;string expected&quot;, 2)    end    ...end</code></pre><p>当错误发生的时候，我们常常希望了解详细的信息，而不仅是错误发生的位置。若能了解到“错误发生时的栈信息”就好了，但pcall返回错误信息时，已经释放了保存错误发生情况的栈信息。因此，若想得到tracebacks，我们必须在pcall返回以前获取。Lua提供了xpcall来实现这个功能，xpcall接受两个参数：调用函数、错误处理函数。当错误发生时，Lua会在栈释放以前调用错误处理函数，因此可以使用debug库收集错误相关信息。有两个常用的debug处理函数：debug.debug和debug.traceback，前者给出Lua的提示符，你可以自己动手察看错误发生时的情况；后者通过traceback创建更多的错误信息，也是控制台解释器用来构建错误信息的函数。你可以在任何时候调用debug.traceback获取当前运行的traceback信息：</p><p>print(debug.traceback())</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pcall() xpcall()  debug.traceback() debug.debug() assert()&lt;/p&gt;
&lt;p&gt;错误&lt;/p&gt;
&lt;p&gt;Errare humanum est（拉丁谚语：犯错是人的本性）。所以我们要尽可能的防止错误的发生，Lua经常作为扩展语言
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua用法2</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E7%94%A8%E6%B3%952/"/>
    <id>https://bytemode.github.io/2018/12/12/lua用法2/</id>
    <published>2018-12-12T13:33:40.000Z</published>
    <updated>2018-12-12T13:34:15.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="loadstring-load"><a href="#loadstring-load" class="headerlink" title="loadstring load"></a>loadstring load</h1><p>从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). </p><p>一般如下用法：<br><code>assert(loadstring(script))()</code><br><code>f = loadstring(&quot;a = 1&quot;)</code><br>语义上相当于：<br><code>f = loadstring(&quot;function() a = 1 end&quot;)</code><br>复杂用法如下：<br>下面是动态加载字符串，并执行，结果为一个table       </p><pre><code>local script = &quot;localee={[0]={id=0,lv=5,text=&#39;yy&#39;},[1]={id=1,lv=3,text=&#39;zz&#39;}}  return ee&quot;  local tb=assert(loadstring(script))()  print(tb[0].text)  </code></pre><p>下面是动态加载字符串，并执行，结果为方法</p><pre><code>local addscript=&quot;function dadd(a,b) return a+b  end&quot;  assert(loadstring(addscript))()  print(tostring(dadd(2,3)))  </code></pre><pre><code>local f = load(&quot;a=1+2&quot;)print(type(f))  --function</code></pre><h1 id="loadfile"><a href="#loadfile" class="headerlink" title="loadfile"></a>loadfile</h1><p>loadfile 编译Lua外部代码块，但不会运行代码，将会以函数的形式返回编译结果.返回编译结果函数.</p><pre><code>local f = laodfile(&quot;a.lua&quot;)print(type(f)) --function</code></pre><h1 id="dofile"><a href="#dofile" class="headerlink" title="dofile"></a>dofile</h1><p>dofile 直接编译运行Lua外部代码块，并不返回任何结果。编译错误会返回nil.  </p><pre><code>function dofile(filename)    local func = assert(loadfile(filename))    func()end</code></pre><h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><p><code>load (chunk [, chunkname [, mode [, env]]])</code><br>加载一个代码块。<br>如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。</p><p>如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。<br>chunkname 在错误消息和调试消息中，用于代码块的名字。<br>字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 “b” （只能是二进制代码块）， “t” （只能是文本代码块）， 或 “bt” （可以是二进制也可以是文本）。 默认值为 “bt”。       </p><h1 id="ENV"><a href="#ENV" class="headerlink" title="_ENV"></a>_ENV</h1><p>引用一个叫 var 的自由名字在句法上都被翻译为 _ENV.var 。 此外，每个被编译的 Lua 代码块都会有一个外部的局部变量叫 _ENV。</p><p> 这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。    当编译器在转译自由名字时所用到的 _ENV ， 指的是你的程序在那个点上可见的那个名为 _ENV 的变量<br>被 _ENV 用于值的那张表被称为 环境。   </p><p>Lua保有一个被称为 全局环境 特别环境。它被保存在 C 注册表的一个特别索引下。<br>在 Lua 中，全局变量 _G 被初始化为这个值。 </p><p>当 Lua 加载一个代码块，_ENV 这个上值的默认值就是这个全局环境。         因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项        （它们也被称为 全局变量 ）。<br>此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。 你可以用 load （或 loadfile）加载代码块，并赋予它们不同的环境。 （在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境。）    </p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>如果 index 是个数字， 那么返回参数中第 index 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，index 必须是字符串 “#”， 此时 select 返回参数的个数。 </p><pre><code>do      function foo(...)          for i = 1, select(&#39;#&#39;, ...) do //get the count of the params              local arg = select(i, ...);//select the param              print(&quot;arg&quot;, arg);          end      end      foo(1, 2, 3, 4);  end</code></pre><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><p><code>next (table [, index])</code><br>允许程序遍历表的所有字段。它的第一个参数是一个表，它的第二个参数是该表的索引。接下来返回表及其关联值的一个索引。</p><pre><code>local tee = {1, 3, 4, 6, 8}t = {3,7,10,17, pi=3.14159, banana=&quot;yellow&quot;}for key,value in next,t,nil do print(key,value)endfunction pairs (t)    return next, t, nilendfor k, v in pairs(t) do    print(k, v)end</code></pre><h1 id="pcall"><a href="#pcall" class="headerlink" title="pcall"></a>pcall</h1><p><code>pcall (f [, arg1, ···])</code></p><p>传入参数，以 保护模式 调用函数 f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。</p><p><code>local ret, msg = pcall(function(i) print(i) end, 33)</code></p><h1 id="xpcall"><a href="#xpcall" class="headerlink" title="xpcall"></a>xpcall</h1><p><code>xpcall (f, msgh [, arg1, ···])</code><br>这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。</p><pre><code>local function __TRACKBACK__(errmsg)    local track_text = debug.traceback(tostring(errmsg), 6);    print(track_text, &quot;LUA ERROR&quot;);    return false;endlocal function trycall(func, ...)    local args = { ... };    return xpcall(function() func(unpack(args)) end, __TRACKBACK__);endlocal function test(aaa)    print(&quot;#&quot;..aaa)endtrycall(test, nil)</code></pre><h1 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h1><p>使用[[ sun feng sunfeng ]]  定义多行文本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;loadstring-load&quot;&gt;&lt;a href=&quot;#loadstring-load&quot; class=&quot;headerlink&quot; title=&quot;loadstring load&quot;&gt;&lt;/a&gt;loadstring load&lt;/h1&gt;&lt;p&gt;从给定的字符串得到块(函数)。lua
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua版本变化</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96/"/>
    <id>https://bytemode.github.io/2018/12/12/lua版本变化/</id>
    <published>2018-12-12T13:31:21.000Z</published>
    <updated>2018-12-12T14:47:58.254Z</updated>
    
    <content type="html"><![CDATA[<h4 id="从-Lua-5-1-迁移到-5-2"><a href="#从-Lua-5-1-迁移到-5-2" class="headerlink" title="从 Lua 5.1 迁移到 5.2"></a>从 Lua 5.1 迁移到 5.2</h4><ul><li><p>5.2中抛弃module，建议使用require进行加载， 可能是考虑到Module定义对全局表的污染</p></li><li><p>在5.1版本，可以理解为每个<a href="https://www.lua.org/pil/1.1.html" target="_blank" rel="noopener">chunk</a>都具有自己的环境表，然后通过setfenv/getfenv进行设置和操作。Lua5.2开始取消了环境表的概念，取消setfenv/getfenv方法，增加了_Env来管理。</p></li><li><p>_G 和 _Env*</p></li></ul><p>_G 是放在注册表LUA_RIDX_GLOBALS中，初始化时核心的库都放在_G中；_Env 是chunk闭包的第一个upvalue，load时默认为_G, 然后后面定义的变量都会在编译时加上_ENV.前缀，以此传递下去，当然也可以修改</p><ul><li>全局注册表</li></ul><p>在5.2中已经移除了LUA_GLOBALSINDEX,去而带之的是注册表。5.2以后中上面两个函数都是使用的注册标中的LUA_RIDX_GLOBAS伪索引（索引注册表的全局环境）。处理 lua和C交互API的时候需要注意</p><ul><li>luaL_register</li></ul><p>Lua5.2 以后取消了这个接口，不过可以通过luaL_setfunc方法看来实现</p><p>#undef luaL_register #define luaL_register(L,n,f) \     { if ((n) == NULL) luaL_setfuncs(L,f,0); else luaL_newlib(L,f); } #endif</p><h4 id="从-Lua-5-2-迁移到-5-3"><a href="#从-Lua-5-2-迁移到-5-3" class="headerlink" title="从 Lua 5.2 迁移到 5.3"></a>从 Lua 5.2 迁移到 5.3</h4><ul><li>整数 (默认 64 位)，32 位整数的官方支持</li><li>位操作符</li><li>基本的 utf-8 支持</li><li>值的打包及解包函数</li><li>整数除法</li><li>ipairs 以及表处理库都会考虑元方法</li><li>新函数 string.pack</li><li>新函数 string.unpack</li><li>新函数 string.packsize</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;从-Lua-5-1-迁移到-5-2&quot;&gt;&lt;a href=&quot;#从-Lua-5-1-迁移到-5-2&quot; class=&quot;headerlink&quot; title=&quot;从 Lua 5.1 迁移到 5.2&quot;&gt;&lt;/a&gt;从 Lua 5.1 迁移到 5.2&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;5
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua迭代器</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://bytemode.github.io/2018/12/12/lua迭代器/</id>
    <published>2018-12-12T13:28:22.000Z</published>
    <updated>2018-12-12T13:29:38.051Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器都需要在每次成功调用之后保存一些状态，这样才能知道它所在的位置及如何走到下一个位置，通过之前博文的总结，闭包对于这样的任务提供了极佳的支持。现在我们就用代码来实现一个简单的迭代器。</p><pre><code>function values(tb)     local i = 0     return function ()          i = i + 1          return tb[i]     endendlocal testTb = {10, 20, 30}for value in values(testTb) do     print(value)end</code></pre><p>这就是一个最简单的迭代器，使用闭包来完成整个任务；这只是一个简单的例子，接下来，再看看泛型for的语义。</p><h4 id="泛型for的语义"><a href="#泛型for的语义" class="headerlink" title="泛型for的语义"></a>泛型for的语义</h4><p>泛型for比较复杂，它在循环过程内保存了迭代器函数。它实际上保存着3个值：一个迭代器函数、一个恒定状态和一个控制变量。接下来，分别进行总结。<br>泛型for的语法如下：</p><pre><code>for &lt;var-list&gt; in &lt;exp-list&gt; do     &lt;body&gt;end</code></pre><p>其中，<var-list>是一个或多个变量名的列表，以逗号分隔；<exp-list>是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器函数的调用。例如：</exp-list></var-list></p><p>for k, v in pairs(t) do print(k, v) end<br>for做的第一件事就是对in后面的表达式求值，这些表达式应该返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。这里和多重赋值是一样的，只有最后一个表达式才会产生多个结果，并且只会保留前3个值，多余的值会被丢弃；而不够的话，就以nil补足。</p><p>在初始化完成以后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环就终止，否则，for执行它的循环体，随后再次调用迭代器函数，并重复这个过程。在前言部分的代码中，只是返回了迭代器函数，并没有返回恒定状态和控制变量。下面通过代码来说明这个问题，比如：</p><pre><code>for var_1, ..., var_n in &lt;explist&gt; do &lt;block&gt; end -- 就等价于以下代码：do     local _f, _s, _var = &lt;explist&gt;    -- 返回迭代器函数、恒定状态和控制变量的初值     while true do          local var_1, ..., var_n = _f(_s, _var)          _var = var_1          if _var == nil then break end          &lt;block&gt;          end     endend</code></pre><h4 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h4><p>所谓“无状态的迭代器”，就是一种自身不保存任何状态的迭代器。因此，我们可以在多个循环中使用同一个无状态的迭代器，避免创建新的闭包的开销。</p><p>在每次迭代中，for循环都会用恒定状态和控制变量来调用迭代器函数。一个无状态的迭代器可以根据这两个值来为下次迭代生成下一个元素。这类迭代器的代表就是ipairs。它可以用来迭代一个数组的所有元素。如下述演示代码：</p><pre><code>local aTb = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;}for i, v in ipairs(aTb) do     print(i, v)end</code></pre><p>在这里，迭代器状态就是需要遍历的table（一个恒定状态，它不会在循环中改变）及当前的索引值（控制变量）。我们可以使用Lua代码来实现ipairs，大概就如下代码：</p><pre><code>local function iter(a, i)     i = i + 1     local v = a[i]     if v then          return i, v     endendfunction ipairs(a)     return iter, a, 0end</code></pre><p>函数pairs与ipairs类似，也是用于遍历一个table中的所有元素。不同的是，它的迭代器函数是Lua中的一个基本函next。</p><pre><code>function pairs(a)     return next, t, nilend</code></pre><p>在调用next(t, k)时，k是table t的一个key。此调用会以table中的任意次序返回一组值：此table的下一个key，及这个key所对应的值。而调用next(t, nil)时，返回table的第一组值。若没有下一组值时，next返回nil。所以，我们也可以使用next来判断一个table是否为空。</p><p>对于大家经常迷惑的ipairs和pairs的区别，在这里就能看的一清二楚了，ipairs只能用于遍历index是整型的table，同时，由于ipairs返回的控制变量初值为0，这就决定了，ipairs只能访问index从1开始的key和value；ipairs不能返回nil，当key对应的值为nil时，就直接终止遍历；而pairs则没有要求。关于ipairs和pairs的具体差异，请参考这篇博文：点这里。</p><p>当然了，有了无状态的迭代器，就有了有状态的迭代器了，有状态的迭代器就是专门用一个table来保存状态；在无状态的迭代器中，我们每一次都是迭代一个table，这个table就是一个无状态的table，它不会再遍历的过程中发生变化，而有状态的迭代器，则会在遍历的过程中对迭代的table进行变更，迭代的table的状态也随之发生了变化。这里不做详细的总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;迭代器就是一种可以遍历一种集合中所有元素的机制，在Lua中，通常将迭代器表示为函数。每调用一次函数，就返回集合中的“下一个”元素。每个迭代器
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua热更新</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://bytemode.github.io/2018/12/12/lua热更新/</id>
    <published>2018-12-12T12:43:17.000Z</published>
    <updated>2018-12-12T13:22:02.159Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单纯热更新"><a href="#单纯热更新" class="headerlink" title="单纯热更新"></a>单纯热更新</h4><p>Lua热更新<br>最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重新加载：</p><pre><code>function reload_module(module_name)    package.loaded[modulename] = nil    require(modulename)end</code></pre><p>这样做虽然能完成热更，但问题是已经引用了该模块的地方不会得到更新， 因此我们需要将引用该模块的地方的值也做对应的更新。</p><pre><code>function reload_module(module_name)    local old_module = _G[module_name]    package.loaded[module_name] = nil    require (module_name)    local new_module = _G[module_name]    for k, v in pairs(new_module) do      old_module[k] = v    end    package.loaded[module_name] = old_moduleend</code></pre><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><blockquote><p>在生产环境上，总有可能出现不可预知的Bug，而通常修改好Bug仅仅又修改几句，停机维护的成本又太高，对于游戏来说，通常每个服就是单独的进程，也做不到像分布式环境下，关掉一部分机器，先升级一部分，再升级另一部分的无缝升级。这时候如果有热更就可以迅速的把Bug修复方案通过热更新进行修复，不会对用户任何的影响。例如：</p></blockquote><blockquote><ol><li>业务逻辑有Bug</li><li>配置的数据有误</li><li>需求发生变更</li></ol></blockquote><h3 id="热更新的原则"><a href="#热更新的原则" class="headerlink" title="热更新的原则"></a>热更新的原则</h3><p>1、热更新不破坏原有数据</p><blockquote><p>热更新更新的基本内容就是更新服务的逻辑，通常只是逻辑发生变化，但原有的值并不能被改变，例如：</p></blockquote><pre><code>local a = 1function get_a()    return aend</code></pre><p>此时，我们调用get_a()返回是的1，我们将热更成</p><pre><code>local a = 2function get_a()    print(&quot;get_a function&quot;)    return aend</code></pre><p>此时我们改变了a的初始值，但我们并不知道之前服务a的值是不是被重新赋过值，假设热更前a的值仍然为1，那么我们热更后调用get_a()返回的应该是1，而不应受新的初始值影响，而且同能打印出了”get_a function”，这时候则认为热更正常。</p><p>2、不为热更新写更多的代码</p><blockquote><p>热更新可以通过很多种方法实现，比如说模块为了支持数据不变的特性，需要在模块里额外写一些代码来记录旧值，热更新之后再把旧值copy过来，或者用一些特殊的语法来支撑。这种方法将会对项目增加很多的负担，而且一旦发生意料之外的Bug，热更系统几乎处于半瘫痪状态。应该来说，代码原本该怎么实现就怎么实现，对于99%的lua代码都是支持的，不需要修改来迎合热更新。通常热更新不改变原有变量值的类型。</p></blockquote><h3 id="热更新的实现，代码适用于5-2以上"><a href="#热更新的实现，代码适用于5-2以上" class="headerlink" title="热更新的实现，代码适用于5.2以上"></a>热更新的实现，代码适用于5.2以上</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>利用_ENV环境，在加载的时候把数据加载到_ENV下，然后再通过对比的方式修改_G底下的值，从而实现热更新，函数</p></blockquote><pre><code>function hotfix(chunk, check_name)</code></pre><p>定义env的table，并为env设置_G访问权限，然后调用load实现把数据重新加载进来</p><pre><code>local env = {}setmetatable(env, { __index = _G })local _ENV = envlocal f, err = load(chunk, check_name,  &#39;t&#39;, env)assert(f,err)local ok, err = pcall(f)assert(ok,err)</code></pre><p>此时env我们可以得到新函数有变更的部分，我们替换的为可见变量，也就是可直接访问的变量</p><pre><code>for name,value in pairs(env) do    local g_value = _G[name]    if type(g_value) ~= type(value) then        _G[name] = value    elseif type(value) == &#39;function&#39; then        update_func(value, g_value, name, &#39;G&#39;..&#39;  &#39;)        _G[name] = value    elseif type(value) == &#39;table&#39; then        update_table(value, g_value, name, &#39;G&#39;..&#39;  &#39;)    endend</code></pre><blockquote><p>通过env当前的值和_G当前的值进行对比</p></blockquote><blockquote><ol><li>如果类型不同我们直接覆盖原值，此时value不为nil，不会出现原则被覆盖成nil的情况</li><li>如果当前值为函数，我们进行函数的upvalue值比对</li></ol></blockquote><pre><code>function update_func(env_f, g_f, name, deep)    --取得原值所有的upvalue，保存起来    local old_upvalue_map = {}    for i = 1, math.huge do        local name, value = debug.getupvalue(g_f, i)        if not name then break end        old_upvalue_map[name] = value    end    --遍历所有新的upvalue，根据名字和原值对比，如果原值不存在则进行跳过，如果为其它值则进行遍历env类似的步骤    for i = 1, math.huge do        local name, value = debug.getupvalue(env_f, i)        if not name then break end        local old_value = old_upvalue_map[name]        if old_value then            if type(old_value) ~= type(value) then                debug.setupvalue(env_f, i, old_value)            elseif type(old_value) == &#39;function&#39; then                update_func(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)            elseif type(old_value) == &#39;table&#39; then                update_table(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)                debug.setupvalue(env_f, i, old_value)            else                debug.setupvalue(env_f, i, old_value)            end        end    endend</code></pre><blockquote><ol><li>如果当前值为table，我们遍历table值进行对比</li></ol></blockquote><pre><code>local protection = {    setmetatable = true,    pairs = true,    ipairs = true,    next = true,    require = true,    _ENV = true,}--防止重复的table替换，造成死循环local visited_sig = {}function update_table(env_t, g_t, name, deep)    --对某些关键函数不进行比对    if protection[env_t] or protection[g_t] then return end    --如果原值与当前值内存一致，值一样不进行对比    if env_t == g_t then return end    local signature = tostring(g_t)..tostring(env_t)    if visited_sig[signature] then return end    visited_sig[signature] = true    --遍历对比值，如进行遍历env类似的步骤    for name, value in pairs(env_t) do        local old_value = g_t[name]        if type(value) == type(old_value) then            if type(value) == &#39;function&#39; then                update_func(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)                g_t[name] = value            elseif type(value) == &#39;table&#39; then                update_table(value, old_value, name, deep..&#39;  &#39;..name..&#39;  &#39;)            end        else            g_t[name] = value        end    end    --遍历table的元表，进行对比    local old_meta = debug.getmetatable(g_t)    local new_meta = debug.getmetatable(env_t)    if type(old_meta) == &#39;table&#39; and type(new_meta) == &#39;table&#39; then        update_table(new_meta, old_meta, name..&#39;s Meta&#39;, deep..&#39;  &#39;..name..&#39;s Meta&#39;..&#39;  &#39; )    endend</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>1、可以调用hotfix_file对整个文件进行热更</p><pre><code>function hotfix_file(name)    local file_str    local fp = io.open(name)    if fp then        io.input(name)        file_str = io.read(&#39;*all&#39;)        io.close(fp)    end    if not file_str then        return -1    end    return hotfix(file_str, name)end</code></pre><p>2、可以通过hotfix进行代码的更新</p><pre><code>function hotfix(chunk, check_name)</code></pre><h4 id="关于坑"><a href="#关于坑" class="headerlink" title="关于坑"></a>关于坑</h4><blockquote><p>这里有一个注意事项，lua的module模块，如：</p></blockquote><pre><code>module(&quot;AA&quot;, package.seeall)</code></pre><p>当我们加载lua模块的时候，这时候这个模块信息并不像初始化全局代码一样，就算提前设置了package.loaded[“AA”] = nil, 也不会出现在env中同时也不会调用_G的__newindex函数，也就是说env[“AA”]为空，故这种写法无法进行热更新，所以通常模块的写法改成如下</p><pre><code>--定义模块AAAA = {}--相当于package.seeallsetmetatable(AA, {__index = _G})--环境隔离local _ENV = AA</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单纯热更新&quot;&gt;&lt;a href=&quot;#单纯热更新&quot; class=&quot;headerlink&quot; title=&quot;单纯热更新&quot;&gt;&lt;/a&gt;单纯热更新&lt;/h4&gt;&lt;p&gt;Lua热更新&lt;br&gt;最简单粗暴的热更新就是将package.loaded[modelname]的值置为nil，强制重
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua支持init64</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E6%94%AF%E6%8C%81init64/"/>
    <id>https://bytemode.github.io/2018/12/12/lua支持init64/</id>
    <published>2018-12-12T06:01:12.000Z</published>
    <updated>2018-12-12T06:34:19.956Z</updated>
    
    <content type="html"><![CDATA[<p>lua5.3提供了很多很好的特性例如string.pack unpack这样的好东西，同时还支持ini64.在lua之前的版本中number只有一种类型double.对于init64基本按照int来处理. 对于64位的解决方案有很多种,基本的思路都是使用8byte的string或者lightuserdata或者userdata修改元表来实现.</p><h4 id="luajit使用userdata重载元表运算符实现"><a href="#luajit使用userdata重载元表运算符实现" class="headerlink" title="luajit使用userdata重载元表运算符实现"></a>luajit使用userdata重载元表运算符实现</h4><p>在 luajit 中,是定义了一个 userdata 并重载其运算符完成的。用 <code>ffi.cast(&quot;int64_t&quot;,0)</code> 来构造一个 64bit 的 0 .userdata的做法存在额外开销问题，当 64bit 的 cdata 做 table 的 key 的时候，相同值的 int64 并不是同一个 key .</p><h4 id="lightuserdata-设置-metatable实现"><a href="#lightuserdata-设置-metatable实现" class="headerlink" title="lightuserdata 设置 metatable实现"></a>lightuserdata 设置 metatable实现</h4><p>用 lightuserdata 无损失的表示一个 int64 ,lightuserdata是一个轻量级的cdata,通过给 lightuserdata 设置 metatable ，我们可以重载它的数据运算。存在的问题:比较一个 int64 和普通的 lua number 是否相等时，lua 不能隐式的做转换。目前使用这个方案的实现的已经有了,github上有<a href="https://github.com/bytemode/lua-int64.git这个库是云风大神实现的" target="_blank" rel="noopener">https://github.com/bytemode/lua-int64.git这个库是云风大神实现的</a>.</p><p>这个库只提供了一个显式的 api ，即构造一个 int64 数字。可以从 lua number 构造，也支持从一个 8 字节宽的小头的字符串来构造。实际在内存储存的是一个 lightuserdata 即一个 64bit 指针（所以这个库不适用于 32 位平台）。你也可以通过 C 接口 <code>lua_pushlightuserdata</code> 来把一个 64bit 整数压入堆栈。把 int64 转换为普通的 lua number 借用了 # 操作符。</p><pre><code>#include &lt;lua.h&gt;#include &lt;lauxlib.h&gt;#include &lt;stdint.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;static int64_t_int64(lua_State *L, int index) {    int type = lua_type(L,index);    int64_t n = 0;    switch(type) {    case LUA_TNUMBER: {        lua_Number d = lua_tonumber(L,index);        n = (int64_t)d;        break;    }    case LUA_TSTRING: {        size_t len = 0;        const uint8_t * str = (const uint8_t *)lua_tolstring(L, index, &amp;len);        if (len&gt;8) {            return luaL_error(L, &quot;The string (length = %d) is not an int64 string&quot;, len);        }        int i = 0;        uint64_t n64 = 0;        for (i=0;i&lt;(int)len;i++) {            n64 |= (uint64_t)str[i] &lt;&lt; (i*8);        }        n = (int64_t)n64;        break;    }    case LUA_TLIGHTUSERDATA: {        void * p = lua_touserdata(L,index);        n = (intptr_t)p;        break;    }    default:        return luaL_error(L, &quot;argument %d error type %s&quot;, index, lua_typename(L,type));    }    return n;}static inline void_pushint64(lua_State *L, int64_t n) {    void * p = (void *)(intptr_t)n;    lua_pushlightuserdata(L,p);}static intint64_add(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    _pushint64(L, a+b);    return 1;}static intint64_sub(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    _pushint64(L, a-b);    return 1;}static intint64_mul(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    _pushint64(L, a * b);    return 1;}static intint64_div(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    if (b == 0) {        return luaL_error(L, &quot;div by zero&quot;);    }    _pushint64(L, a / b);    return 1;}static intint64_mod(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    if (b == 0) {        return luaL_error(L, &quot;mod by zero&quot;);    }    _pushint64(L, a % b);    return 1;}static int64_t_pow64(int64_t a, int64_t b) {    if (b == 1) {        return a;    }    int64_t a2 = a * a;    if (b % 2 == 1) {        return _pow64(a2, b/2) * a;    } else {        return _pow64(a2, b/2);    }}static intint64_pow(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    int64_t p;    if (b &gt; 0) {        p = _pow64(a,b);    } else if (b == 0) {        p = 1;    } else {        return luaL_error(L, &quot;pow by nagtive number %d&quot;,(int)b);    }     _pushint64(L, p);    return 1;}static intint64_unm(lua_State *L) {    int64_t a = _int64(L,1);    _pushint64(L, -a);    return 1;}static intint64_new(lua_State *L) {    int top = lua_gettop(L);    int64_t n;    switch(top) {        case 0 :             lua_pushlightuserdata(L,NULL);            break;        case 1 :            n = _int64(L,1);            _pushint64(L,n);            break;        default: {            int base = luaL_checkinteger(L,2);            if (base &lt; 2) {                luaL_error(L, &quot;base must be &gt;= 2&quot;);            }            const char * str = luaL_checkstring(L, 1);            n = strtoll(str, NULL, base);            _pushint64(L,n);            break;        }    }    return 1;}static intint64_eq(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    printf(&quot;%s %s\n&quot;,lua_typename(L,1),lua_typename(L,2));    printf(&quot;%ld %ld\n&quot;,a,b);    lua_pushboolean(L,a == b);    return 1;}static intint64_lt(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    lua_pushboolean(L,a &lt; b);    return 1;}static intint64_le(lua_State *L) {    int64_t a = _int64(L,1);    int64_t b = _int64(L,2);    lua_pushboolean(L,a &lt;= b);    return 1;}static intint64_len(lua_State *L) {    int64_t a = _int64(L,1);    lua_pushnumber(L,(lua_Number)a);    return 1;}static inttostring(lua_State *L) {    static char hex[16] = &quot;0123456789ABCDEF&quot;;    uintptr_t n = (uintptr_t)lua_touserdata(L,1);    if (lua_gettop(L) == 1) {        luaL_Buffer b;        luaL_buffinitsize(L , &amp;b , 28);        luaL_addstring(&amp;b, &quot;int64: 0x&quot;);        int i;        bool strip = true;        for (i=15;i&gt;=0;i--) {            int c = (n &gt;&gt; (i*4)) &amp; 0xf;            if (strip &amp;&amp; c ==0) {                continue;            }            strip = false;            luaL_addchar(&amp;b, hex[c]);        }        if (strip) {            luaL_addchar(&amp;b , &#39;0&#39;);        }        luaL_pushresult(&amp;b);    } else {        int base = luaL_checkinteger(L,2);        int shift , mask;        switch(base) {        case 0: {            unsigned char buffer[8];            int i;            for (i=0;i&lt;8;i++) {                buffer[i] = (n &gt;&gt; (i*8)) &amp; 0xff;            }            lua_pushlstring(L,(const char *)buffer, 8);            return 1;            }        case 10: {            int64_t dec = (int64_t)n;            luaL_Buffer b;            luaL_buffinitsize(L , &amp;b , 28);            if (dec&lt;0) {                luaL_addchar(&amp;b, &#39;-&#39;);                dec = -dec;            }            int buffer[32];            int i;            for (i=0;i&lt;32;i++) {                buffer[i] = dec%10;                dec /= 10;                if (dec == 0)                    break;            }            while (i&gt;=0) {                luaL_addchar(&amp;b, hex[buffer[i]]);                --i;            }            luaL_pushresult(&amp;b);            return 1;        }        case 2:            shift = 1;            mask = 1;            break;        case 8:            shift = 3;            mask = 7;            break;        case 16:            shift = 4;            mask = 0xf;            break;        default:            luaL_error(L, &quot;Unsupport base %d&quot;,base);            break;        }        int i;        char buffer[64];        for (i=0;i&lt;64;i+=shift) {            buffer[i/shift] = hex[(n&gt;&gt;(64-shift-i)) &amp; mask];        }        lua_pushlstring(L, buffer, 64 / shift);    }    return 1;}static voidmake_mt(lua_State *L) {    luaL_Reg lib[] = {        { &quot;__add&quot;, int64_add },        { &quot;__sub&quot;, int64_sub },        { &quot;__mul&quot;, int64_mul },        { &quot;__div&quot;, int64_div },        { &quot;__mod&quot;, int64_mod },        { &quot;__unm&quot;, int64_unm },        { &quot;__pow&quot;, int64_pow },        { &quot;__eq&quot;, int64_eq },        { &quot;__lt&quot;, int64_lt },        { &quot;__le&quot;, int64_le },        { &quot;__len&quot;, int64_len },        { &quot;__tostring&quot;, tostring },        { NULL, NULL },    };    luaL_newlib(L,lib);}intluaopen_int64(lua_State *L) {    if (sizeof(intptr_t)!=sizeof(int64_t)) {        return luaL_error(L, &quot;Only support 64bit architecture&quot;);    }    lua_pushlightuserdata(L,NULL);    make_mt(L);    lua_setmetatable(L,-2);    lua_pop(L,1);    lua_newtable(L);    lua_pushcfunction(L, int64_new);    lua_setfield(L, -2, &quot;new&quot;);    lua_pushcfunction(L, tostring);    lua_setfield(L, -2, &quot;tostring&quot;);    return 1;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lua5.3提供了很多很好的特性例如string.pack unpack这样的好东西，同时还支持ini64.在lua之前的版本中number只有一种类型double.对于init64基本按照int来处理. 对于64位的解决方案有很多种,基本的思路都是使用8byte的stri
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua类的实现</title>
    <link href="https://bytemode.github.io/2018/12/11/lua%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://bytemode.github.io/2018/12/11/lua类的实现/</id>
    <published>2018-12-11T10:10:12.000Z</published>
    <updated>2018-12-11T10:44:21.077Z</updated>
    
    <content type="html"><![CDATA[<p>子类在定义时复制所有基类的方法，在实例化时将该类作为metatable的__index赋值给实例。这就是cocos2dx里面的lua class的实现。</p><pre><code>function class(classname, super)​     local cls = {}​     if super then --复制基类方法​        cls = {}​        for k,v in pairs(super) do cls[k] = v end​        cls.super = super​    else​        cls = {ctor = function() end}​    end​    cls.__cname = classname​    cls.__index = cls​    function cls.new(...) --实例化​        local instance = setmetatable({}, cls)​        instance.class = cls​        instance:ctor(...)​        return instance​    end​    return clsend</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;子类在定义时复制所有基类的方法，在实例化时将该类作为metatable的__index赋值给实例。这就是cocos2dx里面的lua class的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function class(classname, super)
​     local 
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
</feed>
