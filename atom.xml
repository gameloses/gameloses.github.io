<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小工知识库</title>
  
  <subtitle>coding wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gameloses.github.io/"/>
  <updated>2018-12-05T12:25:15.853Z</updated>
  <id>https://gameloses.github.io/</id>
  
  <author>
    <name>stephen.sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lua表访问跟踪</title>
    <link href="https://gameloses.github.io/2018/12/05/lua%E8%A1%A8%E8%AE%BF%E9%97%AE%E8%B7%9F%E8%B8%AA/"/>
    <id>https://gameloses.github.io/2018/12/05/lua表访问跟踪/</id>
    <published>2018-12-05T12:21:39.000Z</published>
    <updated>2018-12-05T12:25:15.853Z</updated>
    
    <content type="html"><![CDATA[<p>当访问一个 table 或者更新 table 中的某个元素时，lua 首先会在 table 查找是否存在该元素，如果没有，就会查找 table 是否存在 <strong>index(访问) 或者 </strong>newindex(更新) 原方法。以访问为例，首先在 table 中查找某个字段，如果不存在，解释器会去查找 <strong>index 这个原方法，如果仍然没有，返回 nil。所以说，</strong>index 和 __newindex 是在 table 中没有所需访问的 index 时才发挥作用的。    </p><p>根据上面这种思路，如果我们想跟踪一个 table 的操作行为，那么<strong>需要一个空表</strong>，每次对这个空表操作的时候，就会使用 <strong>index 或者 </strong>newindex 这些元方法，在元方法中对原始 table 进行访问和操作，并打印跟踪信息。而之前创建的那个空表，就是代理。</p><pre><code>---------------------------------------------print &quot;跟踪单个表&quot;local _t = {}local mt = {    __newindex = function(t, name, value)        print(&quot;__newindex&quot;, name, value)        --rawset(_t, name, value) --原始访问 不访问原表        _t[name] = value    end,    __index = function(t, name)        print(&quot;__index&quot;, name, value)        --return rawget(_t, name) --原始访问 不访问原表        return _t[name]    end}--a.__index = alocal a = {}   setmetatable(a, mt)a.x = 1print(a.x)---------------------------------------------print &quot;跟踪多个表&quot;local index = {}    --  创建私有索引，即原表在代理表中特殊字段local mt = {    __index = function (t, k)        print(&quot;__index &quot; .. tostring(k))        return t[index][k]    end,    __newindex = function (t, k, v)        print(&quot;__newindex &quot; .. tostring(k) .. &quot; to &quot; .. tostring(v))        t[index][k] = v    end}function track (t)    local proxy = {}    proxy[index] = t    setmetatable(proxy, mt)    return proxyendlocal ori_table = {} --在其他地方创建的原表，对他进行跟踪local _o = track(ori_table)_o[2] = &quot;lua&quot;print(_o[2])</code></pre>]]></content>
    
    <summary type="html">
    
      lua表问跟踪器,使用一个代理器通过——index和newindex特性记录表的访问.跟踪lua表的赋值和取值table.key table.key = value会被跟踪.
    
    </summary>
    
      <category term="lua" scheme="https://gameloses.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://gameloses.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua高级特性</title>
    <link href="https://gameloses.github.io/2018/12/05/lua%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://gameloses.github.io/2018/12/05/lua高级特性/</id>
    <published>2018-12-05T11:52:56.000Z</published>
    <updated>2018-12-05T12:14:22.986Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原表"><a href="#原表" class="headerlink" title="原表"></a>原表</h4>]]></content>
    
    <summary type="html">
    
      涉及lua原表、尾递归、弱引用表、luastate、gc、源码解析、记录lua表访问赋值、lua面向对象等
    
    </summary>
    
      <category term="lua" scheme="https://gameloses.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://gameloses.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua和c交互原理</title>
    <link href="https://gameloses.github.io/2018/12/05/lua%E5%92%8Cc%E4%BA%A4%E4%BA%92/"/>
    <id>https://gameloses.github.io/2018/12/05/lua和c交互/</id>
    <published>2018-12-05T11:20:11.000Z</published>
    <updated>2018-12-05T11:52:34.908Z</updated>
    
    <content type="html"><![CDATA[<p>luastate</p>]]></content>
    
    <summary type="html">
    
      lua和c语言的交互,两者相互调用的原理.
    
    </summary>
    
      <category term="lua" scheme="https://gameloses.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://gameloses.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>git重点用法</title>
    <link href="https://gameloses.github.io/2018/12/05/git%E9%87%8D%E7%82%B9%E7%94%A8%E6%B3%95/"/>
    <id>https://gameloses.github.io/2018/12/05/git重点用法/</id>
    <published>2018-12-05T05:46:52.000Z</published>
    <updated>2018-12-05T12:12:59.103Z</updated>
    
    <content type="html"><![CDATA[<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><img src="/2018/12/05/git重点用法/gitflow.png" title="git flow"><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>放入暂存区<br><code>git add .</code><br><code>git add file</code></p></li><li><p>提交到仓库<br><code>git commit -m &#39;log&#39;</code></p></li><li><p>撤销工作区修改<br><code>git checkout -- file</code><br><code>git checkout .</code></p></li><li><p>暂存区回退到工作区<br><code>git reset HEAD file</code></p></li><li><p>Reset回退commit<br>回滚commit,工作区暂存区也改变<br><code>git reset --hard  commitid</code><br>只回滚commit,工作区暂存区代码没有改变<br><code>git reset --soft commitid</code><br>回滚commit,暂存区改变,工作区不变<br><code>git reset -mixed commitid</code> 等同 <code>git reset commitid</code></p></li><li><p>revert回退commit</p><p><code>git revert commit</code></p><p>但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在.</p><p>而reset是指将HEAD指针指到指定提交,历史记录中不会出现放弃的提交记录.</p></li><li><p>commit id查看<br><code>git log</code><br><code>git reflog</code></p></li><li><p>git push<br><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>推送本地master分支到远程origin主机的master分支，后者不存在就创建<br><code>git push origin master</code> 省略了远程分支名</p></li><li><p>git pull<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>远程主机origin的master分支拉取过来，与本地的brantest分支合并:<br><code>git pull origin master:brantest</code><br>将远程origin主机的master分支拉取过来和本地的当前分支进行合并<br><code>git pull origin master</code></p><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4></li><li>本地代码回滚到commitid<br><code>git reset --hard commitid</code></li><li>远程代码回回滚<br>方法1：<br>回滚后强制推送本地到远程<br><code>git reset --hard commitid</code><br><code>git push origin branch -f</code><br>方法2：<br>且分支在分支上reset然后删除远程分支，使用本地分支重新远程分支<pre><code>git checkout the_branchgit branch bkgit pullgit reset --hard th_commit_idgit push origin :the_branch 删除远程then_branchgit push origin the_branch</code></pre></li></ul><h4 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h4><ul><li><p>删除某次提交</p><p><code>git rebase -i commitid^</code></p><p>在命令编辑里边把某次提交之前的内容改为drop.退出交互模式,就会删除相应commit.之后强制推送就ok.</p></li><li><p>修改某次提交</p><p><code>git rebase -i commitid^</code></p><p>在编辑框中把需要修改的某次提交所在commit之前的pick改为edit然后保存退出.之后做出修改,完成之后执行如下命令：</p><pre><code>git add .git commit --amendgit rebase --continue</code></pre></li></ul><h4 id="子仓库"><a href="#子仓库" class="headerlink" title="子仓库"></a>子仓库</h4><p>主要用于工程中以来的第三方库，第三方库是独立的git仓库可以自行管理.</p><ul><li><p>添加submodule</p><p><code>git submodule add 仓库地址 localpath</code></p><p>会在.gitmodules和.git/config中添加submodule路径和对应的仓库库地址</p></li><li><p>clone父仓库之后更新子仓库</p><pre><code>git submodule initgit submodule update</code></pre></li><li><p>submodule修改后再localpath中 add commit push</p></li><li><p>删除submodule</p><p>删除.gitmodules和.git.config中的submodule信息;git rm –cached localpath.  </p><h4 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h4></li><li><p>git merge</p><p>$ git merge issueFix</p><p>如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:test.c</p><p>printf (“test1″);</p><p>=======</p><p>printf (“test2″);</p><p>>&gt;&gt;&gt;&gt;&gt;&gt; issueFix:test.c</p><p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在 issueFix 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><p>printf (“test2″);</p><p>这个解决方案各采纳了两个分支中的一部分内容，而且删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，和&gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决（resolved）。</p></li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><ul><li><p>创建分支</p><p><code>git branch bname</code></p></li><li><p>切换分支</p><p>git checkout bname</p></li><li><p>创建并切分支</p><p>git checkout -b bname</p></li><li><p>git checkout -b 本地分支名x origin/远程分支名x</p><p><code>git checkout -b dev origin/dev</code></p><p>远程分支dev切分支到本地dev分支</p></li><li><p>查看分支</p><p>git branch -av</p></li></ul>]]></content>
    
    <summary type="html">
    
      涉及git工作流程,实用方法.分支合并回滚子模块等.注重实践中常用的方法流程,同时对原理稍作注解.git的实践说明书.
    
    </summary>
    
      <category term="git" scheme="https://gameloses.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://gameloses.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx性能优化</title>
    <link href="https://gameloses.github.io/2018/12/03/cocos2dx%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://gameloses.github.io/2018/12/03/cocos2dx性能优化/</id>
    <published>2018-12-03T08:14:02.000Z</published>
    <updated>2018-12-03T08:33:50.766Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/03/cocos2dx性能优化/hexo_github.png" title="ceshi">]]></content>
    
    <summary type="html">
    
      cocos2dx性能优化,主要是针对帧率、内存、drawcall优化.
    
    </summary>
    
      <category term="cocos2dx" scheme="https://gameloses.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://gameloses.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>golang服务器开发</title>
    <link href="https://gameloses.github.io/2018/11/30/golang/"/>
    <id>https://gameloses.github.io/2018/11/30/golang/</id>
    <published>2018-11-30T07:55:25.000Z</published>
    <updated>2018-12-03T08:36:36.632Z</updated>
    
    <content type="html"><![CDATA[<h4 id="golang开发笔记"><a href="#golang开发笔记" class="headerlink" title="golang开发笔记"></a>golang开发笔记</h4><p>涉及内容包括web服务器、游戏服务器的开始使用,包括一些开元的golang软件的解读.</p><p>leaf goworld 等教程. 同时会有一些游戏demo展示.</p><blockquote><p>跳转链接：</p></blockquote><p><a href="https://gameloses.github.io/golang/">golang深度解析</a></p><p><a href="https://gameloses.github.io/golang/">leaf解析</a></p><p><a href="https://gameloses.github.io/golang/">goworld解析</a></p><p><a href="https://gameloses.github.io/golang/">https://gameloses.github.io/golang/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;golang开发笔记&quot;&gt;&lt;a href=&quot;#golang开发笔记&quot; class=&quot;headerlink&quot; title=&quot;golang开发笔记&quot;&gt;&lt;/a&gt;golang开发笔记&lt;/h4&gt;&lt;p&gt;涉及内容包括web服务器、游戏服务器的开始使用,包括一些开元的golang软
      
    
    </summary>
    
      <category term="golang" scheme="https://gameloses.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://gameloses.github.io/tags/golang/"/>
    
      <category term="go" scheme="https://gameloses.github.io/tags/go/"/>
    
      <category term="游戏服务器" scheme="https://gameloses.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="leaf" scheme="https://gameloses.github.io/tags/leaf/"/>
    
      <category term="goworld" scheme="https://gameloses.github.io/tags/goworld/"/>
    
  </entry>
  
  <entry>
    <title>gitbook使用</title>
    <link href="https://gameloses.github.io/2018/11/28/gitbook/"/>
    <id>https://gameloses.github.io/2018/11/28/gitbook/</id>
    <published>2018-11-28T10:23:58.000Z</published>
    <updated>2018-12-03T07:13:36.182Z</updated>
    
    <content type="html"><![CDATA[<p>Gitbook的搭建</p><p>gitbook是一个npm工具使用的是git和markdown技术支持构建多种格式的ebook.</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install gitbook-cligitbook -V</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>创建一个空目录,生成README.md SUMMARY.md两个文件,使用如下命令</p><p><code>gitbook init</code></p><ul><li>README.md —— 书籍的介绍写在这个文件里</li><li>SUMMARY.md —— 书籍的目录结构在这里配置</li></ul><h4 id="编辑电子书"><a href="#编辑电子书" class="headerlink" title="编辑电子书"></a>编辑电子书</h4><p>目录编辑</p><pre><code>* [第一章](section1/README.md)    * [第一节](section1/example1.md)    * [第二节](section1/example2.md)* [第二章](section2/README.md)    * [第一节](section2/example1.md)</code></pre><p>目录支持三级，目录中可以带链接.名录名+链接的方式.链接即相对md文件名字.</p><h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><p><code>gitbook serve</code></p><h4 id="发布电子书"><a href="#发布电子书" class="headerlink" title="发布电子书"></a>发布电子书</h4><p><code>gitbook build</code></p><p>在本地目录生成_book静态网页电子书</p><h4 id="生成电子书"><a href="#生成电子书" class="headerlink" title="生成电子书"></a>生成电子书</h4><p>安装插件calibre. <a href="https://link.jianshu.com/?t=https://calibre-ebook.com/download" target="_blank" rel="noopener">https://calibre-ebook.com/download</a></p><p>添加环境变量：</p><pre><code>cd ~vim .bash_profilePATH = /Applications/calibre.app/Contents/MacOS:${PATH}&quot;source .bash_profile</code></pre><p>生成电子书命令如下：</p><pre><code>gitbook pdfgitbook mobi</code></pre><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><p>利用gh-pages将gitbook生成的静态网页发布到github pages上.</p><ol><li><p>安装gh-pages <code>npm install g gh-pages</code> </p></li><li><p>在github上创建仓库例如cocos2dx</p></li><li><p>将书籍源码push到仓库的master分支</p></li><li><p>将_book发布到github仓库的gh-pages分支</p><pre><code>gitbook buildgh-pages -d _book</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gitbook的搭建&lt;/p&gt;
&lt;p&gt;gitbook是一个npm工具使用的是git和markdown技术支持构建多种格式的ebook.&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h4
      
    
    </summary>
    
      <category term="web" scheme="https://gameloses.github.io/categories/web/"/>
    
    
      <category term="Gitbook" scheme="https://gameloses.github.io/tags/Gitbook/"/>
    
  </entry>
  
  <entry>
    <title>github上搭建hexo博客</title>
    <link href="https://gameloses.github.io/2018/11/23/hexo%E6%90%AD%E5%BB%BAgithubblog/"/>
    <id>https://gameloses.github.io/2018/11/23/hexo搭建githubblog/</id>
    <published>2018-11-23T12:51:11.000Z</published>
    <updated>2018-12-03T08:31:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>打算在github上搭建起hexo博客和gitbook,主要记录一些技术积累.涉及游戏开前后端区块链等.解读一些开源的库.像skynet,pomelo,kbengine,coco2dx,cocos creator,ETH,goworld等.本文记录一下搭建hexo的过程纯属经验之谈.</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><img src="/2018/11/23/hexo搭建githubblog/hexo_github.png" title="基本流程"><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><ul><li><p>node.js</p><blockquote><p>mac下注意npm对user/local的权限问题</p></blockquote></li><li><p>git  </p><blockquote><p>保证使用ssh和github进行认证测试通过：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>.</p></blockquote></li><li><p>创建github仓库</p><blockquote><p>例如github用户名为gameloses则仓库名为:gameloses.github.io</p></blockquote></li></ul><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><pre><code>npm install -g hexo-clihexo init blogcd blognpm install</code></pre><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>在 _config.yml 中修改大部份的配置  </p><ul><li><p>配置部署参数</p><pre><code>deploy:  type: git  repository: git@github.com:gameloses/gameloses.github.io.git  branch: master</code></pre></li><li><p>安装部署插件      </p><pre><code>cd blognpm install hexo-deployer-git --save</code></pre></li><li><p>安装首页文章显示插件</p><p><code>npm install --save hexo-auto-excerpt</code></p><p>设置显示字数：</p><p>auto_excerpt:</p><p>  enable: true</p><p>  length: 300</p></li><li><p>手动添加文章描述</p><p><code>npm install --save hexo-front-matter-excerpt</code></p><p>在文章标题描述中添加：excerpt: xxxxxxxx 或者文章中添加 “<a id="more"></a>“</p></li><li><p>文章资源文件夹</p><pre><code>post_asset_folder: true{% asset_img example.jpg This is an example image %}</code></pre></li><li><p>发布上传博客<br><code>hexo d -g</code></p></li><li><p>常见的其他命令</p><pre><code>hexo s == hexo server   //启动本地服务hexo g == hexo generate //生成hexo d == hexo deploy   //发布hexo n == hexo new      //新建</code></pre></li></ul><h4 id="书写文章"><a href="#书写文章" class="headerlink" title="书写文章"></a>书写文章</h4><p><code>hexo new post &quot;文章名字&quot;</code><br>使用模板生成文章</p><pre><code>title: cocos2dx引擎架构概述comments: truedate: 2018-11-23 20:51:11tags:categories:</code></pre><h4 id="分类标签"><a href="#分类标签" class="headerlink" title="分类标签"></a>分类标签</h4><p>为了使分类标签生效需要生成两个page文件</p><pre><code>hexo new page categorieshexo new page tags</code></pre><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>一个模仿github样式的主题</p><pre><code>git clone git@github.com:sabrinaluo/hexo-theme-replica.git themes/replica</code></pre><p>Set theme: replica in _config.yml (the one in your root folder)     </p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>安装rss<br><code>npm install hero-generator-feed</code><br>配置如下：</p><pre><code>plugin:- hexo-generator-feedfeed:type: atompath: atom.xmllimit: 20rss: /atom.xml</code></pre><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>添加WWW和@主机记录，记录类型为CNAME.</p><p> 在source目录下创建CNAME文件，文件内容为域名例如：chuangyutime.com</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ol><li>mac下node安装好之后使用npm安装全局包会出现usr/local目录权限读写问题？<br><code>sudo chown -R $USER /usr/local</code><br>修改权限之后使用ls -l /usr/local 查看权限</li><li>分类标签404？<br>需要创建两个page categories、tags</li><li>vscode 编写markdown回退文本之后以后存在特殊的bs字符问题？<br>显示隐藏字符 <code>&quot;editor.renderControlCharacters&quot;: true</code><br>安装插件：<code>Remove backspace control character</code><br>开启设置：<code>&quot;editor.formatOnType&quot;: true 在被设定的情况下，进行变换时;输入时启动</code></li></ol>]]></content>
    
    <summary type="html">
    
      使用hexo搭建博客并且部署在github上,在过程中遇到很多问题,重要插件安装文章模板生成还有很坑的域名绑定问题.
    
    </summary>
    
      <category term="web" scheme="https://gameloses.github.io/categories/web/"/>
    
    
      <category term="hexo" scheme="https://gameloses.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
