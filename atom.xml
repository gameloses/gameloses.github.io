<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小工知识库</title>
  
  <subtitle>coding wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bytemode.github.io/"/>
  <updated>2018-12-27T09:59:58.566Z</updated>
  <id>https://bytemode.github.io/</id>
  
  <author>
    <name>sunfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opengl纹理</title>
    <link href="https://bytemode.github.io/2018/12/27/opengl%E7%BA%B9%E7%90%86/"/>
    <id>https://bytemode.github.io/2018/12/27/opengl纹理/</id>
    <published>2018-12-27T08:59:39.000Z</published>
    <updated>2018-12-27T09:59:58.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于纹理"><a href="#关于纹理" class="headerlink" title="关于纹理"></a>关于纹理</h4><p>可以为每个顶点添加颜色来增加图形的细节，从而创建出丰富的图像。想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销.纹理是一个2D图片，它可以用来添加物体的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p><p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><p><img src="https://learnopengl-cn.github.io/img/01/06/tex_coords.png" alt="img"></p><p>我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值</p><p>纹理坐标看起来就像这样：</p><pre><code>float texCoords[] = {    0.0f, 0.0f, // 左下角    1.0f, 0.0f, // 右下角    0.5f, 1.0f // 上中};</code></pre><h4 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h4><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像，其他的环绕方式</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p>纹理选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（<code>s</code>、<code>t</code>、<code>r</code>）它们和<code>x</code>、<code>y</code>、<code>z</code>是等价的）：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</code></pre><p>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是<code>WRAP</code>选项，并且指定<code>S</code>和<code>T</code>轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</p><p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的<code>fv</code>后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><pre><code>float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</code></pre><h4 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h4><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p><p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/filter_nearest.png" alt="img"></p><p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/filter_linear.png" alt="img"></p><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/texture_filtering.png" alt="img"></p><p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><h4 id="多级纹理"><a href="#多级纹理" class="headerlink" title="多级纹理"></a>多级纹理</h4><p>再提个大场景中，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，对它们使用高分辨率纹理浪费内存。</p><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="img"></p><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p><p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p><table><thead><tr><th>过滤方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_NEAREST_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td>GL_LINEAR_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td>GL_NEAREST_MIPMAP_LINEAR</td><td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td>GL_LINEAR_MIPMAP_LINEAR</td><td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p><pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code></pre><p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h2 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>创建纹理对象，使用id类记录对象</p><pre><code>unsigned int texture;glGenTextures(1, &amp;texture);</code></pre><p>glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的<code>unsigned int</code>数组中（我们的例子中只是单独的一个<code>unsigned int</code>），</p><p>绑定对象，让之后任何的纹理指令都可以配置当前绑定的纹理：</p><pre><code>glBindTexture(GL_TEXTURE_2D, texture);</code></pre><p>使用图片数据生成一个纹理了：</p><pre><code>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);glGenerateMipmap(GL_TEXTURE_2D);</code></pre><p>函数很长，参数也不少，所以我们一个一个地讲解：</p><ul><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有<code>RGB</code>值，因此我们也把纹理储存为<code>RGB</code>值。</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为<code>0</code>（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为<code>char</code>(byte)数组，我们将会传入对应值。</li><li>最后一个参数是真正的图像数据。</li></ul><p>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</p><p>生成一个纹理的过程应该看起来像这样：</p><pre><code>unsigned int texture;//生成并且绑定纹理对象glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);//为当前绑定的纹理对象设置环绕方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//多级纹理过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data){    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);    glGenerateMipmap(GL_TEXTURE_2D);}else{    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}</code></pre><h4 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h4><p>使用glDrawElements绘制,我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p><pre><code>float vertices[] = {//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // 右上     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // 右下    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // 左下    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // 左上};</code></pre><p>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/vertex_attribute_pointer_interleaved_textures.png" alt="img"></p><pre><code>glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2);</code></pre><p>注意，我们同样需要调整前面两个顶点属性的步长参数为<code>8 * sizeof(float)</code>。</p><p>接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p><pre><code>#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main(){    gl_Position = vec4(aPos, 1.0);    ourColor = aColor;    TexCoord = aTexCoord;}</code></pre><p>片段着色器应该接下来会把输出变量<code>TexCoord</code>作为输入变量。</p><p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如<code>sampler1D</code>、<code>sampler3D</code>，或在我们的例子中的<code>sampler2D</code>。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><pre><code>#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D ourTexture;void main(){    FragColor = texture(ourTexture, TexCoord);}</code></pre><p>我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色</p><p>现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p><pre><code>//glBindTexture中textture是纹理对象的idglBindTexture(GL_TEXTURE_2D, texture);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>完成之后你会看到下面的图像：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/textures2.png" alt="img"></p><p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色：</p><pre><code>FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);</code></pre><p>最终的效果应该是顶点颜色和纹理颜色的混合色：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/textures_funky.png" alt="img"></p><p>我猜你会说我们的箱子喜欢跳70年代的迪斯科。</p><h4 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h4><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p><p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p><pre><code>glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元glBindTexture(GL_TEXTURE_2D, texture);</code></pre><p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用<code>glBindTexture</code>的时候，无需激活任何纹理单元。</p><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p><p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p><pre><code>#version 330 core...uniform sampler2D texture1;uniform sampler2D texture2;void main(){    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);}</code></pre><p>最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是<code>0.0</code>，它会返回第一个输入；如果是<code>1.0</code>，会返回第二个输入值。<code>0.2</code>会返回<code>80%</code>的第一个输入颜色和<code>20%</code>的第二个输入颜色，即返回两个纹理的混合色。</p><p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。</p><p>为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，<strong>先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元</strong>：</p><pre><code>glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>我们还要通过使用<strong>glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元</strong>。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><pre><code>ourShader.use(); // 别忘记在激活着色器前先设置uniform！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置while(...) {    [...]}</code></pre><p>通过使用glUniform1i设置采样器，我们保证了每个uniform采样器对应着正确的纹理单元。你应该能得到下面的结果：</p><p><img src="https://learnopengl-cn.github.io/img/01/06/textures_combined.png" alt="img"></p><p>你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴<code>0.0</code>坐标是在图片的底部的，但是图片的y轴<code>0.0</code>坐标通常在顶部。在图像加载时帮助我们翻转y轴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于纹理&quot;&gt;&lt;a href=&quot;#关于纹理&quot; class=&quot;headerlink&quot; title=&quot;关于纹理&quot;&gt;&lt;/a&gt;关于纹理&lt;/h4&gt;&lt;p&gt;可以为每个顶点添加颜色来增加图形的细节，从而创建出丰富的图像。想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多
      
    
    </summary>
    
      <category term="opengl" scheme="https://bytemode.github.io/categories/opengl/"/>
    
    
      <category term="opengl" scheme="https://bytemode.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx批处理渲染</title>
    <link href="https://bytemode.github.io/2018/12/27/cocos2dx%E6%89%B9%E5%A4%84%E7%90%86%E6%B8%B2%E6%9F%93/"/>
    <id>https://bytemode.github.io/2018/12/27/cocos2dx批处理渲染/</id>
    <published>2018-12-27T08:32:40.000Z</published>
    <updated>2018-12-27T10:00:34.643Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>opengl基础</title>
    <link href="https://bytemode.github.io/2018/12/27/opengl%E5%9F%BA%E7%A1%80/"/>
    <id>https://bytemode.github.io/2018/12/27/opengl基础/</id>
    <published>2018-12-27T08:13:48.000Z</published>
    <updated>2018-12-27T08:38:33.225Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="opengl" scheme="https://bytemode.github.io/categories/opengl/"/>
    
    
      <category term="opengl" scheme="https://bytemode.github.io/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>cocos2dx渲染架构</title>
    <link href="https://bytemode.github.io/2018/12/17/cocos2dx%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://bytemode.github.io/2018/12/17/cocos2dx渲染架构/</id>
    <published>2018-12-17T12:13:14.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<p>2dx的时代UI树便利和渲染是没有分开的，遍历UI树的时候就渲染.3dx版本为了分离了ui树的遍历和渲染，先遍历生成渲染命令发到渲染队列，之后遍历渲染命令队列开始渲染.这样做的好处是渲染命令可以重用，单独的渲染可以做优化例如自动批绘制.本篇首先介绍cocos2D-X 3.x版本的渲染结构，之后会深入opengl es.</p><h4 id="mainLoop"><a href="#mainLoop" class="headerlink" title="mainLoop"></a>mainLoop</h4><pre><code>void DisplayLinkDirector::mainLoop(){    if (_purgeDirectorInNextLoop)    {        //只有一种情况会调用到这里来，就是导演类调用end函数        _purgeDirectorInNextLoop = false;        //清除导演类        purgeDirector();    }    else if (! _invalid)    {        //绘制        drawScene();        //清除内存        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();    }}</code></pre><p>分析的起点是mainLoop函数，这是在主线程里面会调用的循环，其中drawScene函数进行绘制。那么就进一步来看drawScene函数。mainLoop实在opengl的ondrawframe调用过来的即平台每帧渲染会调用.</p><h4 id="drawScene"><a href="#drawScene" class="headerlink" title="drawScene"></a>drawScene</h4><pre><code>void Director::drawScene(){    //计算间隔时间    calculateDeltaTime();    //如果间隔时间过小会被忽略    if(_deltaTime &lt; FLT_EPSILON){ return;}    //空函数，也许之后会有作用    if (_openGLView)    {        _openGLView-&gt;pollInputEvents();    }    //非暂停状态    if (! _paused)    {        //scheduler更新 会使actionmanager更新和相关的schedule更新 引擎物理模拟都是在绘制之前做的        _scheduler-&gt;update(_deltaTime);        _eventDispatcher-&gt;dispatchEvent(_eventAfterUpdate);    }    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    //切换下一场景，必须放在逻辑后绘制前，否则会出bug    if (_nextScene)    {        setNextScene();    }    kmGLPushMatrix();    //创建单位矩阵    kmMat4 identity;    kmMat4Identity(&amp;identity);    //绘制场景    if (_runningScene)    {        //递归的遍历scene中的每个node的visit生成渲染命令放入渲染队列        _runningScene-&gt;visit(_renderer, identity, false);        _eventDispatcher-&gt;dispatchEvent(_eventAfterVisit);    }    //绘制观察节点，如果你需要在场景中设立观察节点，请调用摄像机的setNotificationNode函数     if (_notificationNode)    {        _notificationNode-&gt;visit(_renderer, identity, false);//这是一个常驻节点    }    //绘制屏幕左下角的状态    if (_displayStats)    {        showStats();    }    //渲染    _renderer-&gt;render();    //渲染后    _eventDispatcher-&gt;dispatchEvent(_eventAfterDraw);    kmGLPopMatrix();    _totalFrames++;    if (_openGLView)    {        _openGLView-&gt;swapBuffers(); //交换缓冲区    }    //计算绘制时间    if (_displayStats)    {        calculateMPF();    }}</code></pre><p>其中和绘制相关的是visit的调用和render的调用，其中visit函数会调用节点的draw函数，在3.x之前的版本中draw函数就会直接调用绘制代码，3.x版本是在draw函数中生成将绘制命令放入到renderer队列中，然后renderer函数去进行真正的绘制，首先来看sprite的draw函数.</p><h4 id="渲染命令"><a href="#渲染命令" class="headerlink" title="渲染命令"></a>渲染命令</h4><pre><code>void Sprite::draw(Renderer *renderer, const kmMat4 &amp;transform, bool transformUpdated){    //检查是否超出边界，自动裁剪    _insideBounds = transformUpdated ? renderer-&gt;checkVisibility(transform, _contentSize) : _insideBounds;    if(_insideBounds)    {        //初始化        _quadCommand.init(_globalZOrder, _texture-&gt;getName(), _shaderProgram, _blendFunc, &amp;_quad, 1, transform);        renderer-&gt;addCommand(&amp;_quadCommand);        //物理引擎相关绘制边界if CC_SPRITE_DEBUG_DRAW        _customDebugDrawCommand.init(_globalZOrder);        //自定义函数        _customDebugDrawCommand.func = CC_CALLBACK_0(Sprite::drawDebugData, this);        renderer-&gt;addCommand(&amp;_customDebugDrawCommand);endif    }}</code></pre><p>这里面用了两种不同的绘制命令quadCommand初始化后就可以加入到绘制命令中，customDebugDrawCommand传入了一个回调函数，具体的命令种类会在后面介绍。其中自定义的customDebugDrawCommand命令在初始化的时候只传入了全局z轴坐标，因为它的绘制函数全部都在传入的回调函数里面，_quadCommand则需要传入<strong>全局z轴坐标，贴图名称，shader，混合，坐标点集合，坐标点集个数，变换</strong>。</p><h4 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h4><pre><code>void Renderer::render(){    _isRendering = true;    if (_glViewAssigned)    {        //清除        _drawnBatches = _drawnVertices = 0;        //排序        for (auto &amp;renderqueue : _renderGroups)        {            renderqueue.sort();        }        //绘制        visitRenderQueue(_renderGroups[0]);        flush();    }    clean();    _isRendering = false;}</code></pre><p>Render类中的render函数进行真正的绘制，<strong>首先排序，再进行绘制</strong>，从列表中的第一个组开始绘制。在visitRenderQueue函数中可以看到五种不同类型的绘制命令类型，分别对应五个类，这五个类都继承自RenderCommand。</p><h5 id="绘制命令"><a href="#绘制命令" class="headerlink" title="绘制命令"></a>绘制命令</h5><ol><li><p>QUAD_COMMAND：</p><p>QuadCommand类绘制精灵等。所有绘制图片的命令都会调用到这里，处理这个类型命令的代码就是绘制贴图的openGL代码，</p></li><li><p>CUSTOM_COMMAND：</p><p>自定义绘制，自己定义绘制函数，在调用绘制时只需调用已经传进来的回调函数就可以，裁剪节点，绘制图形节点都采用这个绘制，把绘制函数定义在自己的类里。这种类型的绘制命令不会在处理命令的时候调用任何一句openGL代码，而是调用你写好并设置给func的绘制函数，并自己实现一个自定义的绘制。</p></li><li><p>BATCH_COMMAND：</p><p>批处理绘制，批处理精灵和粒子,其实它类似于自定义绘制，也不会再render函数中出现任何一句openGL函数，它调用一个固定的函数。</p></li><li><p>GROUP_COMMAND：</p><p>绘制组，一个节点包括两个以上绘制命令的时候，把这个绘制命令存储到另外一个renderGroups中的元素中，并把这个元素的指针作为一个节点存储到renderGroups[0]中。</p></li></ol><h5 id="render流程"><a href="#render流程" class="headerlink" title="render流程"></a>render流程</h5><pre><code>void Renderer::addCommand(RenderCommand* command){    //获得栈顶的索引    int renderQueue =_commandGroupStack.top();    //调用真正的addCommand    addCommand(command, renderQueue);}void Renderer::addCommand(RenderCommand* command, int renderQueue){    //将命令加入到数组中    _renderGroups[renderQueue].push_back(command);}</code></pre><p>addCommand它是获得需要把命令加入到renderGroups位置中的索引，这个索引是从commandGroupStack获得的，commandGroupStack是个栈，当我们创建一个GROUP_COMMAND时，需要调用pushGroup函数，它是把当前这个命令在_renderGroups的索引位置压到栈顶，当addCommand时，调用top，获得这个位置</p><pre><code>groupCommand.init(globalZOrder);renderer-&gt;addCommand(&amp;_groupCommand);renderer-&gt;pushGroup(_groupCommand.getRenderQueueID());</code></pre><p>GROUP_COMMAND一般用于绘制的节点有一个以上的绘制命 令，把这些命令组织在一起，无需排定它们之间的顺序，他们作为一个整体被调用，所以一定要记住，栈是push，pop对应的，关于这个节点的所有的绘制命令被添加完成后，请调用pop，将这个值从栈顶弹出，否则后面的命令也会被添加到这里。</p><p> 为什么调用的起始只需调用为什么只是0，其他的呢？</p><p><code>visitRenderQueue(_renderGroups[0]);</code></p><p>它们会在处理GROUP_COMMAND被调用</p><pre><code>else if(RenderCommand::Type::GROUP_COMMAND == commandType) {    flush();    int renderQueueID = ((GroupCommand*) command)-&gt;getRenderQueueID();    visitRenderQueue(_renderGroups[renderQueueID]);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2dx的时代UI树便利和渲染是没有分开的，遍历UI树的时候就渲染.3dx版本为了分离了ui树的遍历和渲染，先遍历生成渲染命令发到渲染队列，之后遍历渲染命令队列开始渲染.这样做的好处是渲染命令可以重用，单独的渲染可以做优化例如自动批绘制.本篇首先介绍cocos2D-X 3.x
      
    
    </summary>
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/categories/cocos2dx/"/>
    
    
      <category term="cocos2dx" scheme="https://bytemode.github.io/tags/cocos2dx/"/>
    
  </entry>
  
  <entry>
    <title>tolua原理</title>
    <link href="https://bytemode.github.io/2018/12/17/tolua%E5%8E%9F%E7%90%86/"/>
    <id>https://bytemode.github.io/2018/12/17/tolua原理/</id>
    <published>2018-12-17T03:03:17.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？"><a href="#tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？" class="headerlink" title="tolua++如何将c++对象导入到lua里？lua如何能够访问c++对象成员？"></a>tolua++如何将c++对象导入到lua里？lua如何能够访问c++对象成员？</h4><p>创建一个 userdata ，存放 C/C++ 对象指针，然后给 userdata 添加元表，用<strong>index</strong> 和<strong>newindex</strong> 元方法映射 C/C++ 中的对象方法。</p><ol><li>c++层新建一个元表作为类型（通过tolua_usertype）放在注册表中（_R[mt] = name），并且设置这些类型的继承关系(通过_R.tolua_super).</li><li>创建一个类表(newtable)，并且设置_R中的原型表为元表（通过tolua_usertype），这个类表是放在全局表中的.</li><li>在注册类型的时候metatable里新建了.get和.set表。</li></ol><p>​      成员变量：在.set和.get表里存储以变量名为键一读取设置c函数为值的键值对。</p><p>​      变量的读取赋值会在在metatable的<strong>index和</strong>newindex里，以变量名为键，从.get和.set表里取得读取设置函数并调用。</p><p>​      成员函数：只需要以函数名为键，函数为值存储在metatable里。</p><ol start="3"><li>因为c++类型已经在注册表里，所以可以直接访问。</li></ol><p>​     lua里调用c++创建一个对象之后，c++需要返回这个对象：</p><p>​     新建userdata,将c++指针放入userdata;以对象地址为key，userdata为值放入tolua_ubox表里；设置此类型对象的元表为userdata的元表。</p><p>   经过上面4个步骤，就可以在lua里面调用类表。</p><p>传入c++对象的tolua++函数是tolua_pushusertype。一般情况下，第一次使用这个函数将一个c++对象push到lua堆栈上时，才会新建userdata。tolua++会以c++对象地址为键，userdata为值，将键值对存储在tolua_ubox表里。下次推入同样的c++对象时，从这个表里取出userdata推入堆栈即可。</p><h4 id="tolua-如何处理类型的继承"><a href="#tolua-如何处理类型的继承" class="headerlink" title="tolua++如何处理类型的继承"></a>tolua++如何处理类型的继承</h4><p>父类的metatable,是子类metatable的metatable。这样调用父类方法时，就会去父类的metatable里查找了。</p><p>tolua++还维护了一个tolua_super表，这个表以c++类型的metatable为键，以一个表格为值。这个值表格以类型名称为键，以true为值，记录了metatable对应c++类型的父类有哪些。这个表格可以用来帮助判断对象是否是某一个类型。</p><h4 id="tolua-如何管理对象的生命周期"><a href="#tolua-如何管理对象的生命周期" class="headerlink" title="tolua++如何管理对象的生命周期"></a>tolua++如何管理对象的生命周期</h4><p>一般情况下，当lua里对c++对象的引用变量可以被垃圾回收时，tolua++只是简单的释放userdata占用的4字节指针地址内存。但是也可以通过绑定或者代码指定的方式，让tolua++真正释放对象所占内存。</p><p>绑定的方式，是指在将c++类型构造函数使用tolua++导出到lua里时，tolua++会自动生成new_local方法。如果在lua代码里，用这个方法新建对象时，tolua++会调用tolua_register_gc方法，指明回收对象时回收对象内存。</p><p>在c++代码里，使用tolua_pushusertype_and_takeownership；在lua代码里，使用tolua.takeownership，都可以达到同样的目的。</p><p>对于这些指定由tolua++回收内存的对象，如果其类型的析构函数也通过tolua++导出了，则在回收内存时，会通过delete运算符，调用对象的析构函数。否则只会使用free方法回收。</p><p>tolua_register_gc方法，做的事情，是以对象指针为键，以对象metatable为值，将键值对存储在tolua_gc表里。在对象类型的metatable表的__gc方法里，tolua++会检查tolua_gc表是否包含以这个地址为键的表项。包含的话才会进行上述的内存回收工作。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>有的时候，在lua里取得一个c++对象后，我们想赋给它一些只在lua环境下有意义的属性。或者，我们想在lua里扩展一个c++类。tolua++也提供了实现这种需求的机制。</p><p>tolua++在LUA_REGISTRY里维护了一张tolua_peers表。这张表以表示c++对象的userdata为键，以一张表格t为值。t里面就记录了这个对象在lua里扩展的属性。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>C++在进行函数调用的时候是this指针+函数地址, Lua提供用户自定义的userdata.</p><p> 一般lua中持有c++对象是使用userdata来实现的(userdata 类型用来将任意 C 数据保存在 Lua 变量中. 这个类型相当于一块原生的内存, 除了赋值和相同性判断, Lua 没有为之预定义任何操作.通过使用 metatable （元表）, 可以为 userdata 自定义一组操作. metatable 中还可以定义一个函数gc让 userdata 作垃圾收集时调用它。</p><p>​     因此，metatable可以用来模拟C++里面的函数，通过替换它来实现函数，类成员的查找。Userdata可以很方便的获取到转换成C++里面this指针。通过this指针+类的函数地址即可调用C++里面的类成员函数。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>tolua_open()创建很多用于管理的内部变量， 如记录所有基类；</p><p>tolua_usertype() 创建两个表分别问type和 const type类型， const type 继承自 type;</p><p>tolua_cclass()注册类设置元表建立父子类关系；</p><p>tolua_beginmodule（）注册一个模块</p><p>tolua_function()函数绑定到lua表中</p><p>tolua_beginmodule（）结束模块注册。</p><h5 id="tolua-open是入口点，它创建很多用于管理的内部变量，以下用-G指代全局表，-R指定registry-table："><a href="#tolua-open是入口点，它创建很多用于管理的内部变量，以下用-G指代全局表，-R指定registry-table：" class="headerlink" title="tolua_open是入口点，它创建很多用于管理的内部变量，以下用_G指代全局表，_R指定registry table："></a>tolua_open是入口点，它创建很多用于管理的内部变量，以下用_G指代全局表，_R指定registry table：</h5><p>1、_R.TOLUA_VALUE_ROOT={}， 这个表是cocos2dx自己加的，它把所有传入lua的cppobj/userdata都塞到这个表里，而且这还不是一个弱表，也就意味着cocos2dx创建的cpp obj，永远都不会被gc！只有在c++层面被delete时，才会去这个表里删除自己。因此，每一个cocos2dx cpp obj，是不可能依赖lua gc来释放的，必须纯手动管理（retain/release）。当然，根据cocos2dx自身的设计，每个obj在new出来refcount为1，并且会添加autorelease pool里去，因此只要它不在场景树上，下一帧就会被自动删除掉。通常情况下，lua代码是不会干涉其生命期的。但是有些时候我们会把某些节点从场景树上摘下，过一段时间又挂上去，这时就必须先调一下它的retain，如果之后忘记调release，那么它就永远不会销毁了。</p><p>2、_R.tolua_peers={}，这是个弱表，用来缓存所有cppobj的ptr-&gt;peer table，所谓peer table，就是给每个cpp obj userdata关联的一个lua table，用来提供lua层面的额外的kv存储。tolua++把每个userdata的peer table设成该userdata的env，目的当然是为了方便找到它。因为在lua实现里，userdata的env是没有内定用途的，于是tolua++就拿来存peer table了。</p><p>3、_R.tolua_ubox={}，也是个弱表，用来缓存所有cppobj的ptr-&gt;userdata映射，userdata里面存放的值其实就是ptr。这个表的用途是记录所有已经push到lua里的cppobj，每个cppobj第一次进入lua时，会去做创建userdata、关联metatable、设置peertable(env)等等一大堆操作，然后把ptr-&gt;userdata的映射关系记到这个表里，下次再被返回进lua时，就从这表里去查找，查到的话就直接拿已创建好的userdata用了。但是有一种特殊情况，就是第二次push时的类型是上一次的子类，也就是一个“特化类型”，那么需要改设metatable，以使子类的新函数能被访问到。</p><p>4、_R.tolua_super={}，用来记录每个类型的所有基类，key是子类的mt，value则是个map，其中每个kv都是一个pair&lt;基类名,1&gt;。通过这个表可以快速知道两个类之间有无继承关系。</p><p>5、_R.tolua_gc={}</p><p>6、_R.tolua_gc_event = closure{ func:class_gc_event, upvalue:上述两个表格 }， 这是挂在每个类对应的metatable上的__gc方法。</p><p>7、_G.tolua={}，里面存放tolua自己的一些工具函数</p><h5 id="类的注册。"><a href="#类的注册。" class="headerlink" title="类的注册。"></a>类的注册。</h5><p>1、对每个用户类，首先要用tolua_usertype声明这是个用户类型：</p><p>​     tolua_usertype(tolua_S, “<a href="http://www.java123.net/web/" target="_blank" rel="noopener">Web</a>Socket”)</p><p>它里面的做事情很简单，就是分别为type和const type“两个类”建表（这个表也就是其实例userdata的元表），然后设置type继承const type，从数据的角度来看也就是：</p><p>//先用tolua_newmetatable分别创建创建两个元表，其内又调用tolua_classevents挂上各种属性</p><p>_R[“WebSocket”]={</p><p>  __index = cfunc:class_index_event,</p><p>  __newindex = cfunc:class_newindex_event,</p><p>  __gc=_R.tolua_gc_event //上面之&lt;一.6&gt;</p><p>  //其它各种add/sub/lt/eq等方法……</p><p>}</p><p>_R[“const WebSocket”]= ……同上</p><p>//mapsuper(L,type,ctype) 设置两者的继承关系</p><p>_R.tolua_super[_R[“WebSocket”]] ={ “const WebSocket” = 1,} //上面之&lt;一.4&gt;</p><p>//这个过程会递归执行，即把基类的所有基类都添到子类里</p><p>for k,v in pairs(_R.tolua_super[_R[“const WebSocket”]]) do</p><p>_R.tolua_super[_R[“WebSocket”]][k] = v</p><p>end</p><p> //在这一步里，mapsuper只是设置type-&gt;const type，但是在后续步骤里会添加大量type-&gt;base type，因此递归下来，每个type的_R.tolua_super[type]表还是有很多内容的。</p><p>2、然后用tolua_cclass来注册类。</p><p>​    tolua_cclass主要做两件事，一是把基类和父类（以及各const变种）之间的关系建立起来，二是注册类的析构函数（构造函数由普通的create静态函数替代了）。</p><p>关于继承关系，总共四对：</p><p>mapinheritance(L,name,base);</p><p>mapinheritance(L,cname,name);</p><p>mapsuper(L,cname,cbase);</p><p>mapsuper(L,name,base);</p><p>其中c指const。除了上面提到的mapsuper，又来了个mapinheritance， 再次对比说明下：</p><p>mapsuper是：在_R.tolua_super记录每个类(k)有哪些父类(v)，所有父类以v[类名]=1的形式记录着。</p><p>mapinheritance是：把父类元表表设成子类元表表的元表，同时给基类表上挂一个用以记录该类objptr-&gt;userdata映射的弱表，大致是：</p><p>setmetatable( _R.type, _R.base_type )，</p><p>_R.type.tolua_ubox = _R.base_type.tolua_ubox or weak({})</p><p>其中第二句与前述之&lt;一.3&gt;有点相似，只是那是放在_R上的一个总表，而这里是为每个类单独建表，但子类与基类是共用的，也就是每次调用tolua_cclass注册一个类，就有“3个类”的表中的tolua_ubox字段指向了同一个表，这3个类从上到下是：base type -&gt; type -&gt; const type，至于const base type，那是在之前注册基类时处理的了。</p><p>不过这里还有个另外的问题！注意和第2条里的对比：</p><p>mapinheritance(L,cname,name) //tolua_cclass里</p><p>mapsuper(L,type,ctype) //tolua_usertype里</p><p>到底type和const type谁是“基类”呢？这主要看不同场合里“基类”这个概念是用于解决什么问题了：</p><p>对mapsuper而言：在c++里一个声明为const的参数，实际是对函数本身的约束而不是对实参的约束：它只是强调函数内部不会去修改这个参数，至于传进来的实参本身是不是const的根本不重要，因为反正函数已经承诺不会去修改它了。所以要把一个类型为type的obj传给某个带有const type参数的函数，是没有问题的，但反过来，一个const type对象要传给接受type参数的函数是不行的，因为不知道它到底会不会修改（没有承诺不修改就意味着会修改）。再加上tolua++在生成胶水代码时，对每个参数都要做类型匹配检测（也就是在生成代码中大量的lua_isusertype调用），一个usertype变量是否合格，就是检查它所在位置的参数类型，是否是它可以“扮演”的角色，这些角色一是它的所有父类，二就是它以及所有父类的const变种了，而这些可以扮演的类型，恰好就是mapsuper所建立的_R.tolua_super体系中记录的内容了。</p><p>对mapinheritance而言：它将基类表设成子类表的元表，这是为了在子类表里可以找到基类的函数（在class_index_event函数里，有一个while循环，通过这里建立的链条不断向上级查找）。就这个目的而言，type和const type谁做基类是一样的。但是，type还有真正的基类base，按照base-&gt;type-&gt;const type的继承顺序是恰好满足的：</p><p>classA -&gt; const classA</p><p>​          -&gt; classB -&gt; const classB</p><p>​                         -&gt; classC -&gt; const classC</p><p>​                                       -&gt; classD -&gt; const classD</p><p>也就是说const类型在当前层次的链上是一个叶，下一层次不是从它继承，而是与它并级。</p><p>而如果按照base-&gt;const type-&gt;type-&gt;const subtype-&gt;sub type，那么问题就麻烦了，因为在注册函数时，所有函数都是挂在不带const的类表上的，如CCNode的函数都在_R[“CCNode”]里，这也符合脚本里创建类实例时的习惯：直接以“纯粹的”（不带const的）类名来操作，比如CCNode:create，而不会写作const_CCNode:create()。那么在后者的继承链上，每一个const type实际成了断点，没有得到这个type自身的函数！</p><p>3.tolua_beginmodule（） tolua_endmodule()  tolua_function()</p><p>tolua_beginmodule(m_pState, “CTest”);是只注册一个模块，比如，我们管CTest叫做”CTest”，保持和C++的名称一样。这样在Lua的对象库中就会多了一个CTest的对象描述，等同于string,number等等基本类型，同tolua_beginmodule()和tolua_endmodule()对象必须成对出现，如果出现不成对的，你注册的C++类型将会失败。 </p><p>tolua_function(m_pState, “SetData”, tolua_SetData_CTest);指的是将Lua里面CTest对象的”SetData”绑定到你的tolua_SetData_CTest()函数中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？&quot;&gt;&lt;a href=&quot;#tolua-如何将c-对象导入到lua里？lua如何能够访问c-对象成员？&quot; class=&quot;headerlink&quot; title=&quot;tolua++如何将c++对象导入到
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua闭包</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E9%97%AD%E5%8C%85/"/>
    <id>https://bytemode.github.io/2018/12/15/lua闭包/</id>
    <published>2018-12-15T10:47:01.000Z</published>
    <updated>2018-12-27T08:12:07.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lua中有两种闭包-c闭包和lua闭包"><a href="#lua中有两种闭包-c闭包和lua闭包" class="headerlink" title="lua中有两种闭包, c闭包和lua闭包"></a>lua中有两种闭包, c闭包和lua闭包</h4><p>两种闭包的公共部分:</p><pre><code>#define ClosureHeader CommonHeader;\lu_byte isC; \  是否c闭包lua_byte nupvalues; \ upvalue的个数GCObject* gclist; \struct Table env 闭包的环境</code></pre><p>C闭包的结构</p><pre><code>struct CClosure{   ClosureHeader;   lua_CFunction f;   TValue upvalue[1];}</code></pre><p>结构比较简单, f是一个满足 int lua_func(lua_State*) 类型的c函数</p><p>upvalue是创建C闭包时压入的upvalue, 类型是TValue, 可以得知, upvalue可以是任意的lua类型 </p><p>Lua闭包结构</p><pre><code>struct LClosure{  ClosureHeader;  strcut Proto* p;  UpVal* upvals[1];}</code></pre><p>Proto的结构比较复杂, 这里先不做分析</p><p>统一的闭包结构, 一个联合体, 说明一个闭包要么是C闭包, 要么是lua闭包, 这个是用isC表识出来的.</p><pre><code>union Closure{    CClosure c;    LClosure  l;}</code></pre><p> <strong>闭包 == {功能抽象, upvalue, env}</strong> </p><h4 id="向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的"><a href="#向lua中注册c函数的过程是通过lua-pushcclosure-L-f-n-函数实现的" class="headerlink" title="向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的"></a>向lua中注册c函数的过程是通过lua_pushcclosure(L, f, n)函数实现的</h4><p>流程: </p><ol><li><p>创建一个 sizeof(CClosure) + (n - 1) * sizeof(TValue)大小的内存, 这段内存是 CClosure + TValue[n],,  isC= 1 标示其是一个C闭包.</p></li><li><p>c-&gt;f = f绑定c函数.         ———  <strong>闭包.功能抽象 = f</strong></p></li><li><p>env = 当前闭包的env.  ———- <strong>闭包.env = env</strong></p></li><li><p>把栈上的n个元素赋值到c-&gt;upvalue[]数组中, 顺序是越先入栈的值放在upvalue数组的越开始位置, c-&gt;nupvalues指定改闭包upvalue的个数.  ———- <strong>闭包.upvalue = upvalue</strong></p></li><li><p>弹出栈上n个元素, 并压入新建的Closure到栈顶.</p></li></ol><p>整个流程是: 分配内存, 填写属性, 链入gc监控, 绑定c函数, 绑定upvalue, 绑定env一个C闭包就ok了</p><h4 id="C闭包被调用的过程"><a href="#C闭包被调用的过程" class="headerlink" title="C闭包被调用的过程"></a>C闭包被调用的过程</h4><p>lua 闭包调用信息结构:</p><pre><code>struct CallInfo{    StkId base; ----闭包调用的栈基    StkId func; ----要调用的闭包在栈上的位置    StkId top;  ----闭包的栈使用限制    const Instruction *savedpc; ----如果在本闭包中再次调用别的闭包, 那么该值就保存下一条指令以便在返回时继续执行    int nresults; ----闭包要返回的值个数    int tailcalls;----尾递归用, 暂时不管}</code></pre><p>这个结构是比较简单的, 它的作用就是维护一个函数调用的有关信息, 其实和c函数调用的栈帧是一样的, 重要的信息base –&gt; ebp, func –&gt; 要调用的函数的栈index, savedpc –&gt; eip, top, nresults和tailcalls没有明显的对应.</p><p><strong>在lua初始化的时候, 分配了一个CallInfo数组, 并用L-&gt;base_ci指向该数组第一个元素, 用L-&gt;end_ci指向该数组最后一个指针, 用L-&gt;size_ci记录数组当前的大小, L-&gt;ci记录的是当前被调用的闭包的调用信息.</strong></p><p>下面讲解一个c闭包的调用的过程:<br>情景: c 函数</p><pre><code>int lua_test(lua_State* L){    int a = lua_tonumber(L, 1);    int b = lua_tonumber(L, 2);    a = a + b;    lua_pushnumber(L, a);}</code></pre><p>已经注册到了lua 中, 形成了一个C闭包, 起名为”test”, 下面去调用它<br><code>luaL_dostring(L, &quot;c = test(3, 4)&quot;)</code></p><p>调用过程堆栈变化情况如下：</p><p>1.初始栈</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-828474891656030&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2cCI6%2FKUHKD74rb5zUmgnkHU678%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=21047001409346822&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>2.压入了函数和参数的堆栈 </p><pre><code>lua_getglobal(L, “test”)lua_pushnumber(L, 3)lua_pushnumber(L, 4) </code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/fbb22d3ec714edd9bbe59e9f1a727f5b?fid=1259087893-250528-1072131023144167&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-RE7mQ7%2BV8SIVj7JObpxAupx2Kt0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092046924209033410&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>3.调用lua_test开始时的堆栈    lua_call(L,3, 4) </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/88d243fb39e38c3d56cefd3a5b2e3459?fid=1259087893-250528-712458354988681&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-QKj7KqKkVTuusQ8o0UkkVwLDB%2B0%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092063733828165106&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>4.调用结束的堆栈 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/ca3dd633932be0c1bb59256e44276e6d?fid=1259087893-250528-574814416488756&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-4jo1Tky2%2FALRP0b%2Bv49ptjJVAgw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092105420285105960&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><ol start="5"><li>取出结果的栈 lua_setglobal(L, “c”)     </li></ol><p><img src="https://thumbnail0.baidupcs.com/thumbnail/da6b672bfe31efd925d1b07252d8d61f?fid=1259087893-250528-381860168682101&amp;time=1544878800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-WW5zL3p%2Bf6EDOcBSTdSYtECt4cw%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=8092179093472688280&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><h4 id="lua-call函数的过程"><a href="#lua-call函数的过程" class="headerlink" title="lua_call函数的过程"></a>lua_call函数的过程</h4><ol><li>lua具有很强一致性, 不管是dostring, 还是dofile, 都会形成一个闭包, 也就是说, 闭包是lua中用来组织结构的基本构件, 这个特点使得lua中的结构具有一致性, 是一种简明而强大的概念.</li><li>根据1， a = test(3, 4)其实是被组织成为一个闭包放在lua栈顶[方便期间, 给这个lua闭包起名为bb], 也就说dostring真正调用的是bb闭包, 然后bb闭包执行时才调用的是test[保存当前信息到当前函数的CallInfo中]</li><li>在调用test的时刻, L-&gt;ci记载着bb闭包的调用信息, 所以, 先把下一个要执行的指令放在L-&gt;ci-&gt;savedpc中, 以供从test返回后继续执行.</li><li>取栈上的test C闭包 cl, 用 cl-&gt;isC == 1断定它的确是一个C闭包[进入一个新的CallInfo, 布置堆栈]</li><li><p>从L中新分配一个CallInfo ci来记录test的调用信息, 并把它的值设置到L-&gt;ci, 这表明一个新的函数调用开始了, 这里还要指定test在栈中的位置, L-&gt;base = ci-&gt;base = ci-&gt;func+1, 注意, 这几个赋值很重要, 导致的堆栈状态由图2转化到图3, 从图中可以看出, L-&gt;base指向了第一个参数, ci-&gt;base也指向了第一个参数, 所以在test中, 我们调用lua_gettop函数返回的值就是2， 因为在调用它的时候, 它的栈帧上只有2个元素, 实现了lua向c语言中传参数.<br>[调用实际的函数]</p></li><li><p>安排好堆栈, 下面就是根据L-&gt;ci-&gt;func指向的栈上的闭包(及test的C闭包), 找到对应的cl-&gt;c-&gt;f, 并调用, 就进入了c函数lua_test [获取返回值调整堆栈, 返回原来的CallInfo]</p></li><li><p>根据lua_test的返回值, 把test闭包和参数弹出栈, 并把返回值压入并调整L-&gt;top</p></li><li><p>恢复 L-&gt;base, L-&gt;ci 和 L-&gt;savedpc, 继续执行.</p></li></ol><h4 id="调用一个新的闭包时："><a href="#调用一个新的闭包时：" class="headerlink" title="调用一个新的闭包时："></a>调用一个新的闭包时：</h4><ol><li>保存当前信息到当前函数的CallInfo中 （CallInfo函数调用的状态信息）</li><li>进入一个新的CallInfo, 布置堆栈  </li><li>调用实际的函数  </li><li>获取返回值调整堆栈, 返回原来的CallInfo</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;lua中有两种闭包-c闭包和lua闭包&quot;&gt;&lt;a href=&quot;#lua中有两种闭包-c闭包和lua闭包&quot; class=&quot;headerlink&quot; title=&quot;lua中有两种闭包, c闭包和lua闭包&quot;&gt;&lt;/a&gt;lua中有两种闭包, c闭包和lua闭包&lt;/h4&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua模块注册</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C/"/>
    <id>https://bytemode.github.io/2018/12/15/lua模块注册/</id>
    <published>2018-12-15T10:19:25.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<p>Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.</p><h4 id="相关的函数index2adr"><a href="#相关的函数index2adr" class="headerlink" title="相关的函数index2adr"></a>相关的函数index2adr</h4><pre><code>static TValue *index2adr (lua_State *L, int idx) {  if (idx &gt; 0) {    TValue *o = L-&gt;base + (idx - 1);    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);    if (o &gt;= L-&gt;top) return cast(TValue *, luaO_nilobject);    else return o;  }  else if (idx &gt; LUA_REGISTRYINDEX) {    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);    return L-&gt;top + idx;  }  else switch (idx) {  /* pseudo-indices */    case LUA_REGISTRYINDEX: return registry(L);    case LUA_ENVIRONINDEX: {      Closure *func = curr_func(L);      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);      return &amp;L-&gt;env;    }    case LUA_GLOBALSINDEX: return gt(L);    default: {      Closure *func = curr_func(L);      idx = LUA_GLOBALSINDEX - idx;      return (idx &lt;= func-&gt;c.nupvalues)                ? &amp;func-&gt;c.upvalue[idx-1]                : cast(TValue *, luaO_nilobject);    }  }}</code></pre><p>一个Lua函数栈由两个指针base和top来指定,base指向函数栈底,top则指向栈顶.<br>回到index2addr函数中,几种情况:</p><ol><li>如果索引为正,则从函数栈底为起始位置向上查找数据</li><li>如果索引为负,则从函数栈顶为起始位置向下查找数据</li><li>紧跟着是几种特殊的索引值,都定义了非常大的数据,由于Lua栈限定了函数的栈尺寸,所以不会有那么大的索引,大可放心使用.</li></ol><p>索引值为LUA_REGISTRYINDEX时,则返回的是全局数据global_state的l_registry表;如果索引值为LUA_GLOBALSINDEX,则返回该Lua_State的l_gt表.</p><h4 id="lua模块注册"><a href="#lua模块注册" class="headerlink" title="lua模块注册"></a>lua模块注册</h4><p>Lua内部所有模块的注册都在linit.c的函数luaL_openlibs中提供.可以看到的是,它依次访问一个数组,数组中定义了每个模块的模块名及相应的模块注册函数,依次调用函数就完成了模块的注册.</p><pre><code>static const luaL_Reg lualibs[] = {  {&quot;&quot;, luaopen_base},  {LUA_LOADLIBNAME, luaopen_package},  {LUA_TABLIBNAME, luaopen_table},  {LUA_IOLIBNAME, luaopen_io},  {LUA_OSLIBNAME, luaopen_os},  {LUA_STRLIBNAME, luaopen_string},  {LUA_MATHLIBNAME, luaopen_math},  {LUA_DBLIBNAME, luaopen_debug},  {NULL, NULL}};LUALIB_API void luaL_openlibs (lua_State *L) {  const luaL_Reg *lib = lualibs;  for (; lib-&gt;func; lib++) {    lua_pushcfunction(L, lib-&gt;func);    lua_pushstring(L, lib-&gt;name);    lua_call(L, 1, 0);  }}</code></pre><p>我没有详细的查看每个模块的注册函数,不过还是以最简单的例子来讲解,就是最常用的print函数.</p><p>由于这个函数没有前缀,因此的它所在的模块是””,也就是一个空字符串,因此它是在base模块中注册的,调用的注册函数是luaopen_base.</p><p>紧跟着继续看luaopen_base内部调用的第一个函数base_open:</p><pre><code>static void base_open (lua_State *L) {  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);  /* open lib into global table */  luaL_register(L, &quot;_G&quot;, base_funcs);  // ....}</code></pre><p>首先来看最前面的两句:</p><pre><code>  /* set global _G */  lua_pushvalue(L, LUA_GLOBALSINDEX);  lua_setglobal(L, &quot;_G&quot;);</code></pre><p>这两句首先将LUA_GLOBALSINDEX对应的值压入栈中,其次调用”lua_setglobal(L, “_G”);”,这句代码的意思是在Lua_state的l_gt表中,当查找”_G”时,查找到的是索引值为LUA_GLOBALSINDEX的表.如果觉得有点绕,可以简单这个理解,在Lua中的G表,也就是全局表,满足这个等式”_G = _G[“_G”]“,也就是这个叫”_G”的表,内部有一个key为”_G”的表是指向自己的.怀疑这个结论的,可以在Lua命令行中执行print(_G)和print(_G[“_G”])看看输出结果是不是一致的.</p><p>Lua中要这么处理的理由是:为了让G表和处理其它表使用同样的机制.查找一个变量时,最终会一直查到G表中,这是很自然的事情;所以为了也能按照这个机制顺利的查找到自己,于是在G表中有一个同名成员指向自己.</p><p>好了,前面两句的作用已经分析完毕.其结果有两个:</p><ol><li>_G = _G[“_G”]</li><li>_G表的值压入函数栈中方便了下面的调用.</li></ol><p>继续看下面的语句:<br><strong>luaL_register(L, “_G”, base_funcs);</strong><br><strong>它最终会将base_funcs中的函数注册到G表中,但是里面还有些细节需要看看的.</strong></p><pre><code>LUALIB_API void luaI_openlib (lua_State *L, const char *libname,                              const luaL_Reg *l, int nup) {  if (libname) {    int size = libsize(l);    /* check whether lib already exists */    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);    lua_getfield(L, -1, libname);  /* get _LOADED[libname] */    if (!lua_istable(L, -1)) {  /* not found? */      lua_pop(L, 1);  /* remove previous result */      /* try global variable (and create one if it does not exist) */      if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)        luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);      lua_pushvalue(L, -1);      lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */    }    lua_remove(L, -2);  /* remove _LOADED table */    lua_insert(L, -(nup+1));  /* move library table to below upvalues */  }// ...}</code></pre><p>注册这些函数之前,首先会到l_registry表的成员_LOADED表中查找该库,如果不存在则再在G表中查找这个库,不存在则创建一个表.因此,不管是lua中内部的库或者是外部使用require引用的库,都会走这个流程并最终在G表和l_registry[“_LOADED”]中存放该库的表.最后,再遍历传进来的函数指针数组,完成库函数的注册.</p><p>比如,注册os.print时,首先将print函数绑定在一个函数指针上,再去l_registry[“_LOADED”]和G表中查询该名为”os”的库是否存在,不存在则创建一个表,即:<br>G[“os”] = {}</p><p>紧跟着注册print函数,即: G[“os”][“print”] = 待注册的函数指针.这样,在调用lua代码os.print(1)时,首先根据”os”到G表中查找对应的表,再在这个表中查找”print”成员得到函数指针,最后完成函数的调用.</p><h4 id="注册外部模块"><a href="#注册外部模块" class="headerlink" title="注册外部模块"></a>注册外部模块</h4><p><strong>luaL_newlibtable</strong> 它仅仅是创建了一个table,然后把数组里的函数放进去而已 </p><p><strong>luaL_setfuncs</strong>它把数组l中的所有函数注册入<strong>栈顶</strong>的table，并给所有函数绑上<strong>nup</strong>个<strong>upvalue</strong> </p><p>define luaL_newlibtable(L, l)</p><pre><code>lua_createtble(L, 0, sizeof(l)/sizeof((l)[0]) - 1)</code></pre><p>define luaL_newlib(L, l)</p><pre><code>(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0)</code></pre><pre><code>LUALIB_API void luaL_setfuncs(lua_State *L, const luaL_Reg *l, int nup){    luaL_checkversion(L);    luaL_checkstack(L, nup, &quot;too_many_upvalue&quot;);    for(; l-&gt;name != NULL; i++){/* fill the table with given functions*/        int i;        for(i = 0; i &lt; nup; i++)/copy upvalues to the top/            lua_pushvalue(L, -nup);        lua_pushclosure(L, l-&gt;func, nup);/closure with those upvalues/        lua_setfield(L, -(nup + 2), l-&gt;name);    }    lua_pop(L, nup);/remove upvalues/}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua自带的模块并不多,好处就是Lua足够的小,毕竟它的设计目标是定位成一个嵌入式的轻量级语言的.&lt;/p&gt;
&lt;h4 id=&quot;相关的函数index2adr&quot;&gt;&lt;a href=&quot;#相关的函数index2adr&quot; class=&quot;headerlink&quot; title=&quot;相关的函数in
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua协程</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%8D%8F%E7%A8%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua协程/</id>
    <published>2018-12-15T09:56:15.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器领域，使用Lua协程最好的范例就是ngx_lua了</p><p>来看看Lua协程内部是如何实现的。</p><p>本质上，每个Lua协程其实也是对应一个LuaState指针，所以其实它内部也是一个完整的Lua虚拟机—有完整的Lua堆栈结构，函数调用栈等等等等，绝大部分之前对Lua虚拟机的分析都可以直接套用到Lua协程中。于是，由Lua虚拟机管理着这些隶属于它的协程，当需要暂停当前运行协程的时候，就保存它的运行环境，切换到别的协程继续执行。很简单的实现。</p><p>来看看相关的API。</p><ol><li>lua_newthread</li></ol><p>创建一个Lua协程，最终会调用的API是luaE_newthread，Lua协程在Lua中也是一个独立的Lua类型数据，它的类型是LUA_TTHREAD，创建完毕之后会照例初始化Lua的栈等结构，有一点需要注意的是，调用preinit_state初始化Lua协程的时候，传入的global表指针是来自于Lua虚拟机，换句话说，任何在Lua协程修改的全局变量，也会影响到其他的Lua协程包括Lua虚拟机本身。</p><ol start="2"><li>加载一个Lua文件并且执行</li></ol><p>对于一般的Lua虚拟机，大可以直接调用luaL_dofile即可，它其实是一个宏：</p><pre><code>#define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>展开来也就是当调用luaL_loadfile函数完成对该Lua文件的解析，并且没有错误时，调用lua_pcall函数执行这个Lua脚本。</p><p>但是对于Lua协程而言，却不能这么做，需要调用luaL_loadfile然后再调用lua_resume函数。所以两者的区别在于lua_pcall函数和lua_resume函数。来看看lua_resume函数的实现。这个函数做的几件事情：首先查看当前Lua协程的状态对不对，然后修改计数器：</p><pre><code> L-&gt;baseCcalls = ++L-&gt;nCcalls;</code></pre><p>其次调用status = luaD_rawrunprotected(L, resume, L-&gt;top – nargs);，可以看到这个保护Lua函数堆栈的调用luaD_rawrunprotected最终调用了函数resume:</p><pre><code>static void resume (lua_State *L, void *ud) {  StkId firstArg = cast(StkId, ud);  CallInfo *ci = L-&gt;ci;  if (L-&gt;status == 0) {  /* start coroutine? */    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);    if (luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA)      return;  }  else {  /* resuming from previous yield */    lua_assert(L-&gt;status == LUA_YIELD);    L-&gt;status = 0;    if (!f_isLua(ci)) {  /* `common&#39; yield? */      /* finish interrupted execution of `OP_CALL&#39; */      lua_assert(GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||                 GET_OPCODE(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);      if (luaD_poscall(L, firstArg))  /* complete it... */        L-&gt;top = L-&gt;ci-&gt;top;  /* and correct top if not multiple results */    }    else  /* yielded inside a hook: just continue its execution */      L-&gt;base = L-&gt;ci-&gt;base;  }  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));}</code></pre><p>这个函数将执行Lua代码的流程划分成了几个阶段，如果调用</p><pre><code>luaD_precall(L, firstArg - 1, LUA_MULTRET) != PCRLUA</code></pre><p>那么说明这次调用返回的结果小于0，可以跟进luaD_precall函数看看什么情况下会出现这样的情况：</p><pre><code>    n = (*curr_func(L)-&gt;c.f)(L);  /* do the actual call */    lua_lock(L);    if (n &lt; 0)  /* yielding? */      return PCRYIELD;    else {      luaD_poscall(L, L-&gt;top - n);      return PCRC;    }</code></pre><p>继续回到resume函数中，如果之前该Lua协程的状态是YIELD，那么说明之前被中断了，则调用luaD_poscall完成这个函数的调用。<br>然后紧跟着调用luaV_execute继续Lua虚拟机的继续执行。</p><p>可以看到，resume函数做的事情其实有那么几件：</p><ol><li>如果调用C函数时被YIELD了，则直接返回</li><li>如果之前被YIELD了，则调用luaD_poscall完成这个函数的执行，接着调用luaV_execute继续Lua虚拟机的执行。</li></ol><p>因此，这个函数对于函数执行中可能出现的YIELD，有充分的准备和判断，因此它不像一般的pcall那样，一股脑的往下执行，而是会在出现YIELD的时候保存现场返回，在继续执行的时候恢复现场。<br>3）同时，由于resume函数是由luaD_rawrunprotected进行保护调用的，即使执行出错，也不会造成整个程序的退出。</p><p>这就是Lua协程中，比一般的Lua操作过程做的更多的地方。</p><p>最后给出一个Lua协程的例子：<br>co.lua</p><pre><code>print(&quot;before&quot;)test(&quot;123&quot;)print(&quot;after resume&quot;)</code></pre><p>co.c</p><pre><code> #include     #include &quot;lua.h&quot;    #include &quot;lualib.h&quot;    #include &quot;lauxlib.h&quot;    static int panic(lua_State *state) {      printf(&quot;PANIC: unprotected error in call to Lua API (%s)\n&quot;,              lua_tostring(state, -1));      return 0;    }    static int test(lua_State *state) {      printf(&quot;in test\n&quot;);      printf(&quot;yielding\n&quot;);      return lua_yield(state, 0);    }    int main(int argc, char *argv[]) {      char *name = NULL;      name = &quot;co.lua&quot;;      lua_State*  L1 = NULL;      L1 = lua_open();      lua_atpanic(L1, panic);      luaL_openlibs( L1 );      lua_register(L1, &quot;test&quot;, test);      lua_State*  L = lua_newthread(L1);      luaL_loadfile(L, name);      lua_resume(L, 0);      printf(&quot;sleeping\n&quot;);      sleep(1);      lua_resume(L, 0);      printf(&quot;after resume test\n&quot;);      return 0;    }</code></pre><p>你可以使用coroutine.create来创建协程,协程有三种状态：挂起，运行，停止。创建后是挂起状态，即不自动运行。status函数可以查看当前状态。协程真正强大的地方在于他可以通过yield函数将一段正在运行的代码挂起。</p><p>lua的resume-yield可以互相交换数据</p><pre><code>co = coroutine.create(function (a, b)     coroutine.yield(a+b, a-b)end)print(coroutine.resume(co, 3, 8))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程是个很好的东西，它能做的事情与线程相似，区别在于：协程是使用者可控的，有API给使用者来暂停和继续执行，而线程由操作系统内核控制；另外，协程也更加轻量级。这样，在遇到某些可能阻塞的操作时，可以使用暂停协程让出CPU；而当条件满足时，可以继续执行这个协程。目前在网络服务器
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表类型</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%A1%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/lua表类型/</id>
    <published>2018-12-15T09:51:02.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lua的表的定义"><a href="#Lua的表的定义" class="headerlink" title="Lua的表的定义:"></a>Lua的表的定义:</h4><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>这里将Table分为了两个部分:数组部分,array指针指向数组部分的首地址,sizearray是数组的尺寸,绝大部分(注意:不是全部)正整数为key的数据都存放在数组部分;node指针指向一个hash桶,对于不能存放在数组部分的数据,都存放在hash中.如下图所示:<br><img src="https://thumbnail0.baidupcs.com/thumbnail/46eff62f24b48c0dd2380abaa949cb84?fid=1259087893-250528-534280502274275&amp;time=1544864400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-KcBURzIEUOljxyzUWcN5%2FL3uieo%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=17866885042028318&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt=""></p><p>hash部分需要特别注意的一点是:在物理上,所有hash部分的数据,其实是存放一块连续的内存中的,即node指针指向的数组;但是从逻辑上来看,如果几块数据在同一个hash桶上,那么又是通过next指针串联起来的.<br>以图中的示例来分析,node数组的第一个和第三个元素,在物理上是第一和第三个元素,但是在逻辑上,它们是通过next指针串联起来的.</p><h4 id="Table查找数据"><a href="#Table查找数据" class="headerlink" title="Table查找数据"></a>Table查找数据</h4><p>有了以上的了解,从Table中查找一个数据的伪代码就很显而易见了:</p><p>如果输入的Key是一个正整数,并且它的值 &gt; 0 &amp;&amp; &lt;= 数组大小<br>    尝试在数组部分查找<br>否则尝试在Hash部分进行查找:<br>    计算出该Key的Hash值(ltable.c中的mainposition函数),根据此Hash值访问node数组得到Hash桶所在位置<br>    遍历该Hash桶下的所有链表元素,直到找到该Key为止<br>以上已经明白了Table的大致结构,来看看Table中如果新加入新的数据会怎么处理.这里有一些内容,要留到后面讲解到Lua虚拟机的时候才触及,这里先讲解一下,当新插入数据时,Table内的数组和Hash部分,做了哪些变化.</p><p>这部分中,核心的算法在ltable.c的rehash函数中,这个函数是计算当新添加数据时,数组和hash重新分配之后各自的尺寸是多少,伪代码如下:</p><p>首先分配一个位图nums,将其中的所有位置0,这个位图的意义在于:nums数组中第i个元素存放的是key在2^(i-1), 2^i之间的元素数量<br>遍历lua Table中的数组部分,计算在数组部分中的元素数量,更新对应的nums数组元素数量.(numusearray函数)<br>遍历lua Table中的Hash部分,因为其中也可能存放了正整数,也根据这里的正整数数量更新对应的nums数组元素数量.(numusehash函数)<br>此时nums数组已经有了当前这个Table中所有正整数的分配统计,逐个遍历nums数组,如果当前已经有的根据新的数组大小和Hash大小重新分配table的大小(computesizes函数)<br>这里要特别讲解的是computesizes函数,在前面的两个函数调用numusearray函数和numusehash函数之后,此时在nums位图中,已经存放了所有有关整数key的信息,即在[2^(i-1), 2^i]范围内,有多少数据.前面曾经提到过,并不是所有的正整数,都会存放在数组部分的,即使它曾经在,也有可能在之后被分配到hash部分,那么判断的依据是什么?到底怎样的数据,在重新分配之后会从数组部分挪到hash部分?<br>来看computesizes函数的实现:</p><pre><code>static int computesizes (int nums[], int *narray) {  int i;  int twotoi;  /* 2^i */  int a = 0;  /* number of elements smaller than 2^i */  int na = 0;  /* number of elements to go to array part */  int n = 0;  /* optimal size for array part */  for (i = 0, twotoi = 1; twotoi/2 &lt; *narray; i++, twotoi *= 2) {    if (nums[i] &gt; 0) {      a += nums[i];      if (a &gt; twotoi/2) {  /* more than half elements present? */        n = twotoi;  /* optimal size (till now) */        na = a;  /* all elements smaller than n will go to array part */      }    }    if (a == *narray) break;  /* all elements already counted */  }  *narray = n;  lua_assert(*narray/2 &lt;= na &amp;&amp; na &lt;= *narray);  return na;}</code></pre><p>注意到这样的细节:这个函数在遍历nums位图数组的时候,会将当前数据数量存放在变量a中,如果a &gt; twotoi/2,也就是当前有一半以上的空间被利用上了,那么这部分数据会继续留在数组部分,否则就会在之后挪到hash部分了.</p><h4 id="纯粹的使用数组或者hash表性能更高"><a href="#纯粹的使用数组或者hash表性能更高" class="headerlink" title="纯粹的使用数组或者hash表性能更高"></a>纯粹的使用数组或者hash表性能更高</h4><p>为了证实这里的判断,简单的写一段lua代码做为实验:</p><pre><code>function print_ipairs(t)  print(&quot;in print_ipairs&quot;)  for k, v in ipairs(t) do    print(k)  endend function print_pairs(t)  print(&quot;in print_pairs&quot;)  for k, v in pairs(t) do    print(k)  endend a = {}a={1,2,3,4,5,6,7,8,9,10}print_ipairs(a)a[2] = nila[3] = nila[4] = nila[6] = nila[&quot;k&quot;] = &quot;e&quot;print_ipairs(a)print_pairs(a)输出为:in print_ipairs12345678910in print_ipairs1in print_pairs17810k59</code></pre><p>在这里,首先对表a赋值,有1-10共十个元素,通过调用函数print_ipairs可知,这些元素都是存放在数组部分的,这是因为ipairs取的是Table的数组部分元素.<br>在这之后,人为的将其中2,3,4,6元素删除,造成原来数组不满一半元素被利用上的现象,然后再插入一个新key “k”,以让这个Table重新分配空间.再此之后,再次调用ipairs遍历a的数组部分,可以看到只有1被打印出来了,也就是说,在重新分配空间之后,除去已经被删除的2,3,4,6之外,只有1还在数组里面,剩下的5,7,8,9,10已经不在数组部分了.紧接着调用pairs遍历这个表,可以看出这些已经不在数组部分的值又被打印出来了,并且它们的顺序已经被打乱,不再按照数字大小顺序来排列了,它们在这次重新分配中被挪动到了hash部分.</p><p>这个实验既验证了我们前面的分析,同时也告诉我们,Table的重新分配,实际上代价是很大的,因此不建议在实际程序中,一个Table即有数组部分,也有Hash部分,纯粹一些,性能上会有提升.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Lua的表的定义&quot;&gt;&lt;a href=&quot;#Lua的表的定义&quot; class=&quot;headerlink&quot; title=&quot;Lua的表的定义:&quot;&gt;&lt;/a&gt;Lua的表的定义:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef struct Table {
  CommonHeade
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua通用数据类型</title>
    <link href="https://bytemode.github.io/2018/12/15/LUA%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://bytemode.github.io/2018/12/15/LUA的通用数据类型/</id>
    <published>2018-12-15T06:57:00.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TValue结构"><a href="#TValue结构" class="headerlink" title="TValue结构"></a>TValue结构</h4><p>TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.很容易想到,在面向对象中,这个结构体是一个基类,派生出来的都是其他的子类.</p><p>TValue结构体内部有几个宏, 展开之后就是这样的:</p><pre><code>typedef struct lua_TValue {    union {      union GCObject {        struct GCheader {          GCObject *next; lu_byte tt; lu_byte marked;        } gch;        union TString ts;        union Udata u;        union Closure cl;        struct Table h;        struct Proto p;        struct UpVal uv;        struct lua_State th;  /* thread */      } gc;      void *p;      lua_Number n;      int b;    } value;    int tt;} TValue;</code></pre><p>这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int.</p><h4 id="gc-union"><a href="#gc-union" class="headerlink" title="gc union"></a>gc union</h4><p>gc union的定义,可以看到各种可gc的类型(Tstring,Udata..etc)和一个GCHeader放在 一起,也就是说,当这部分还是数据的时候,数据部分启用,否则就是gc部分了.这里的GCHeader包括了三个部分:next指针将可gc的数据串联成链表,tt表示数据类型,marked存放的gc处理时的颜色值.<br>这是另一种方式的使用C语言实现的面向对象,对外部而言,TValue结构体可以看作是”基类”,真正进行处理时,再根据数据类型决定到底使用value union中的哪个数据部分.可以看到lua源代码中定义了很多宏就是这样操作Tvalue数据指针的,比如:</p><pre><code>#define hvalue(o)    check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)</code></pre><p>这个宏定义了如何从TValue指针得到Table结构体:首先判断数据类型是Table,然后将value的gc union中Table *h取出.</p><p>反之,要从一个具体的类型转换再赋值为相应的TValue,Lua源代码中也提供了相应的宏.因为TValue结构体的中的value域是一个union,所以其实随便强制转换为其中的哪一种类型都可以,不过看上去最舒服的写法还是直接转换为公共类型GCObject了,比如:</p><pre><code>#define setsvalue(L,obj,x) \  { TValue *i_o=(obj); \    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \checkliveness(G(L),i_o); }</code></pre><h4 id="GCObject"><a href="#GCObject" class="headerlink" title="GCObject"></a>GCObject</h4><pre><code>union GCObject {  GCheader gch;  union TString ts;  union Udata u;  union Closure cl;  struct Table h;  struct Proto p;  struct UpVal uv;  struct lua_State th;  /* thread */};</code></pre><p>其中的GCheader展开是这样的:</p><pre><code>typedef struct GCheader {  CommonHeader;} GCheader;</code></pre><p>而随便抽在GCObject结构体中的数据类型结构体定义,都发现也包含了一个CommonHeader结构体,比如:</p><pre><code>typedef struct Table {  CommonHeader;  lu_byte flags;  lu_byte lsizenode;  /* log2 of size of `node&#39; array */  struct Table *metatable;  TValue *array;  /* array part */  Node *node;  Node *lastfree;  /* any free position is before this position */  GCObject *gclist;  int sizearray;  /* size of `array&#39; array */} Table;</code></pre><p>换言之,在GCObject中,无论是哪个数据结构体,都自己有一份CommonHeader.仔细观察,其实GCObject这个union的内存分布,最开始部分无论如何都是留给CommonHeader的.这样做,就保证了一个存放在TValue结构体中的数据,既可以使用CommonHeader关于GC的部分,也可以使用到自己本身的数据部分了.</p>]]></content>
    
    <summary type="html">
    
      TValue这个结构体是Lua的通用结构体,,Lua中的所有的数据都可以使用这个结构体来表示.这个结构体定义,总体来说分为两个部分:tt存放的数据类型,而value域存放的是各种数据.而在其中,又划分为两个部分,可gc的数据类型使用union放在一起,剩下的就是不可gc的数据类型了:void*,lua_Number,int. gc联合体部分就是GCobject
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua栈</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E6%A0%88/"/>
    <id>https://bytemode.github.io/2018/12/15/lua栈/</id>
    <published>2018-12-15T06:56:54.000Z</published>
    <updated>2018-12-27T08:12:07.824Z</updated>
    
    <content type="html"><![CDATA[<p>既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.</p><p>lua虚拟机在初始化创建lua_State结构体时,会走到stack_init函数中,这个函数主要就是对Lua栈和CallInfo数组的初始化:</p><pre><code>static void stack_init (lua_State *L1, lua_State *L) {  /* initialize CallInfo array */  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);  L1-&gt;ci = L1-&gt;base_ci;  L1-&gt;size_ci = BASIC_CI_SIZE;  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - 1;  /* initialize stack array */  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TValue);  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;  L1-&gt;top = L1-&gt;stack;  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;  /* initialize first ci */  L1-&gt;ci-&gt;func = L1-&gt;top;  setnilvalue(L1-&gt;top++);  /* `function&#39; entry for this `ci&#39; */  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;}</code></pre><p>可以看到的是,初始化了两个数组,分别保存Lua栈和CallInfo结构体数组.<br>其中,与Lua栈相关的lua_State结构体成员变量有base,stack,top,lastfree,stack保存的是数组的初始位置,base会根据每次函数调用的情况发生变化,top指针指向的是当前第一个可用的栈位置,每次向栈中增加/删减元素都要对应的增减top指针,lastfee指针指向的书Lua栈的最后位置.</p><p>CallInfo结构体,是每次有函数调用时都会去初始化的一个结构体,它的成员变量中,也有top,base指针,同样的是指向Lua栈的位置,所不同的是,它关注的仅是函数调用时的相关位置.从代码中可以看出,CallInfo数组是有限制的,换言之,在Lua中的嵌套函数调用层次也是有限制,不能超过一定数量.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215144229849-16830691.png" alt=""></p><p>首先看f_parser函数:</p><pre><code>static void f_parser (lua_State *L, void *ud) {  int i;  Proto *tf;  Closure *cl;  struct SParser *p = cast(struct SParser *, ud);  int c = luaZ_lookahead(p-&gt;z);  luaC_checkGC(L);  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                             &amp;p-&gt;buff, p-&gt;name);  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));  cl-&gt;l.p = tf;  for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */    cl-&gt;l.upvals[i] = luaF_newupval(L);  setclvalue(L, L-&gt;top, cl);  incr_top(L);}</code></pre><p>f_parser函数的最后两句,将分析完毕之后的结构Closure指针压入了Lua栈.</p><p>再来看luaD_precall函数,这里为将代码放入Lua虚拟机中执行准备了相关数据,我们只截取其中的一部分来看:</p><pre><code>int luaD_precall (lua_State *L, StkId func, int nresults) {  ….  if (!cl-&gt;isC) {  /* Lua function? prepare its call */    CallInfo *ci;    StkId st, base;    Proto *p = cl-&gt;p;// 1) 根据函数的参数类型,计算出该CallInfo的base指针位置    if (!p-&gt;is_vararg) {  /* no varargs? */      base = func + 1;      if (L-&gt;top &gt; base + p-&gt;numparams)        L-&gt;top = base + p-&gt;numparams;    }    else {  /* vararg function */      int nargs = cast_int(L-&gt;top - func) - 1;      base = adjust_varargs(L, p, nargs);      func = restorestack(L, funcr);  /* previous call may change the stack */}// 2) 分配一个新的CallInfo结构体,用于保存此次函数调用的相关信息:top,base指针,func函数    ci = inc_ci(L);  /* now `enter&#39; new function */    ci-&gt;func = func;    L-&gt;base = ci-&gt;base = base;    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);    // 3) LuaState的PC指针指向函数原型的代码数组    L-&gt;savedpc = p-&gt;code;  /* starting point */    // …..    return PCRLUA;  }</code></pre><p>到这一步,跟某次具体的Lua代码执行相关的代码(保存在Proto的code数组中)和执行时所需环境(Lua栈),就已经准备完毕了.后面就是进入Lua虚拟机的主循环中解释执行代码了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;既然Lua虚拟机模拟的是CPU的运作,那么Lua栈模拟的就是内存的角色.在Lua内部,参数的传递是通过Lua栈,同时Lua与C等外部进行交互的时候也是使用的栈.,先关注的是Lua栈的分配,管理和相关的数据结构.&lt;/p&gt;
&lt;p&gt;lua虚拟机在初始化创建lua_State结构体
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数与upavalue</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E4%B8%8Eupavalue/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数与upavalue/</id>
    <published>2018-12-15T06:35:14.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。</p><p>函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：</p><pre><code>static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {  FuncState *fs = ls-&gt;fs;  Proto *f = fs-&gt;f;  int oldsize = f-&gt;sizep;  int i;  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,                  MAXARG_Bx, &quot;constant table overflow&quot;);  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;  f-&gt;p[fs-&gt;np++] = func-&gt;f;  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));  for (i=0; if-&gt;nups; i++) {    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);  }}</code></pre><p>注意在这个函数的最后，将遍历upvalue数组，根据该upvalue是否是局部变量，来决定紧跟着的是MOVE指令还是GETUPVAL指令。而这些是如何确定的呢？</p><p>Lua的分析器在解析到一个变量时，会调用singlevaraux函数进行查找：</p><pre><code>static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {  if (fs == NULL) {  /* no more levels? */    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */    return VGLOBAL;  }  else {    int v = searchvar(fs, n);  /* look up at current level */    if (v &gt;= 0) {      init_exp(var, VLOCAL, v);      if (!base)        markupval(fs, v);  /* local will be used as an upval */      return VLOCAL;    }    else {  /* not found at current level; try upper one */      if (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)        return VGLOBAL;      var-&gt;u.s.info = indexupvalue(fs, n, var);  /* else was LOCAL or UPVAL */      var-&gt;k = VUPVAL;  /* upvalue in this level */      return VUPVAL;    }  }}</code></pre><p>可以看到，这个函数是一个递归函数，有以下几种情况：</p><ol><li>在函数的当前层找到该变量，则认为一个LOCAL变量</li><li>在函数的上层找到，则认为一个UPVAL</li><li>最后，则认为是一个全局变量。</li></ol><p>如何定义函数的“层次”？来看一个例子就知道了:</p><pre><code>local a = 1function test1()  local b = 100  function test2()     print(a)     print(b)  endendtest1()</code></pre><p>在这个例子中，函数test2与变量b是同层的，所以在调用函数test2时，singlevaraux查找变量b返回的LOCAL变量；而变量a是更上一层的LOCAL变量，对于函数test2而言，它就是UPVAL。</p><p>明白了解析部分是怎么处理upvalue的，来看看在虚拟机中是如何处理的。<br>对应的代码在lvm.c中的这一部分：</p><pre><code>      case OP_CLOSURE: {        Proto *p;        Closure *ncl;        int nup, j;        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];        nup = p-&gt;nups;        ncl = luaF_newLclosure(L, nup, cl-&gt;env);        ncl-&gt;l.p = p;        for (j=0; jl.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];          else {            lua_assert(GET_OPCODE(*pc) == OP_MOVE);            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));          }        }        setclvalue(L, ra, ncl);        Protect(luaC_checkGC(L));        continue;      }</code></pre><p>当变量是UPVAL时，此时PC指令对应的B参数是函数结构体的upval数组的索引，根据它直接从upval数组中取出值来；否则，PC指令对应的B参数是基于函数基地址base的一个偏移量，根据它得到相应的变量；再调用函数luaF_findupval：</p><pre><code>UpVal *luaF_findupval (lua_State *L, StkId level) {  global_State *g = G(L);  GCObject **pp = &amp;L-&gt;openupval;  UpVal *p;  UpVal *uv;  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) {    lua_assert(p-&gt;v != &amp;p-&gt;u.value);    if (p-&gt;v == level) {  /* found a corresponding upvalue? */      if (isdead(g, obj2gco(p)))  /* is it dead? */        changewhite(obj2gco(p));  /* ressurect it */      return p;    }    pp = &amp;p-&gt;next;  }  uv = luaM_new(L, UpVal);  /* not found: create a new one */  uv-&gt;tt = LUA_TUPVAL;  uv-&gt;marked = luaC_white(g);  uv-&gt;v = level;  /* current value lives in the stack */  uv-&gt;next = *pp;  /* chain it in the proper position */  *pp = obj2gco(uv);  uv-&gt;u.l.prev = &amp;g-&gt;uvhead;  /* double link it in `uvhead&#39; list */  uv-&gt;u.l.next = g-&gt;uvhead.u.l.next;  uv-&gt;u.l.next-&gt;u.l.prev = uv;  g-&gt;uvhead.u.l.next = uv;  lua_assert(uv-&gt;u.l.next-&gt;u.l.prev == uv &amp;&amp; uv-&gt;u.l.prev-&gt;u.l.next == uv);  return uv;}</code></pre><p>注意到，传入这个函数的参数level，其实是前面已经根据base基址定位到的变量。这个函数分为两个部分：</p><ol><li>首先，遍历当前的openupval数组，查找这个变量。由于这个变量肯定是前面已经定义过的，所以查找的条件就是（(p = ngcotouv(*pp))-&gt;v &gt;= level）。当查找到这个变量时，如果是准备释放的变量，则将它重新置为不可释放。</li><li>如果在openval数组中没有找到，说明之前没有别的地方引用过这个upval。如此则重新分配一个upvalue指向待引用的值。</li><li>最后，当函数调用完毕时，有相应的close指令，将upvalue的引用关系去除。具体见函数luaF_close。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua中的所谓upvalue是一类比较特殊的值，可以理解为在某函数内引用外部的数据。&lt;/p&gt;
&lt;p&gt;函数定义中用到了pushclosure这个函数用于将函数的定义Proto结构体指针push到父函数的数组中，在这个函数内，还建立了有关upvalue相关的逻辑：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua虚拟机概述</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <id>https://bytemode.github.io/2018/12/15/lua虚拟机概述/</id>
    <published>2018-12-15T05:42:38.000Z</published>
    <updated>2018-12-27T08:12:07.825Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为虚拟机"><a href="#何为虚拟机" class="headerlink" title="何为虚拟机"></a>何为虚拟机</h4><p>用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode(”操作码”),可以理解为这门程序自己定义的”汇编语言”.一般的编译型语言,比如C等,经过编译器编译之后生成的都是与当前硬件环境相匹配的汇编代码;而脚本型的语言,经过前端的处理之后,生成的就是opcode,再将该opcode放在这门语言的虚拟机中执行.虚拟机是作为单独的程序独立存在,而Lua由于是一门嵌入式的语言是附着在宿主环境中的.   </p><h3 id="lua代码到虚拟机执行的流程"><a href="#lua代码到虚拟机执行的流程" class="headerlink" title="lua代码到虚拟机执行的流程"></a>lua代码到虚拟机执行的流程</h3><p><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215140547779-1286988518.png" alt=""></p><p>在Lua中,Lua代码从词法分析到语法分析再到生成opcode,最后进入虚拟机执行的大体流程是什么样子的呢？</p><p>Lua的API中提供了luaL_dofile函数,它实际上是个宏,内部首先调用luaL_loadfile函数,加载Lua代码进行语法,词法分析,生成Lua虚拟机可执行的代码,再调用lua_pcall函数,执行其中的代码:</p><pre><code>    #define luaL_dofile(L, fn) \        (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</code></pre><p>前半部分调用luaL_loadfile函数对Lua代码进行词法和语法分析,后半部分调用lua_pcall将第一步中分析的结果(也就是opcode)到虚拟机中执行.</p><p>首先来看luaL_loadfile函数,暂时不深入其中研究它如何分析一个Lua代码文件,先看它最后输出了什么.它最终会调用f_parser函数,这是对一个Lua代码进行分析的入口函数:</p><pre><code>    static void f_parser (lua_State *L, void *ud) {      int i;      Proto *tf;      Closure *cl;      struct SParser *p = cast(struct SParser *, ud);      int c = luaZ_lookahead(p-&gt;z);      luaC_checkGC(L);      tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,                                                                 &amp;p-&gt;buff, p-&gt;name);      cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));      cl-&gt;l.p = tf;      for (i = 0; i &lt; tf-&gt;nups; i++)  /* initialize eventual upvalues */        cl-&gt;l.upvals[i] = luaF_newupval(L);      setclvalue(L, L-&gt;top, cl);      incr_top(L);    }</code></pre><p>在完成词法分析之后,返回了Proto类型的指针tf,然后将其绑定在新创建的Closure指针上,初始化UpValue,最后压入Lua栈中.</p><p>不难想像,Lua词法分析之后产生的opcode等相关数据都在这个Proto类型的结构体中.</p><p>再来看lua_pcall函数是如何将产生的opcode放入虚拟机执行的.</p><p>lua_pcall函数中,首先获取需要调用的函数指针:</p><pre><code>    c.func = L-&gt;top - (nargs+1);  /* function to be called */</code></pre><p>这里的nargs是由函数参数传入的,luaL_dofile中调用lua_pcall时这里传入的参数是0,换句话说,这里得到的函数对象指针就是在f_parser函数中最后放入Lua栈的指针.</p><p>继续往下执行,走到luaD_call函数,有这一段代码:</p><pre><code>      if (luaD_precall(L, func, nResults) == PCRLUA)  /* is a Lua function? */        luaV_execute(L, 1);  /* call it */</code></pre><p>进入luaV_execute函数,这里是虚拟机执行代码的主函数:</p><pre><code>    void luaV_execute (lua_State *L, int nexeccalls) {      LClosure *cl;      StkId base;      TValue *k;      const Instruction *pc;     reentry:  /* entry point */      lua_assert(isLua(L-&gt;ci));      pc = L-&gt;savedpc;      cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;      base = L-&gt;base;      k = cl-&gt;p-&gt;k;      /* main loop of interpreter */      for (;;) {        const Instruction i = *pc++;        StkId ra;        if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;            (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {          traceexec(L, pc);          if (L-&gt;status == LUA_YIELD) {  /* did hook yield? */            L-&gt;savedpc = pc - 1;            return;          }          base = L-&gt;base;        }        /* warning!! several calls may realloc the stack and invalidate `ra&#39; */        ra = RA(i);    // 以下是各种opcode的情况处理    }</code></pre><p>可以看到,这里的pc指针里存放的是虚拟机opcode代码,它最开始从L-&gt;savepc初始化而来,而L-&gt;savepc在luaD_precall中赋值:</p><pre><code>    L-&gt;savedpc = p-&gt;code;  /* starting point */</code></pre><p>这里的p就是第一步f_parser中返回的Proto指针.</p><p>回顾一下整个流程:</p><ol><li><p>函数f_parser中,对Lua代码文件的分析返回了Proto指针</p></li><li><p>函数luaD_precall中,将Lua_state的savepc指针指向1中的Proto结构体的code指针</p></li><li><p>函数luaV_execute中,pc指针指向2中的savepc指针,紧跟着就是一个大的循环体,依次取出其中的opcode进行执行.<br><img src="https://img2018.cnblogs.com/blog/1560953/201812/1560953-20181215141251439-1865045097.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;何为虚拟机&quot;&gt;&lt;a href=&quot;#何为虚拟机&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机&quot;&gt;&lt;/a&gt;何为虚拟机&lt;/h4&gt;&lt;p&gt;用于模拟计算机运行的程序.是个中间层,它处于脚本语言和硬件之间的一个程序.每一门脚本语言都会有自己定义的opcode
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua函数定义</title>
    <link href="https://bytemode.github.io/2018/12/15/lua%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    <id>https://bytemode.github.io/2018/12/15/lua函数定义/</id>
    <published>2018-12-15T05:24:49.000Z</published>
    <updated>2018-12-27T08:12:07.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="FuncState"><a href="#FuncState" class="headerlink" title="FuncState"></a>FuncState</h4><p>proto结构数组保存函数原型信息;prev保存父函数体指针；actvar保存定义的局部变量；upvalues保存upvalue</p><p>Lua源码中,专门有一个结构体FuncState用来保存函数相关的信息.其实,即使没有创建任何函数,对于Lua而言也有一个最外层的FuncState数据.这个结构体的定义:</p><pre><code>typedef struct FuncState {  Proto *f;  /* current function header */  Table *h;  /* table to find (and reuse) elements in  */  struct FuncState *prev;  /* enclosing function */  struct LexState *ls;  /* lexical state */  struct lua_State *L;  /* copy of the Lua state */  struct BlockCnt *bl;  /* chain of current blocks */  int pc;  /* next position to code (equivalent to `ncode&#39;) */  int lasttarget;   /* `pc&#39; of last `jump target&#39;  */  int jpc;  /* list of pending jumps to `pc&#39; */  int freereg;  /* first free register */  int nk;  /* number of elements in `k&#39;  */  int np;  /* number of elements in `p&#39;  */  short nlocvars;  /* number of elements in `locvars&#39; */  lu_byte nactvar;  /* number of active local variables  */  upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */  unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */} FuncState;</code></pre><p>其中的Proto结构体数组用于保存函数原型信息,包括函数体代码(opcode),之所以使用数组,是因为在某个函数内,可能存在多个局部函数.而prev指针就是指向这个函数的”父函数体”的指针.</p><p>比如以下代码:</p><pre><code>function fun()   function test()   endend</code></pre><p>那么,在保存test函数原型的Proto数据就存放在保存fun函数的FuncState结构体的p数组中,反之,保存test函数的FuncState.prev指针就指向保存func函数的FuncState指针.</p><p>接着看Funcstate结构体的成员,actvar数组用于保存局部变量,比如函数的参数就是保存在这里.另外还有一个存放upval值的upvalues数组.这里有两种不同的处理.如果这个upval是父函数内的局部变量,则生成的是MOVE指令用于赋值;如果对于父函数而言也是它的upval,则生成GET_UPVAL指令用于赋值.</p><p>当开始处理一个函数的定义时,首先调用open_func函数,创建一个新的Proto结构体用于保存函数原型信息,接着将该函数的FuncState的prev指针指向父函数.<br>最后当函数处理完毕时,调用pushclosure函数将这个新的函数的信息push到父函数的Proto数组中.</p><h4 id="函数也是第一类值-可以存在变量里"><a href="#函数也是第一类值-可以存在变量里" class="headerlink" title="函数也是第一类值 可以存在变量里"></a>函数也是第一类值 可以存在变量里</h4><p>最后,由于函数在Lua中是所谓的”first class type”,所以其实以下两段Lua代码是等价的:</p><pre><code>local function test()  -- 可以testend--以上相当于 local test； test = function() ...  endlocal test = function ()   --不可以调用test 以为第一类之定义完成之后才可以使用end</code></pre><p>也就是说,其实是生成一段代码,用于保存函数test的相关信息,之后再将这些信息赋值给变量test,这里的test可以是local,也可以是global的,这一点跟一般的变量无异.</p><h4 id="函数定义词法分析"><a href="#函数定义词法分析" class="headerlink" title="函数定义词法分析"></a>函数定义词法分析</h4><p>所以在与函数定义相关的词法分析代码中:</p><pre><code>static void funcstat (LexState *ls, int line) {  /* funcstat -&gt; FUNCTION funcname body */  int needself;  expdesc v, b;  luaX_next(ls);  /* skip FUNCTION */  needself = funcname(ls, &amp;v);  body(ls, &amp;b, needself, line);  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);  luaK_fixline(ls-&gt;fs, line);  /* definition `happens&#39; in the first line */}</code></pre><p>上面的变量v首先在funcname函数中获得该函数的函数名,变量b在进入函数body之后可以得到函数体相关的内容.在这之后的luaK_storevar调用,就是把b的值赋值给v,也就是前面提到的函数体赋值给函数名.</p>]]></content>
    
    <summary type="html">
    
      函数是第一类值，函数定义有funcstate结构表示，其中包含父函数指针，函数原型数组信息；actvar局部变量数组，upvalues保存upvalue数组信息。
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua字符串类型</title>
    <link href="https://bytemode.github.io/2018/12/14/lua%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://bytemode.github.io/2018/12/14/lua字符串/</id>
    <published>2018-12-14T14:25:11.000Z</published>
    <updated>2018-12-27T08:12:07.822Z</updated>
    
    <content type="html"><![CDATA[<p>Lua中字符串结构体的定义是:</p><pre><code>typedef union TString {  L_Umaxalign dummy;  /* ensures maximum alignment for strings */  struct {    CommonHeader;    lu_byte reserved;    unsigned int hash;    size_t len;  } tsv;} TString;</code></pre><p>这里TString结构体是一个union, 最开始的L_Umaxalign dummy;起到的是对齐作用.紧跟着是CommonHeader,可以看出TString也是可GC数据类型的一种.</p><p>在Lua中,字符串是一个保存在一个全局的地方,在globale_state的strt里面,这是一个hash数组,专门用于存放字符串:</p><pre><code>typedef struct stringtable {  GCObject **hash;  lu_int32 nuse;  /* number of elements */  int size;} stringtable;</code></pre><p>一个字符串TString,首先根据hash算法算出hash值,这就是stringtable中hash的索引值,如果这里已经有元素,则使用链表串接起来.</p><p>同时,TString中的字段reserved,表示这个字符串是不是保留字符串,比如Lua的关键字,在最开始赋值的时候是这么处理的:</p><pre><code>void luaX_init (lua_State *L) {  int i;  for (i=0; itsv.reserved = cast_byte(i+1);  /* reserved word */  }}</code></pre><p>这里存放的值,是数组luaX_tokens中的索引:</p><pre><code>const char *const luaX_tokens [] = {    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;,    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,    &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,    NULL};</code></pre><p>一方面可以迅速定位到是哪个关键字,另方面如果这个reserved字段不为0,则表示该字符串是不可自动回收的,在GC过程中会略过这个字符串的处理.</p><p>具体查找字符串时,首先计算出hash值,定位到所在的strt中的hash数组所在,再遍历hash桶所在链表,首先比较长度,如果相同再继续逐字节的比较字符串内容:</p><pre><code>TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {  GCObject *o;  unsigned int h = cast(unsigned int, l);  /* seed */  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don&#39;t hash all its chars */  size_t l1;  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-1]));  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];       o != NULL;       o = o-&gt;gch.next) {    TString *ts = rawgco2ts(o);    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0)) {      /* string may be dead */      if (isdead(G(L), o)) changewhite(o);      return ts;    }  }  return newlstr(L, str, l, h);  /* not found */}</code></pre>]]></content>
    
    <summary type="html">
    
      lua字符串结构体是TString，TString里的记录了hash值和字符串长度，真正的字符串是存储在全局globale_state的stringtable里面，这是一个gcobject组成的hash表.
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua-pcall的实现</title>
    <link href="https://bytemode.github.io/2018/12/13/lua-pcall%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://bytemode.github.io/2018/12/13/lua-pcall的实现/</id>
    <published>2018-12-13T05:24:24.000Z</published>
    <updated>2018-12-13T05:30:12.410Z</updated>
    
    <content type="html"><![CDATA[<p>Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。</p><p>对比起一般的函数调用方式，pcall多做了这些事情：</p><p>对函数调用前的Lua堆栈进行保护在调用完毕之后恢复，支持传入出错时的函数在调用出错时调用。</p><p>来依次看这个过程。</p><ol><li>首先看入口函数lua_pcall：</li></ol><pre><code>LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {  struct CallS c;  int status;  ptrdiff_t func;  lua_lock(L);  api_checknelems(L, nargs+1);  checkresults(L, nargs, nresults);  if (errfunc == 0)    func = 0;  else {    StkId o = index2adr(L, errfunc);    api_checkvalidindex(L, o);    func = savestack(L, o);  }  c.func = L-&gt;top - (nargs+1);  /* function to be called */  c.nresults = nresults;  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);  adjustresults(L, nresults);  lua_unlock(L);  return status;}</code></pre><p>lua_pcall函数与lua_call相比，多了第四个参数，该函数用于传入错误处理函数在Lua栈中的地址。所以第一步将根据传入的参数得到它的值在函数栈中的地址。然后根据这些参数调用函数luaD_pcall函数。</p><ol start="2"><li>luaD_pcall的实现</li></ol><pre><code>int luaD_pcall (lua_State *L, Pfunc func, void *u,                ptrdiff_t old_top, ptrdiff_t ef) {  int status;  unsigned short oldnCcalls = L-&gt;nCcalls;  ptrdiff_t old_ci = saveci(L, L-&gt;ci);  lu_byte old_allowhooks = L-&gt;allowhook;  ptrdiff_t old_errfunc = L-&gt;errfunc;  L-&gt;errfunc = ef;  status = luaD_rawrunprotected(L, func, u);  if (status != 0) {  /* an error occurred? */    StkId oldtop = restorestack(L, old_top);    luaF_close(L, oldtop);  /* close eventual pending closures */    luaD_seterrorobj(L, status, oldtop);    L-&gt;nCcalls = oldnCcalls;    L-&gt;ci = restoreci(L, old_ci);    L-&gt;base = L-&gt;ci-&gt;base;    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;    L-&gt;allowhook = old_allowhooks;    restore_stack_limit(L);  }  L-&gt;errfunc = old_errfunc;  return status;}</code></pre><p>这个函数首先将一些需要保存以便以后进行错误恢复的值保存，然后调用函数luaD_rawrunprotected。</p><ol start="3"><li>在luaD_rawrunprotected中，</li></ol><pre><code>int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {  struct lua_longjmp lj;  lj.status = 0;  lj.previous = L-&gt;errorJmp;  /* chain new error handler */  L-&gt;errorJmp = &amp;lj;  LUAI_TRY(L, &amp;lj,    (*f)(L, ud);  );  L-&gt;errorJmp = lj.previous;  /* restore old error handler */  return lj.status;}</code></pre><p>可以看到的是，在Lua中，涉及到这些错误恢复的数据，实际上形成一个链条关系，这个函数首先将之前的错误链保存起来。而LUAI_TRY这个宏，会根据不同的编译器进行实现，比如C++中使用的try…catch，C中使用longjmp等。</p><ol start="4"><li>再来看看真正出错的时候是如何处理的。</li></ol><pre><code>void luaG_errormsg (lua_State *L) {  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */    StkId errfunc = restorestack(L, L-&gt;errfunc);    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);    setobjs2s(L, L-&gt;top, L-&gt;top - 1);  /* move argument */    setobjs2s(L, L-&gt;top - 1, errfunc);  /* push function */    incr_top(L);    luaD_call(L, L-&gt;top - 2, 1);  /* call it */  }  luaD_throw(L, LUA_ERRRUN);}</code></pre><p><strong>首先如果之前保存的errfunc不为空，则首先从Lua栈中得到该函数，如果判断这个地址存放的不是一个函数则直接抛出错误。否则将错误参数压入栈中调用该错误处理函数。最后调用LuaD_throw函数，这个函数与前面的LUAI_TRY宏是对应的。这样就可以回到原来保存的错误恢复地点，恢复调用前的Lua栈，继续执行下去，而不是导致宿主进程退出。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lua支持两种形式的函数调用，一种对调用过程的堆栈进行保护，即使中间过程出错，也不至于让进程退出，也就是pcall，一般在使用C调用Lua写的脚本函数时，都采用pcall方式。&lt;/p&gt;
&lt;p&gt;对比起一般的函数调用方式，pcall多做了这些事情：&lt;/p&gt;
&lt;p&gt;对函数调用前的
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua表的创建和初始化</title>
    <link href="https://bytemode.github.io/2018/12/13/lua%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://bytemode.github.io/2018/12/13/lua表的创建和初始化/</id>
    <published>2018-12-13T05:11:44.000Z</published>
    <updated>2018-12-13T05:21:36.681Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表的基本实现"><a href="#表的基本实现" class="headerlink" title="表的基本实现"></a>表的基本实现</h4><p>在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为数组部分和hash部分。比如：</p><pre><code>local t = {1,2,3,4,5}</code></pre><p>以上分配一个Lua数组，依次为1到5.</p><p>而如果要初始化hash部分，则需要指定key，有两种方式：</p><pre><code>local t = {a=&quot;test&quot;}local t = {[&quot;a&quot;]=&quot;test&quot;}</code></pre><p>以上都指定了key为”a”的元素对应的值是”test”（注意一些上面两种情况key分别可以加引号和不加引号的）。</p><h5 id="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："><a href="#现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：" class="headerlink" title="现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE："></a>现在可以来看Lua表创建相关的操作。涉及到这部分的，是两个OPCODE：</h5><ol><li><p>NEWTABLE指令。</p><p>指令域A指定的是所要创建的表在Lua栈中的地址，而B,C则分别指定的是创建表时数组和hash部分的初始大小。</p></li><li><p>SETLIST指令。</p><p>需要特别说明的是，这个指令仅能用于初始化Lua表的数组部分时使用，hash部分没有作用。指令域A同样指定的是所要初始化的表在Lua栈中的地址，B指定的是初始化时数组的数量，而C指定的是BLOCK的数量。这里需要做一个说明。在Lua中有一个特殊的常量，叫FPF（fields per flush），可以简单的理解为，每次调用SETLIST指令时，写入数组的数量最多可以有多少，Lua中这个常量定义为50.于是，假如这里要初始化一个有60个元素的数组，那么将会拆分成两个SETLIST指令，第一个SETLIST指令，B为50，C为1，而第二个SETLIST指令，B为10而C为0.</p></li></ol><h5 id="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"><a href="#实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。" class="headerlink" title="实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。"></a>实际上，SETLIST指令还是有点复杂的。需要再继续了解一下几个知识点。</h5><ol><li>lopcodes.h中对这个指令的注释为：</li></ol><pre><code>OP_SETLIST,/*   A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B        */</code></pre><p>需要注意的是，A在这里既指定了表的栈位置，还有另一层含义从”=”右边可知，A在栈中紧跟着的数据是需要初始化给A数组的数据，所以A在这个指令中负担了两个数据的指示。换言之，当在A位置创建了这个Lua表之后，紧跟着这个Lua表的数据（数量由B指定）则是准备初始化给Lua表的数据。</p><ol><li>Lua还要处理某些情况下，数组元素可变的情况，比如:</li></ol><pre><code>local t = {func()}</code></pre><p>可以看到，此时数组元素的数量是不确定的，依赖于函数的返回值，而当解析到这个点时，也并不知道func的具体情况。Lua在这里的处理是将B置为0，表示从A+1位置开始直到这个函数栈的栈顶位置之间的元素全部用来初始化这个Lua表的数组部分。</p><ol start="2"><li>C也有可能为0，但是这种情况很少有，仅当初始化数组的数量非常大的时候出现，这里就不做分析了（因为要模拟这种情况有些蛋疼）。</li></ol><h4 id="Lua源码中相关的实现。"><a href="#Lua源码中相关的实现。" class="headerlink" title="Lua源码中相关的实现。"></a>Lua源码中相关的实现。</h4><p>分析Lua表创建部分的入口函数是lparser.c中的constructor函数。<br>首先，函数调用pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);生成一个NEWTABLE指令，注意在这里，B/C部分都是0，从前面的分析知道，这两部分分别指定的是Lua表的数组和hash部分的初始尺寸，因为在这里这两部分的大小并不知道，所以先填0，而保存在pc中是要保存这个生成的NEWTABLE指令，后面需要对B/C部分进行改写，填充数组和hash部分的尺寸。</p><p>紧跟着，在解析Lua表初始化的整个流程中，使用了结构体ConsControl：</p><pre><code>struct ConsControl {  expdesc v;  /* last list item read */  expdesc *t;  /* table descriptor */  int nh;  /* total number of `record&#39; elements */  int na;  /* total number of array elements */  int tostore;  /* number of array elements pending to be stored */};</code></pre><p>每一项的含义分别是，v表示的是上一个解析到表元素，它可能是一个key-value形式的赋值（此时是初始化一个hash元素），也有可能是单独的元素（此时是初始化一个数组元素）；t是一个指针，存放的是待初始化的Lua表；nh和na分别表示表的hash和数组部分尺寸，解析过程中将用这两个变量记录以便在最后重新填充前面的NEWTABLE的B/C部分；tostore则是存放的当前已经有多少数组元素待存放到Lua表中，当这个值达到FPF时，根据上面的分析则生成一个SETLIST指令，然后重新值0进入下一个元素的处理。</p><pre><code>   checknext(ls, &#39;{&#39;);   do {      lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);      if (ls-&gt;t.token == &#39;}&#39;) break;      closelistfield(fs, &amp;cc);      switch(ls-&gt;t.token) {        case TK_NAME: {  /* may be listfields or recfields */          luaX_lookahead(ls);         if (ls-&gt;lookahead.token != &#39;=&#39;)  /* expression? */           listfield(ls, &amp;cc);         else           recfield(ls, &amp;cc);         break;       }       case &#39;[&#39;: {  /* constructor_item -&gt; recfield */         recfield(ls, &amp;cc);         break;       }       default: {  /* constructor_part -&gt; listfield */         listfield(ls, &amp;cc);         break;       }     }   } while (testnext(ls, &#39;,&#39;) || testnext(ls, &#39;;&#39;));   check_match(ls, &#39;}&#39;, &#39;{&#39;, line);   lastlistfield(fs, &amp;cc);   SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */   SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh));  /* set initial table size */</code></pre><p>这个分析过程的主体部分，是一个循环，循环的终止条件是遇到了”}”符号，则该数组的初始化部分完成。<br>每次循环做以下的事情：</p><ol><li><p>调用closelistfield函数。</p><p>它是对数组元素做处理。首先将上一个分析到的数组元素，写入到当前的Lua栈中，这一点可以结合前面分析SETLIST指令来看。同时，如果当前的tostore数量达到FPF时，则生成SETLIST指令，这一点前面也做了分析。</p></li><li><p>然后就是两种情况的处理：</p><p>hash和数组部分，可以参看最开始Lua表初始化的语法就能知道什么语法是用于初始化hash部分，什么语法是初始化数组部分的了。分别调用的是recfield和listfield函数。</p></li></ol><p>listfield函数相对简单，需要判断当前表的数组元素是不是超过了限制，同时增加na和tostore计数。</p><p>recfield稍微复杂一点，还涉及到另一个指令SETTABLE，暂时跳过下一节再解释，现在知道它肯定会增加na计数就可以了。</p><ol start="3"><li>最后，由于初始化Lua表时，不同的元素之间是以”,”或者”;”做分割的，所以在遇到”}”退出循环之后，还有最后一个元素没有处理，于是还要调用lastlistfield函数进行处理。</li></ol><p>lastlistfield函数要处理的情况，就是前面分析过的，初始化过程中是不是遇到了函数返回值的情况，如果有则生成的SETLIST指令的域B要为0.</p><ol start="4"><li>最后就是根据分析过程中得到的na，nh数量重新填充NEWTABLE指令的B/C域了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;表的基本实现&quot;&gt;&lt;a href=&quot;#表的基本实现&quot; class=&quot;headerlink&quot; title=&quot;表的基本实现&quot;&gt;&lt;/a&gt;表的基本实现&lt;/h4&gt;&lt;p&gt;在Lua中，表是唯一的数据结构，可以使用它，模拟hash表，数组，链表，树等一切常用的数据结构。Lua表分为
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua require机制</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%20require%E6%9C%BA%E5%88%B6/"/>
    <id>https://bytemode.github.io/2018/12/12/lua require机制/</id>
    <published>2018-12-12T13:45:37.000Z</published>
    <updated>2018-12-12T13:46:33.620Z</updated>
    
    <content type="html"><![CDATA[<p>require(modname)</p><p>加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.</p><p>如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(loader).</p><p>要找到一个加载器,require首先查询package.preloaded[modname].如果它有值,该值(应该是一个函数)就是加载器.</p><p>如果没值require使用package.path中存储的路径查找一个Lua的加载器.如果该查找也失败,它使用package.cpath中</p><p>存储的路径查找一个C语言加载器(C loader).如果还是失败,它尝试使用all-in-one加载器(如下)</p><p>当加载一个C库的时候,require首先使用动态链接工具将应用程序与库连接起来.之后它尝试找到一个该库中的C函数,该函数要被当做加载器使用.这个C函数的名称是字符串”luaopen_”连接着复制的模块名(模块名称中的每个点号”.”都被替换为一个下划线).此外,如果模块名称含有连字符”-“,则第一个连字符的前缀(包括连字符)都被移除.比如,如果模块名称是a.v1-b.c,则函数名称将是luaopen_b_c.</p><p>如果require即没有为模块找到一个Lua库也没有为模块找到一个C库,他将调用all-in-one加载器.该加载器为给定模块的根名称查找C路径找到对应库(原文:this loader searches the C path for a library for the root name of the given module).例如,当require a.b.c时,它将为a查找一个库.如果找到,它查询该库内部为子模块找到一个开放函数(open function);在我们这个例子中将会是luaopen_a_b_c.使用这个便利机制(facility),一个包可以将几个子模块打包进单个的库中,同时每个子模块保存着它本来的开放函数.</p><p>一旦找到一个加载器,require使用单个的参数modname调用加载器.如果加载器返回任何值,require将其赋值给package.loaded[modname].</p><p>如果加载器没有返回值且没有给package.loaded[modname]赋与任何值,则require为该条目赋值为true.</p><p>无论如何,require返回package.loaded[modname]的最终值.</p><p>如果加载或者运行模块有任何错误,或者他不能为模块找到一个加载器,则require发出一个错误信号.</p><p>require函数的实现原理如下:</p><ol><li>–require 函数的实现  </li><li>function require(name)  </li><li>​    if not package.loaded[name] then    –是否在package.loaded中存在name</li><li>​        local loader = findloader(name) –不存在则查找加载器 </li><li>​        if loader == nil then  </li><li>​            error(“unable to load module” .. name)  </li><li>​        end  </li><li>​        package.loaded[name] = true     –加载器不存在 设置true</li><li>​        local res = loader(name)        –加载</li><li>​        if res ~= nil then  </li><li>​            package.loaded[name] = res  –加载返回的值给你 package.loaded</li><li>​        end  </li><li>​    end  </li><li>​    return package.loaded[name]         –返回 package.loaded[name]</li><li>end  </li></ol><p>package.cpath</p><p>由require使用查找C加载器的路径</p><p>Lua初始化C路径package.cpath的方法与初始化Lua路径package.path的相同,使用LUA_CPATH中的环境变量(另外一个默认的路径在luaconf.h中定义)</p><p>package.loaded</p><p>一个用于控制哪些模块已经加载的表,该表由require使用.当require一个模块名为modname的模块且package.loaded[modname]不为false时,require仅返回package.loaded[modname]存储的值.</p><p>package.loadlib(libname,funcname)</p><p>使用C库libname动态链接到宿主程序.在这个库中,寻找函数funcname并将该函数作为一个C函数返回.(所以,funcname必须遵守协议(参见lua_CFunction)).</p><p>这是一个底层函数.它完全绕过了package和module系统.与require不同,它不执行任何路径查找且不自动添加扩展名.libname必须是C库中完整的文件名,如果必要的话还要包含路径和扩展名.funcname必须是原封不动的C库中导出的名字(这可能取决于使用的C编译器和链接器).</p><p>这个函数不被ANSI C支持.就其本身而言,它只在一些平台上才能使用(Windows,Linux,Mac OS X,Solaris,BSD,加上其他支持dlfcn标准的Unix系统)</p><p>package.path</p><p>require用于查找Lua加载器的路径</p><p>在启动时,Lua使用环境变量LUA_PATH或者如果环境变量未定义就使用luaconf.h中定义的默认值来初始化该值.环境变量中的任何”::”都被替换为默认路径.</p><p>路径是一系列由分号隔开的模板(templates).对于每个模板,require将每个模板中的问号替换为filename,filename是modname中每个点都被替换成”目录分隔符”(比如Unix中的”/“)(这句感觉翻译不准确,原文:For each template,require will change each interrogation mark in the template by filename,which is modname with each dot replaced by a “directory separator”(such as “/“ in Unix));之后他将加载产生的文件名.因此,举个例子,如果Lua路径是”./?.lua;./?.lc;/usr/local/?/init.lua”,为模块foo查找一个Lua加载器将会尝试以如下顺序加载文件./foo.lua,./foo.lc和/usr/local/foo/init.lua</p><p>package.preload</p><p>为特定模块存储加载器的一个表(参见require)</p><p>package.seeall(module)</p><p>为module设置一个元表,module的__index只想全局环境(global environment),以便该module继承全局环境中的值.作为函数module中的一个选项来使用.</p><p>在Programming Lua中是这么讲的:</p><p>默认情况下,module不提供外部访问.必须在调用它之前,为需要访问的外部函数或模块声明适当的局部变量.也可以通过继承来实现外部访问,只需在调用module时附加一个选项package.seeall.这个选项等价于如下代码:</p><ol><li>setmetatable(M,{__index = _G})  </li></ol><p>因而只需这么做:</p><ol><li>module(…,package.seeall)  </li></ol><p>module(name,[,…])</p><p>创建一个模块.如果在package.loaded[name]中有表,该表便是创建的模块.否则,如果有一个全局表t其名称与给定名称相同,则该全局表便是创建的模块.否则创建一个新的表t</p><p>lua中import和require的区别</p><p>载入一个模块</p><p>import() 与 require() 功能相同，但具有一定程度的自动化特性。</p><p>假设有如下的目录结构：</p><p>app/</p><p>app/classes/</p><p>app/classes/MyClass.luaapp/classes/MyClassBase.luaapp/classes/data/Data1.luaapp/classes/data/Data2.lua</p><p>MyClass 中需要载入 MyClassBase 和 MyClassData。如果用 require()，MyClass 内的代码如下：</p><p>local MyClassBase = require(“app.classes.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = require(“app.classes.data.Data1”)</p><p>local Data2 = require(“app.classes.data.Data2”)</p><p>假如将 MyClass 及其相关文件换一个目录存放，那么就必须修改 MyClass 中的 require() 命令，否则将找不到模块文件。</p><p>而使用 import()，只需要如下写：</p><p>local MyClassBase = import(“.MyClassBase”)</p><p>local MyClass = class(“MyClass”, MyClassBase)</p><p>local Data1 = import(“.data.Data1”)</p><p>local Data2 = import(“.data.Data2”)</p><p>当在模块名前面有一个”.” 时，import() 会从当前模块所在目录中查找其他模块。因此 MyClass 及其相关文件不管存放到什么目录里，都不再需要修改 MyClass 中的 import() 命令。这在开发一些重复使用的功能组件时，会非常方便。</p><p>可以在模块名前添加多个”.” ，这样 import() 会从更上层的目录开始查找模块。</p><p>不过 import() 只有在模块级别调用（也就是没有将 import() 写在任何函数中）时，才能够自动得到当前模块名。如果需要在函数中调用 import()，那么就需要指定当前模块名：</p><p># MyClass.lua</p><p># 这里的 … 是隐藏参数，包含了当前模块的名字，所以最好将这行代码写在模块的第一行</p><p>local CURRENT_MODULE_NAME = …</p><p>local function testLoad() local MyClassBase = import(“.MyClassBase”, CURRENT_MODULE_NAME)</p><p># 更多代码</p><p>end</p><p>Parameters</p><p>string moduleName 要载入的模块的名字</p><p>[string currentModuleName]</p><p>当前模块名</p><p>Returns</p><p>module</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;require(modname)&lt;/p&gt;
&lt;p&gt;加载给定的模块.函数首先检查表package.loaded来判定modname是否已经存在.&lt;/p&gt;
&lt;p&gt;如果存在,则require返回package.loaded[modname]所存储的值否则它尝试为模块找到一个加载器(
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua错误跟踪</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E9%94%99%E8%AF%AF%E8%B7%9F%E8%B8%AA/"/>
    <id>https://bytemode.github.io/2018/12/12/lua错误跟踪/</id>
    <published>2018-12-12T13:35:21.000Z</published>
    <updated>2018-12-12T14:47:33.220Z</updated>
    
    <content type="html"><![CDATA[<p>pcall() xpcall()  debug.traceback() debug.debug() assert()</p><p>错误</p><p>Errare humanum est（拉丁谚语：犯错是人的本性）。所以我们要尽可能的防止错误的发生，Lua经常作为扩展语言嵌入在别的应用中，所以不能当错误发生时简单的崩溃或者退出。相反，当错误发生时Lua结束当前的chunk并返回到应用中。</p><p>当Lua遇到不期望的情况时就会抛出错误，比如：两个非数字进行相加；调用一个非函数的变量；访问表中不存在的值等（可以通过metatables修改这种行为，后面介绍）。你也可以通过调用error函数显式地抛出错误，error的参数是要抛出的错误信息。</p><p>print “enter a number:”</p><p>n = io.read(“*number”)</p><p>if not n then error(“invalid input”) end</p><p>Lua提供了专门的内置函数assert来完成上面类似的功能：</p><p>print “enter a number:”</p><p>n = assert(io.read(“*number”), “invalid input”)</p><p>assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。第二个参数是可选的。注意，assert会首先处理两个参数，然后才调用函数，所以下面代码，无论n是否为数字，字符串连接操作总会执行：</p><p>n = io.read()</p><p>assert(tonumber(n), “invalid input: “ .. n .. “ is not a number”)</p><p>当函数遇到异常有两个基本的动作：返回错误代码或者抛出错误。选择哪一种方式，没有固定的规则，不过基本的原则是：对于程序逻辑上能够避免的异常，以抛出错误的方式处理之，否则返回错误代码。</p><p>例如sin函数，假定我们让sin碰到错误时返回错误代码，则使用sin的代码可能变为：</p><p>local res = math.sin(x)</p><p>if not res then      – error</p><p>​    …</p><p>当然，我们也可以在调用sin前检查x是否为数字：</p><p>if not tonumber(x) then     – error: x is not a number</p><p>​    …</p><p>而事实上，我们既不是检查参数也不是检查返回结果，因为参数错误可能意味着我们的程序某个地方存在问题，这种情况下，处理异常最简单最实际的方式是抛出错误并且终止代码的运行。</p><p>再来看一个例子。io.open函数用于打开文件，如果文件不存在，结果会如何？很多系统中，我们通过“试着去打开文件”来判断文件是否存在。所以如果io.open不能打开文件（由于文件不存在或者没有权限），函数返回nil和错误信息。依据这种方式，我们可以通过与用户交互（比如：是否要打开另一个文件）合理地处理问题：</p><pre><code>local file, msgrepeat    print &quot;enter a file name:&quot;    local name = io.read()    if not name then return end     -- no input    file, msg = io.open(name, &quot;r&quot;)    if not file then print(msg) enduntil file</code></pre><p>如果你想偷懒不想处理这些情况，又想代码安全的运行，可以使用assert：</p><p>file = assert(io.open(name, “r”))</p><p>Lua中有一个习惯：如果io.open失败，assert将抛出错误。</p><p>file = assert(io.open(“no-file”, “r”))</p><p>​       –&gt; stdin:1: no-file: No such file or directory</p><p>注意：io.open返回的第二个结果（错误信息）会作为assert的第二个参数。</p><p>虽然你可以使用任何类型的值作为错误信息，通常情况下，我们使用字符串来描述遇到的错误。如果遇到内部错误（比如对一个非table的值使用索引下标访问）Lua将自己产生错误信息，否则Lua使用传递给error函数的参数作为错误信息。不管在什么情况下，Lua都尽可能清楚的描述问题发生的缘由。</p><p>local status, err = pcall(function () a = ‘a’+1 end)</p><p>print(err)</p><p>–&gt; stdin:1: attempt to perform arithmetic on a string value</p><p>local status, err = pcall(function () error(“my error”) end)</p><p>print(err)</p><p>–&gt; stdin:1: my error</p><p>例子中错误信息给出了文件名（stdin）与行号。</p><p>函数error还可以有第二个参数，表示错误发生的层级。比如，你写了一个函数用来检查“error是否被正确调用”：</p><pre><code>function foo (str)    if type(str) ~= &quot;string&quot; then       error(&quot;string expected&quot;)    end    ...end</code></pre><p>可有人这样调用此函数：</p><p>foo({x=1})</p><p>Lua会指出发生错误的是foo而不是error，实际上，错误是调用error时产生的。为了纠正这个问题，修改前面的代码让error报告错误发生在第二级（你自己的函数是第一级）如下：</p><pre><code>function foo (str)    if type(str) ~= &quot;string&quot; then       error(&quot;string expected&quot;, 2)    end    ...end</code></pre><p>当错误发生的时候，我们常常希望了解详细的信息，而不仅是错误发生的位置。若能了解到“错误发生时的栈信息”就好了，但pcall返回错误信息时，已经释放了保存错误发生情况的栈信息。因此，若想得到tracebacks，我们必须在pcall返回以前获取。Lua提供了xpcall来实现这个功能，xpcall接受两个参数：调用函数、错误处理函数。当错误发生时，Lua会在栈释放以前调用错误处理函数，因此可以使用debug库收集错误相关信息。有两个常用的debug处理函数：debug.debug和debug.traceback，前者给出Lua的提示符，你可以自己动手察看错误发生时的情况；后者通过traceback创建更多的错误信息，也是控制台解释器用来构建错误信息的函数。你可以在任何时候调用debug.traceback获取当前运行的traceback信息：</p><p>print(debug.traceback())</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pcall() xpcall()  debug.traceback() debug.debug() assert()&lt;/p&gt;
&lt;p&gt;错误&lt;/p&gt;
&lt;p&gt;Errare humanum est（拉丁谚语：犯错是人的本性）。所以我们要尽可能的防止错误的发生，Lua经常作为扩展语言
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua用法2</title>
    <link href="https://bytemode.github.io/2018/12/12/lua%E7%94%A8%E6%B3%952/"/>
    <id>https://bytemode.github.io/2018/12/12/lua用法2/</id>
    <published>2018-12-12T13:33:40.000Z</published>
    <updated>2018-12-12T13:34:15.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="loadstring-load"><a href="#loadstring-load" class="headerlink" title="loadstring load"></a>loadstring load</h1><p>从给定的字符串得到块(函数)。lua5.3使用load()替换loadstring(). </p><p>一般如下用法：<br><code>assert(loadstring(script))()</code><br><code>f = loadstring(&quot;a = 1&quot;)</code><br>语义上相当于：<br><code>f = loadstring(&quot;function() a = 1 end&quot;)</code><br>复杂用法如下：<br>下面是动态加载字符串，并执行，结果为一个table       </p><pre><code>local script = &quot;localee={[0]={id=0,lv=5,text=&#39;yy&#39;},[1]={id=1,lv=3,text=&#39;zz&#39;}}  return ee&quot;  local tb=assert(loadstring(script))()  print(tb[0].text)  </code></pre><p>下面是动态加载字符串，并执行，结果为方法</p><pre><code>local addscript=&quot;function dadd(a,b) return a+b  end&quot;  assert(loadstring(addscript))()  print(tostring(dadd(2,3)))  </code></pre><pre><code>local f = load(&quot;a=1+2&quot;)print(type(f))  --function</code></pre><h1 id="loadfile"><a href="#loadfile" class="headerlink" title="loadfile"></a>loadfile</h1><p>loadfile 编译Lua外部代码块，但不会运行代码，将会以函数的形式返回编译结果.返回编译结果函数.</p><pre><code>local f = laodfile(&quot;a.lua&quot;)print(type(f)) --function</code></pre><h1 id="dofile"><a href="#dofile" class="headerlink" title="dofile"></a>dofile</h1><p>dofile 直接编译运行Lua外部代码块，并不返回任何结果。编译错误会返回nil.  </p><pre><code>function dofile(filename)    local func = assert(loadfile(filename))    func()end</code></pre><h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><p><code>load (chunk [, chunkname [, mode [, env]]])</code><br>加载一个代码块。<br>如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。</p><p>如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。<br>chunkname 在错误消息和调试消息中，用于代码块的名字。<br>字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 “b” （只能是二进制代码块）， “t” （只能是文本代码块）， 或 “bt” （可以是二进制也可以是文本）。 默认值为 “bt”。       </p><h1 id="ENV"><a href="#ENV" class="headerlink" title="_ENV"></a>_ENV</h1><p>引用一个叫 var 的自由名字在句法上都被翻译为 _ENV.var 。 此外，每个被编译的 Lua 代码块都会有一个外部的局部变量叫 _ENV。</p><p> 这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。    当编译器在转译自由名字时所用到的 _ENV ， 指的是你的程序在那个点上可见的那个名为 _ENV 的变量<br>被 _ENV 用于值的那张表被称为 环境。   </p><p>Lua保有一个被称为 全局环境 特别环境。它被保存在 C 注册表的一个特别索引下。<br>在 Lua 中，全局变量 _G 被初始化为这个值。 </p><p>当 Lua 加载一个代码块，_ENV 这个上值的默认值就是这个全局环境。         因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项        （它们也被称为 全局变量 ）。<br>此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。 你可以用 load （或 loadfile）加载代码块，并赋予它们不同的环境。 （在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境。）    </p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>如果 index 是个数字， 那么返回参数中第 index 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，index 必须是字符串 “#”， 此时 select 返回参数的个数。 </p><pre><code>do      function foo(...)          for i = 1, select(&#39;#&#39;, ...) do //get the count of the params              local arg = select(i, ...);//select the param              print(&quot;arg&quot;, arg);          end      end      foo(1, 2, 3, 4);  end</code></pre><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><p><code>next (table [, index])</code><br>允许程序遍历表的所有字段。它的第一个参数是一个表，它的第二个参数是该表的索引。接下来返回表及其关联值的一个索引。</p><pre><code>local tee = {1, 3, 4, 6, 8}t = {3,7,10,17, pi=3.14159, banana=&quot;yellow&quot;}for key,value in next,t,nil do print(key,value)endfunction pairs (t)    return next, t, nilendfor k, v in pairs(t) do    print(k, v)end</code></pre><h1 id="pcall"><a href="#pcall" class="headerlink" title="pcall"></a>pcall</h1><p><code>pcall (f [, arg1, ···])</code></p><p>传入参数，以 保护模式 调用函数 f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。</p><p><code>local ret, msg = pcall(function(i) print(i) end, 33)</code></p><h1 id="xpcall"><a href="#xpcall" class="headerlink" title="xpcall"></a>xpcall</h1><p><code>xpcall (f, msgh [, arg1, ···])</code><br>这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。</p><pre><code>local function __TRACKBACK__(errmsg)    local track_text = debug.traceback(tostring(errmsg), 6);    print(track_text, &quot;LUA ERROR&quot;);    return false;endlocal function trycall(func, ...)    local args = { ... };    return xpcall(function() func(unpack(args)) end, __TRACKBACK__);endlocal function test(aaa)    print(&quot;#&quot;..aaa)endtrycall(test, nil)</code></pre><h1 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h1><p>使用[[ sun feng sunfeng ]]  定义多行文本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;loadstring-load&quot;&gt;&lt;a href=&quot;#loadstring-load&quot; class=&quot;headerlink&quot; title=&quot;loadstring load&quot;&gt;&lt;/a&gt;loadstring load&lt;/h1&gt;&lt;p&gt;从给定的字符串得到块(函数)。lua
      
    
    </summary>
    
      <category term="lua" scheme="https://bytemode.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="https://bytemode.github.io/tags/lua/"/>
    
  </entry>
  
</feed>
