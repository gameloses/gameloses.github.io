---
title: stl排序
comments: true
date: 2016-01-07 19:53:21
tags:
- stl
categories:
- stl
---

STL的sort()算法，数据量大时采用Quick Sort，分段递归排序，一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷，就改用Insertion Sort。如果递归层次过深，还会改用Heap Sort。本文先分别介绍这个三个Sort，再整合分析STL sort算法(以上三种算法的综合) -- Introspective Sorting(内省式排序)。

#### Insertion Sort

Insertion Sort是《算法导论》一开始就讨论的算法。它的基本原理是：将初始序列的第一个元素作为一个有序序列，然后将剩下的N-1个元素按关键字大小依次插入序列，并一直保持有序。这个算法的复杂度为O(N^2)，最好情况下时间复杂度为O(N)。在数据量很少时，尤其还是在序列“几近排序但尚未完成”时，有着很不错的效果。

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

Insertion Sort

void InsterSort(int a[], int n)

{

​    for (int i = 1; i < n; ++i)

​    {

​        int temp = a[i];

​        int j = i - 1;

​        for (; j >= 0 && a[j] > temp; --j)

​        {

​            a[j + 1] = a[j];

​        }

​        a[j + 1] = temp;

​    }

}



上述函数之所以命名为unguarded_x是因为，一般的Insertion Sort在内循环原本需要做两次判断，判断是否相邻两元素是”逆转对“，同时也判断循环的行进是否超过边界。但由于上述所示的源代码会导致最小值必然在内循环子区间的边缘，所以两个判断可合为一个判断，所以称为unguarded_。省下一个判断操作，在大数据量的情况下，影响还是可观的。

二、Quick Sort

Quick Sort是目前已知最快的排序法，平均复杂度为O(NlogN)，可是最坏情况下将达O(N^2)。

Quick Sort算法可以叙述如下。假设S代表将被处理的序列：

1、如果S的元素个数为0或1，结束。

2、取S中的任何一个元素，当做枢轴(pivot) v。

3、将S分割为L、R两段，使L内的每一个元素都小于或等于v，R内的每一个元素都大于或等于v。

4、对L、R递归执行Quick Sort。

Median-of-Three（三点中值）

因为任何元素都可以当做枢轴(pivot)，为了避免元素输入时不够随机带来的恶化效应，最理想最稳当的方式就是取整个序列的投、尾、中央三个元素的中值(median)作为枢轴。这种做法称为median-of-three partitioning。

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

Quick Sort

void quickSort(int *a, int low, int hight)

{

​    if (low < hight)

​    {

​        int povit = partition(a, low, hight);

​        quickSort(a, low, povit - 1);

​        quickSort(a, povit + 1, hight);

​    }

}



Partitioning（分割）

分割方法有很多，以下叙述既简单又有良好成效的做法。令first向尾移动，last向头移动。当*first大于或等于pivot时停下来，当*last小于或等于pivot时也停下来，然后检验两个迭代器是否交错。未交错则元素互相，然后各自调整一个位置，再继续相同行为。若交错，则以此时first为轴将序列分为左右两半，左边值都小于或等于pivot，右边都大于等于pivot

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

Partitioning



int partition(int *a, int low, int hight) //分割算法

{

​    int povit = a[low];

​    while (low < hight)

​    {

​        while (low < hight && a[hight] >= povit) //高位开始寻找小数 放在低位

​        {

​            --hight;

​        }

​        a[low] = a[hight];

​        while (low < hight && a[low] <= povit) //低位开始寻找大数 放在高位

​        {

​            ++low;

​        }

​        a[hight] = a[low];

​    }

​    a[low] = povit; //设置轴

​    return low;

}





三、Heap Sort

STL中有一个partial_sort()算法。

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

Heap Sort



partial_sort的任务是找出middle-first个最小元素，因此，首先界定出区间[first,middle)，并利用make_heap()将它组织成一个max-heap，然后就可以讲[middle,last)中的每一个元素拿来与max-heap的最大值比较(max-heap的最大值就在第一个元素)；如果小于该最大值，就互换位置并重新保持max-heap的状态。如此一来，当我们走遍整个[middle,last)时，较大的元素都已经被抽离出[first,middle)，这时候再以sort_heap()将[first,middle)做一次排序。

由于篇幅有限，本文不再阐述堆的具体实现，建议海量Google。

四、IntroSort

不当的枢轴选择，导致不当的分割，导致Quick Sort恶化为O(N^2)。David R. Musser于1996年提出一种混合式排序算法，Introspective Sorting。其行为在大部分情况下几乎与 median-of-3 Quick Sort完全相同。但是当分割行为(partitioning)有恶化为二次行为倾向时，能自我侦测，转而改用Heap Sort，使效率维持在O(NlogN)，又比一开始就使用Heap Sort来得好。大部分STL的sort内部其实就是用的IntroSort。

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

Intro Sort



函数一开始就判断序列大小，通过个数检验之后，再检测分割层次，若分割层次超过指定值，就改用partial_sort()，即Heap sort。都通过了这些校验之后，便进入与Quick Sort完全相同的程序。

当__introsort_loop()结束，[first,last)内有多个“元素个数少于或等于”16的子序列，每个序列有相当程序的排序，但尚未完全排序（因为元素个数一旦小于 __stl_threshold，就被中止了）。回到母函数，再进入__final_insertion_sort()：

![img](http://note.youdao.com/src/458492E1915E4AE9BF7022DBE1496EC9)

View Code



必须要看清楚的是，__final_insertion_sort()之前，经过__introsort_loop()的整个序列可以看成是一个个元素个数小于或等于16的子序列(注意子序列长度是不等的)，且这些子序列不但内部有相当程度排序，且更重要的是以子序列与子序列之间也是“递增”的，意思是前一个子序列中的元素都是小于后一个子序列中的元素的，所以这个时候运用insertion_sort()，效率可是相当高的。

 

/---------------------------------------华丽的分割线--------------------------------------/

 

关于IntroSort的测试。

细看__introsort_loop()，是不是觉得他的快排的写法很怪，为什么不能直接这样写呢？

if (last - first > __stl_threshold){		// > 16 ... ... __introsort_loop(cut,last,value_type(first), depth_limit); __introsort_loop(first,cut,value_type(first), depth_limit);

于是，我做了一次测试，结果如下图：

![img](http://note.youdao.com/src/5768FCF2B1724017A348D9623F6BA4F0)

测试结果发现，如果不像STL中那么写，其实在数组还比较小时，还快那么一丁点，

并且即使数组变大，在一百万条记录时也只快0.3秒，唔。。也许STL更注重于大型数据吧，

不过像他那么写，实在是牺牲了代码的可读性。

 

为什么是Insertion Sort，而不是Bubble Sort。

选择排序(Selection sort)，插入排序(Insertion Sort)，冒泡排序(Bubble Sort)。这三个排序是初学者必须知道的三个基本排序方式，且他们速度都不快 -- O(N^2)。选择排序就不说了，最好情况复杂度也得O(N^2)，且还是个不稳定的排序算法，直接淘汰。

可冒泡排序和插入排序相比较呢？

首先，他们都是稳定的排序算法，且最好情况下都是O(N^2)。那么我就来对他们的比较次数和移动元素次数做一次对比（最好情况下），如下：

插入排序：比较次数N-1，移动元素次数2N-1。

冒泡排序：比较次数N-1，无需移动元素。(注：我所说的冒泡排序在最基本的冒泡排序基础上还利用了一下旗帜的方式，即寻访完序列未发生数据交换时则表示排序已完成，无需再进行之后的比较与交换动作）

那么，这样看来冒泡岂不是是更快，我可以把上述的__final_insertion_sort()函数改成一个__final_bubble_sort()，把每个子序列分别进行冒泡排序，岂不是更好？

事实上，具体实现时，我才发现这个想法错了，因为写这么一个__final_bubble_sort()，我没有办法确定每个子序列的大小，可我还是不甘心呐，就把bubble_sort()插在__introsort_loop()最后，这样确实是每个子序列都用bubble_sort()又排序了一次，可是测试结果太惨了，由此可以看书Bubble Sort在“几近排序但尚未完成”的情况下是没多少改进作用的。

 

为什么不直接用Heap Sort

堆排序将所有的数据建成一个堆，最大的数据在堆顶，它不需要递归或者多维的暂存数组。算法最优最差都是O(NlogN)，不像快排，如果你人品够差还能恶化到O(N^2)。当数据量非常大时（百万数据），因为快排是使用递归设计算法的，还可能发出堆栈溢出错误呢。

那么为什么不直接用Heap Sort？或者说给一个最低元素阈值（__stl_threshold)时也给一个最大元素阈值（100W），即当元素数目超过这个值时，直接用Heap Sort，避免堆栈溢出呢？

对于第一个问题，我测试了一下，发现直接用Heap Sort，有时还没有Quick Sort快呢，查阅《算法导论》发现，原来虽然Quick和Heap的时间复杂性是一样的，但堆排序的常熟因子还是大些的，并且堆排序过程中重组堆其实也不是个省时的事。

 

 

VS2010版STL中的sort竟比我自己写的快这么多？

首先，上文实现的这个Introsort是参照SGI STL写的，于是，我斗胆在VS2010中拿他与std:sort比了比快慢。于是就随机产生两个百万数据的vector用来测试。结果发现，VS中sort的速度竟是我的10倍以上的效率。顿时对微软萌生敬意，可是当我仔细翻看源码时.....

原来，microsoft的sort并没有比sgi的sort快。只是在排序vector时，microsoft把vector的本质数据“萃取”出来了。

即，取消了vector在++时的边界检查语句，把vector::iterator当指针一般使用。所以才在对vector排序时会比我自己写的introsort算法快那么多呢。





void heapAdjust(int* a, int s, int len) //s 为要调整的堆的根序号 len为树最后一个节点的序号

{

​    int root = a[s];

​    for (int i = 2 * s; i < len; i *= 2)

​    {

​        if (i < len && a[i] < a[i +1]) //存在右孩子 记录s的孩子中最大

​        {

​            i++;

​        }

​        if (root > a[i]) //最大孩子小与root 以为大根堆

​        {

​            break;

​        }

​        a[s] = a[i]; //大孩子调整为根

​        s = i;       //记录交换后孩子的位置  继续需找孩子i的孩子中最大的放到s处

​    }

​    a[s] = root;     //将root放在堆中合适的位置处

}

void heapSort(int *a, int len)

{

​    //整个树建大顶堆 len/2为最后一个堆的根序号

​    for (int i = len / 2; i > 0; --i)

​    {

​        heapAdjust(a, i, len);

​    }

​    //交换堆顶和最后一个元素 建堆

​    for (int j = len; j > 0; --j)

​    {

​        a[0] = a[1]; //a[1]为顶

​        a[1] = a[j];

​        a[j] = a[0];

​        heapAdjust(a, 1, j-1); //将剩余的元素建堆

​    }

}

