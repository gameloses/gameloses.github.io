---
title: cocos2dx橡皮擦
comments: true
date: 2018-01-09 17:27:06
tags:
- cocos2dx
categories:
- cocos2dx
---

#### 原理

先将要被擦除的像素渲染到 FrameBuffer中，然后使用 Alpha 为 0 的像素块与已有像素做混合，将已有的像素替换成 Alpha为0的像素即可完成擦除。所谓“擦除”，就是将要擦除的图片RGB和alpha值，全部去掉。可以通过两张图片的混合实现

**注意，这里说的“擦除”，准确的描述是“擦除到透明”。对于不透明画布（例如白色背景）的擦除，只需要使用画布的背景颜色进行绘制就行了**

我们并不需要真的去考虑 FrameBuffer 的建立和渲染，cocos2d-x 已经为我们准备好了 RenderTexture 类。

使用 RenderTexture ，我们可以方便地完成绘制工作，比使用 Shader 要灵活，弱点可能就是性能较低。

设置混合模式，可使用 Node 提供的 BlendFunc 这个预定义类型

#### 关于混合

[混合（blend）](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml) 发生在 OpenGL 将像素渲染 FrameBuffer 之前。我们使用的混合模式 `{GL_ONE, GL_ZERO}` 的含义如下：

完全使用源像素（橡皮擦）的内容，替换掉目标像素（被擦除画面）对应坐标的内容。

假设源像素（橡皮擦）的颜色值为 `Rs, Gs, Bs, As` ，目标像素的颜色值为 `Rd, Gd, Bd, Ad` ，那么使用上面的混合模式，最终的像素值为：

```
(Rs*1 + Rd*0), (Gs*1 + Gd*0), (Bs*1 + Bd*0), (As*1 + Ad*0)
```

从上面的公式可以看出，最终的结果与橡皮擦原来的颜色值完全相同

#### 源码

```
//启用触摸支持
this->setTouchMode(kCCTouchesOneByOne);
this->setTouchEnabled(true);
//... 其它初始化内容
//...
// 显示背景图片，方便查看“擦除到透明”效果
CCPoint center = ccp(visibleSize.width / 2 + origin.x, visibleSize.height / 2 + origin.y);
CCSprite* pSprite = CCSprite::create("HelloWorld.png");
pSprite->setPosition(center);
this->addChild(pSprite, 0);

// 创建一个橡皮擦，注意颜色的设置是全透明黑色
pEraser = CCDrawNode::create();
pEraser->drawDot(ccp(0, 0), 20, ccc4f(0, 0, 0, 0));
pEraser->retain();

// 创建画布，并显示它
pRTex = CCRenderTexture::create(visibleSize.width, visibleSize.height);
pRTex->setPosition(ccp(visibleSize.width/2, visibleSize.height/2));
this->addChild(pRTex, 10);

// 创建被擦除的内容，将其渲染到画布上
CCSprite* pBg = CCSprite::create("dirt.png");
pBg->setAnchorPoint(ccp(0.5,0.5));
pBg->setPosition(center);
pRTex->begin();
pBg->visit();
pRTex->end();

// 获取触摸坐标并移动橡皮擦到该坐标
CCPoint touchPoint = touch->getLocation();
pEraser->setPosition(touchPoint);

// 设置混合模式
ccBlendFunc blendFunc = { GL_ONE, GL_ZERO };
pEraser->setBlendFunc(blendFunc);

// 将橡皮擦的像素渲染到画布上，与原来的像素进行混合
pRTex->begin();
pEraser->visit();
pRTex->end();
```

#### 开源实现

git@github.com:bytemode/EraserSprite.git