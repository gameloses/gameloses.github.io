---
title: c++对象模型
comments: true
date: 2018-12-31 16:47:44
tags:
- c++
categories:
- c++
---

#### 关于对象

##### 加上封装后的布局成本

c语言中如下声明一个结构体

```
typedef struct point3d{ float x; float y; float z;}Point3d;
```

struct point3d 转化为class Point3d之后

```
class Point3d
{
    public:
      Point3d(float x = 0.0f, float y = 0.0f; float z = 0.0f)
        :_x(x),_y(y),_z(z){}
    private:
      float _x,_y,_y;
}
```

封装带来的布局成本增加了多少？实际是没有增加布局成本的。3个数据成员直接在class object内，member function在classs声明却不出现在class object中，所谓布局的成本主要由virtual引起的。

virtual function 机制用以支持运行时绑定（运行时多态）

virtual base class 机制支持多次出现在集成体系中的base class有一个单一的被共享的实例。

##### 基本c++对象模型

nostatic data members 被配置在class object之内，static data member存放在class object之外.

static 和nostatic function memners放在class object之外

virtual function的处理步骤：

1. 每个class产生出一堆指向virtual functions的指针，放在表格中，这个表格称为虚表virtual table
2. 每个class object 安插一个虚表指针vptr指向虚表（virtual table）.
3. vptr的设定和重置都由每个class的构造函数、拷贝赋值运算符、析构函数自动完成，每个class所关联的type_info object (用以支持runtime type identification, RTTI)也经由virtual table被指出，通常放在virtual table的第一个slot.

声明一个class Point然后查看其对象模型

```
class Point
{
    public:
      Point(float x);
      virtual ~Point();
      float x() const;
      static int PointCount();
    protected:
      virtual ostream& print(ostream& os) const;
      float _x;
      static int _point_count;
}
```

![Point对象模型](https://img-blog.csdnimg.cn/20190102143720741.png)

##### 加上继承

c++支持单一继承和多重继承.base class subobject的data members直接被放置在derived class object,也就是说子类对象中包含基类子对象.基类成员的改变都会导致继承类重新编译.对于虚基类则是扩展子类自己的vittual table维护virtual base class的位置。

```
class istream : virtual public ios{...};
class ostream : virtual public ios{...};
class iostream : public istream, public ostream{...};
```

在虚拟继承的情况下base class 不管在继承链中被派生多少次，永远只有一个实例存在即一个subobject.iostream之中只有virtual ios base class的一个实例.

##### NRV优化

函数返回基本是数据类型或者指针类型是通过eax寄存器进行传递的，返回对象对象则会进行命名返回值优化.以外部引用传参的形式去掉函数内部的局部对象构造。

```
X foo(){
    X xx
    X* px = new X();
    xx.foo(); //func是一个虚函数
    px->foo()
    delete px;
    rerurn xx
}
```

如上函数有可能内部转化为如下代码：

```
void foo(X &result){
    _result.X::X();
    
    px = _new(sizeof(X));
    if(px != 0){ px->X::X(); }
    
    func(&_result);//这里涉及到成员函数的语义
    
    (*px->vtbl[2])(px) //使用virtual机制扩展px->func()
    
    if(px != 0) {
        (*px->[1])(px); //扩展delete px
        _delete(p)
    }
    return;   
}
```

![NRV优化和虚函数调用](https://img-blog.csdnimg.cn/20190102143759346.png)

##### 指针类型

- 指针类型会指导编译器如何解释某个特定地址中内容及其大小
- void*的指针只能够持有一个地址，而不能够通过他操作他所指向的object
- cast是一种编译指令它不改变一个指针的内容，只影响被指出的大小和其内容的解释方式
- c++通过引用或者指针的方式支持多态，是因为他们不会引发任何与类型有关的内存委托，
- 当一个基类对象直接被初始化为一个子类对象是，子类对象会被切割以放入base type的内存中

#### 构造函数语义学

##### 默认构造函数被合成出来执行编译器的所需操作
如果类class A含有一个以上的类成员对象，编译器会扩张构造函数，在构造函数中安插代码，以成员类的声明顺序调用每个成员类的默认构造函数，这些代码被安插在用户代码之前.

有四种情况会造成编译器为未声明构造函数的类合成一个默认的构造函数，接着调用member object或者base class的默认构造函数，完成虚函数和虚基类机制。

1. 带有默认构造函数的成员类对象
2. 带有默认构造函数的基类
3. 带有virtual function的类，用来初始化vptr
4. 带有virtual base class的类，用来初始化vptr

#####  拷贝构造函数
类中没有任何member或者base class object带有拷贝构造函数，也没有任何的虚函数和虚基类，默认情况下 对象的初始化会展示按位拷贝，这样效率很高且安全.

当对一个object做显示初始化或者object被当做参数交给函数时以及函数返回一个object时（传参、返回值、初始化）构造函数会被调用。

copy 构造函数不展现按位逐次拷贝的时候有编译器产生出来，有四种情况不展现：

1. 当成员类中生命有copy constructor
2. 当基类中存在copy constructor
3. 类中含有virtual function
4. 类有virtual base class

1、2中编译器讲member或者bass class的拷贝构造哈数的调用安插到合成的拷贝构造函数中；3，4是为了对vptr重新初始化.

##### 在构造函数中调用memset或者memcopy会使vptr设置为0

```
class Shape{
	public:
		Shape(){ memset(this, 0, sizeof(Shape);)}
		virtual ~Shape();
}
```
编译器扩充构造函数的内容如下：

```
//扩充后的构造函数

Shape::Shape(){
	//vptr在用户代码之前被设定
	__vptr__Shape = __vtbl__Shape;
	//memset 会使vptr清0
	memset(this, 0, sizeof(Shape));
}
```

##### 初始化成员列表
编译器会操作初始化列表，以成员的声明顺序子构造函数内部在用户代码之前安插初始化代码.
当类含有一下四种情况的时候会需要使用成员初始化列表：
1. 初始化一个引用成员
2. 初始化一个constchengyuan 
3. 基类构造函数拥有参数
4. 成员类构造函数拥有参数

#### Data语义学


##### 数据成员的布局

`class X{};`一个空类它隐藏1byte的大小，他是被编译器安插进去的一个char,这使得这一class的两个object在内存中配置有独一无二的地址.

非静态的数据成员直接存放在每一个类对象中，对于继承而来的费静态成员也是如此。静态数据成员则放在程序的全局数据段，且只存在一份数据实例.

对成员函数的分析，会在整个class声明完成之后才会出现.

在同一个访问段中member的排列要符合较晚出现的成员在对象中有较高的地址，多个访问段中的数据成员是自由排列的.

##### 数据成员的访问

1. 静态数据成员只有一个实例放在程序的数据段，编译器会对每一个静态数据成员进行编码以获得一个独一无二的识别码
2. 非静态数据成员，会使用隐式类对象机制访问数据（this指针）成员函数的参数中隐藏了一个隐式对象指针.
3. 指向数据成员的指针，其offset值总是被加上1，这样可以使编译系统区分出“一个指向数据成员的指针，用以指出第一个成员”和“一个指向数据成员的指针，没有指出任何成员”.

##### 单一继承无virtual function下的内存布局
单一继承下无布局情况下class和struct的布局是一样的.

![单一继承无virtual function下的数据布局](https://img-blog.csdnimg.cn/20190103114837430.png)

##### 单一继承有virtaual function下的内存布局

![单一继承有虚函数](https://img-blog.csdnimg.cn/20190103115054914.png)

Point3d中含有基类的子对象Point2d subobject，子类数据成员放置在基类子对象之后。

##### 多重继承下的数据布局

类体系如下
```
class Point2d
{
	public:
		virtual ~Point2d(){};
	protected:
		float _x,_y;
};

class Point3d : public Point2d
{
	public:
	 //...
	 protected:
	 	float _z;
};

class Vertex
{
	public:
		virtual ~Vertex(){};
	protected:
	    Vertex *next;
}

class Vertex3d: public Point3d, public Vertex
{
	public:
	//...
	protected:
		float mumble;
}
```
![多重继承体系下的数据布局](https://img-blog.csdnimg.cn/20190103115456931.png)

要存取第二个基类中的数据成员，将会是怎样的情况需要付出额外的成本吗？不 ，成员的位置在编译期就时就固定了，因此存取数据成员知识一个简单的offset操作，就像单一继承一样简单--不管是经由一个指针或者引用或者是一个对象来存取.

##### 虚拟继承

对于虚拟继承主要的问题是如何存取class的共享部分,虚拟继承使用两种策略来实现：指针策略和offset策略.

###### 指针策略

为了指出共享类对象每个子类对象安插一些指针，每个指针指向虚基类。

![虚拟继承使用指针策略产生的布局](https://img-blog.csdnimg.cn/20190103130910339.png)

进一步的优化策略的实现：每一个class object如果有一个或者多个virtual base classes，就会由编译器安插一个指针指向virtual base class table.真正的虚基类指针放在虚基类表中.

###### offset策略

在虚函数表中放置虚基类的offset.

![虚拟继承offset策略](https://img-blog.csdnimg.cn/20190103132137522.png)

#### Function语义学

##### 虚函数

基类的指针或者引用寻址出一个子类对象，虚函数分配表格索引，vptr指向virtual table, virtual table中存放虚函数指针.

##### inline函数

inline是一个请求，编译器解说就必须认为它用一个表达式合理的将这个函数扩展开来，扩展期间使用实参代替形参，局部变量在封装的区域内名字唯一.

##### 函数的调用方式

1. 非静态成员函数
- 改函数签名安插this指针，变为一个非成员函数，可以使类对象调用.
- 调用对非静态成员的存取有this指针完成
- 通过name-maping 改为一个外部函数

```
float Point3d::getX()const{...}
extern getX_Point3dFv(const Point3d* this)

obj.getX()
等价于 getX_Point3dFv(&obj)

ptr->getX()
等价于
getX_Point3dFv(ptr)
```
2. 静态成员函数
  被转为非成员函数，不能访问非静态成员没有this指针
3. 虚成员函数
  (*ptr->vptr[1])(ptr) 通过拿到徐表中虚函数地址传入this指针来调用

#### 构造、拷贝、析构语义学

##### 构造函数的扩充

顺序： 先父类后成员最后自己的调用方式.

vptr的初始化在所有base 类构造之后，初始化列表之前（程序代码）
1. 虚基类的构造函数被调用从左到右从深到浅
2. 基类的构造函数被调用，按照基类的生命顺序
3. 设置vptr的指针初值，初始化虚函数表
4. 成员函数的初始化列表被放在构造偶函数内部以成员类的声明顺序,么有构造函数则调用合成的默认的构造函数
5. 构造自己，执行user code

##### 析构函数

按照上面相反的顺序调用
先自己析构然后类成员对象析构然后重置vptr然后基类析构然后虚基类析构

#### 拷贝构造

拷贝构造函数和拷贝复制运算符









