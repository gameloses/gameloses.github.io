---
title: ecs框架
comments: true
date: 2019-01-08 18:47:43
tags:
- 架构
categories:
- 架构
---

ECS即Entity-Component-System，实体-组件系统的意思，是一套游戏层的架构，是基于属性的游戏架构.出现很早，随着《守望先锋》架构设计与网络同步 -- GDC2017 而进入大众视野，unity2018版本直接内置了ecs,同时新起来的开源游戏引擎CLEngine也内置了ecs。google开源的https://github.com/sschmid/Entitas-CSharp/wiki也是一套ecs框架

#### 基本思想

| Entity    | 代表一个独立的个体。                                         |
| --------- | ------------------------------------------------------------ |
| Component | 一个个体某方面的数据，以及它与游戏世界的交互方法。           |
| System    | 持续地对Entity上与System对应的Component进行处理，每个System都有独立的更新 |

- Entity : 无数据无逻辑，单纯是一个实例，拥有若干Component

- Component：只有数据没有逻辑，可以被Entity动态添加和移除

- System：只有逻辑，只关心Component不关心Entity

- World：缓存所有Entity与Component，并对System进行轮询，负责整个系统的运转


#### ECS系统与传统OOP的区别

在OOP系统中，对象的状态是封装到个体中的，对象会提供一些手段来间接操作这些状态（

这样的系统其实并没有什么问题，但从游戏开发的角度来讲，当你把一切都封装好并良构之后，游戏设计师突然表示他需要一项和之前完全不一样的功能，而一般灾难都是从这里开始的。

我们现在知道ECS系统的特征是将状态（由Component提供）与行为（由System系统）进行分离，而Component之间是独立的，我们完全可以通过单独添加新的Component和System来添加新的功能而不修改任何代码，而这也是设计模式中策略模式的思想。



#### 实例

#####  Entity
```
// AddComponent的功能是在world中创建Component并且添加到该Entity的Component集合中。
public Entity bullet = new Entity(_entityID);
bullet.AddComponent(new TransformComponent());
bullet.AddComponent(new MoveComponent());
```

##### Component
```
class TransformComponent
｛
    Vector3 position;
    Vector3 rotation;
｝
class MoveComponent
｛
    Vector3 speed;
｝
```

##### System
```
class MoveSystem
｛
    public void Update(float time)
    ｛
        foreach(var movecomponent in movecomponents)
        ｛
            // 查找该Entity是否拥有TransformComponent
            var transformcomponent = movecomponent.sibling(TransformComponent())
            if(transformcomponent != null)
                transformcomponent.position += movecomponent.speed * time;
        ｝
    ｝
｝
```

- ECS 模型的结构是非常简洁明晰的，而且由于Component 中只有状态没有逻辑，可以很大的提高 Component 的复用度，以及同类 Component 在内存中是连续分布的，可以很大的提高缓存命中率（关于这点还在想该如何设计数据结构才能达到目的）
- 对于System需要使用的（整个 world 中唯一的）状态，遵循 System 中无状态的原则，使用 SingletonComponent 的方式去实现（参考 OW ECS 架构中的 SingletonComponent 部分）
- 将共享的 System 函数分解成 Utility ，减少调用，整合调用点
- 延迟执行（Deferment）的使用，即先缓存需要执行的状态，在更好的时间点集中调用（这点有很广泛的应用价值）

#### 例子2

假设我们有一个绘制函数，这个绘制函数就是一个System，它去会遍历所有带有physical和visible组件的entity，然后利用提供的信息来绘制。

visible组件内包含有“entity看起来应该是什么样”的信息，而physical组件提供绘制的位置。

再以碰撞检测为例子。System会遍历所有拥有物理Component的entity，然后对碰撞进行检测并在需要的时候产生对应的事件。



#### 为Unity设计的ECS系统（Entitas）

在Unity传统编程中，我们利用MonoBehavior来编写游戏



核心思想：将数据和行为分开。

- 在Unity中，我们将MonoBehavior组件放到GameObject中。但Entity系统中不同，Component被设计为附加到Entity上。
- 使用一个pool来包含所有Entity。通过pool我们可以看到所有的entity。
- 我们可以对entity进行分组，分组叫做group。之后我们可以通过指定的规则来区分不同的group，
- 这个规则叫做matcher，通过matcher可以方便地快速获得指定类型的entity。



#### cocos使用ecs

https://www.cnblogs.com/FuTaimeng/p/5572190.html


