---
title: cocos2dx 引用计数机制
comments: true
date: 2017-01-07 18:49:23
tags:
- cocos2dx
categories:
- cocos2dx
---

#### autorelease和release的区别 

  release是立即释放引用计数，如果到达0，对象被销毁。 

  autorelease是延迟释放，是为了更好管理内存产生的。



#### 关于Ref

一个Ref对象new之后，引用计数为1，retain（）执行+1,release()执行-1;

autorelease()只是将其放入了当前缓存池中及AutoReleasePool中。

```
class CC_DLL Ref
{
public:
    void retain();
    void release();
    Ref* autorelease();
    unsigned int getReferenceCount() const;
protected:
    Ref();
public:
    virtual ~Ref();
protected:
    unsigned int _referenceCount;
    friend class AutoreleasePool;   //友元可以访问与其有friend关系的类中的私有成员
};


Ref::Ref(): _referenceCount(1){}
void Ref::retain(){++_referenceCount;}


void Ref::release()   //引用计数较少 如果引用计数==0 则delete this
{
    --_referenceCount;
   if (_referenceCount == 0)
    {//如果一个对象在对象管理池中 但是引用计数为0  则此对象存在问题
\#if defined(COCOS2D_DEBUG) && (COCOS2D_DEBUG > 0)
        auto poolManager = PoolManager::getInstance();
        if (!poolManager->getCurrentPool()->isClearing() && poolManager->isObjectInPools(this))
        {
            CCASSERT(false, "The reference shouldn't be 0 because it is still in autorelease pool.");

        }
\#endif
        delete this;
    }
}


Ref* Ref::autorelease() //将对象放入当前管理池的最后
{
    PoolManager::getInstance()->getCurrentPool()->addObject(this);
    return this;

}
```



#### 关于AutoReleasePool

AutoreleasePool管理一个 std::vector<Ref*>列表，添加时只是放入vector 引用计数不发生变化，

clear（）遍历vector调用release()

```
class CC_DLL AutoreleasePool
{

public:
    AutoreleasePool();   //分配大小 入栈   _managedObjectArray.reserve(150); PoolManager::getInstance()->push(this);
    AutoreleasePool(const std::string &name);
    ~AutoreleasePool(); //清理 出栈 clear(); PoolManager::getInstance()->pop();
    void addObject(Ref *object);
    void clear();
    bool isClearing() const { return _isClearing; };
    bool contains(Ref* object) const;
    void dump();    
private:
    std::vector<Ref*>   _managedObjectArray;
    std::string _name;
    bool _isClearing;
};
```



#### 关于PoolManager

保存一个std::vector<AutoreleasePool*>以堆栈的形式进行管理。

```
class CC_DLL PoolManager
{
public:
    static PoolManager* getInstance(); //添加一个初始的AutoreleasePool  new AutoreleasePool("cocos2d autorelease pool");
    static void destroyInstance();
    AutoreleasePool *getCurrentPool() const;
    bool isObjectInPools(Ref* obj) const;
    friend class AutoreleasePool;
private:
    PoolManager();
    ~PoolManager();
    void push(AutoreleasePool *pool);
    void pop(); //弹出时访问栈顶的AutoreleasePool 
    static PoolManager* s_singleInstance; 
    std::vector<AutoreleasePool*> _releasePoolStack;
};
```

#### 如何清理

在每一帧绘制完成之后会执行清理工作。

```
mainLoop()
{
        drawScene();
        // release the objects
        PoolManager::getInstance()->getCurrentPool()->clear();

}
```

