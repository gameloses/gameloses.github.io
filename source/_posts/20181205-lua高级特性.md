---
title: lua高级特性
comments: true
date: 2018-12-05 19:52:56
tags:
- lua
categories:
- lua
excerpt: 涉及lua原表、尾递归、弱引用表、luastate、gc、源码解析、记录lua表访问赋值、lua面向对象等
---

1. 条件表达式

实现类似c++中a?b:c的效果。

a and b or c  -- a 为true则返回b or c, a为false则返回false

(a and b)or c -- a 为true则返回

2. 弱引用

元表 __mode字段来设置表k,v是弱引用，被弱引用table引用，垃圾回收时可回收，只要k,v被回收，整个条目会删除。

Lua采用了基于垃圾收集的内存管理机制，当某个table对象被存放在容器中，而容器的外部不再有任何变量引用该对象，对于这样的对象，Lua的垃圾收集器是不会清理的，因为容器对象仍然引用着他。见如下代码：

```
a = {}
key = {}
a[key] = 1
key = {}
a[key] = 2
collectgarbage()
for k,v inpairs(a) do print(v) end --输出1 2
```



![复制代码](http://note.youdao.com/src/5DE9982C6F844B22841E66D43A96E67E)

​    在执行垃圾收集之后，table a中的两个key都无法被清理，但是对value等于1的key而言，如果后面的逻辑不会遍历table a的话，那么我们就可以认为该对象内存泄露了。在Lua中提供了一种被称为弱引用table的机制，可以提示垃圾收集器，如果某个对象，如上面代码中的第一个table key，只是被弱引用table引用，那么在执行垃圾收集时可以将其清理。

​    Lua中的弱引用表提供了3中弱引用模式，即key是弱引用、value是弱引用，以及key和value均是弱引用。不论是哪种类型的弱引用table，只要有一个key或value被回收，那么它们所在的整个条目都会从table中删除。

​    一个table的弱引用类型是通过其元表的__mode字段来决定的。如果该值为包含字符"k"，那么table就是key弱引用，如果包含"v"，则是value若引用，如果两个字符均存在，就是key/value弱引用。见如下代码：

 1 a = {}

 2 b = {__mode = "k"}

 3setmetatable(a,b)

 4 key = {}

 5 a[key] = 1

 6 key = {}

 7 a[key] = 2

 8collectgarbage()

 9for k,v inpairs(a) do

10print(v)

11end

12--仅仅输出2

![复制代码](http://note.youdao.com/src/5DE9982C6F844B22841E66D43A96E67E)

​    在上面的代码示例中，第一个key在被存放到table a之后，就被第二个key的定义所覆盖，因此它的唯一引用来自key弱引用表。事实上，这种机制在Java中也同样存在，Java在1.5之后的版本中也提供了一组弱引用容器，其语义和Lua的弱引用table相似。

​    最后需要说明的是，Lua中的弱引用表只是作用于table类型的变量，对于其他类型的变量，如数值和字符串等，弱引用表并不起任何作用。

![img](http://note.youdao.com/src/3D93E1809F1242B98CB49B56896F7F36)

![img](http://note.youdao.com/src/0EEB7D1771464F09AB998AE5C04D31EC)

![img](http://note.youdao.com/src/0CB44C0AD62A43568F0D6E138877BD8C)

![img](http://note.youdao.com/src/78D8E70FC09A44B987325BADE5349886)

![img](http://note.youdao.com/src/7D22CEC95D2848599A731E5703DAEB01)

2.尾递归

什么是尾递归

尾递归的写法只是具备了使当前函数在调用下一个函数前把当前占有的栈销毁，但是会不会真的这样做，是要具体看编译器是否最终这样做。

什么是尾递归呢?(tail recursion), 顾名思议，就是一种“不一样的”递归，说到它的不一样，就得先说说一般的递归。对于一般的递归，比如下面的求阶乘，教科书上会告诉我们，如果这个函数调用的深度太深，很容易会有爆栈的危险。

![复制代码](http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336)

// 先不考虑溢出问题int func(int n) {     if (n <= 1) return1;      return (n * func(n-1)); }

![复制代码](http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336)

原因很多人的都知道，让我们先回顾一下函数调用的大概过程：

1）调用开始前，调用方（或函数本身）会往栈上压相关的数据，参数，返回地址，局部变量等。

2）执行函数。

3）清理栈上相关的数据，返回。

因此，在函数 A 执行的时候，如果在第二步中，它又调用了另一个函数 B，B 又调用 C.... 栈就会不断地增长不断地装入数据，当这个调用链很深的时候，栈很容易就满 了，这就是一般递归函数所容易面临的大问题。

而尾递归在某些语言的实现上，能避免上述所说的问题，注意是某些语言上，尾递归本身并不能消除函数调用栈过长的问题，那什么是尾递归呢？在上面写的一般递归函数 func() 中，我们可以看到，func(n)  是依赖于 func(n-1) 的，func(n) 只有在得到 func(n-1) 的结果之后，才能计算它自己的返回值，因此理论上，在 func(n-1) 返回之前，func(n)，不能结束返回。因此func(n)就必须保留它在栈上的数据，直到func(n-1)先返回，而尾递归的实现则可以在编译器的帮助下，消除这个限制：

![复制代码](http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336)

// 先不考虑溢出int tail_func(int n, int res) {      if (n <= 1) return res;       return tail_func(n - 1, n * res); }  // 像下面这样调用 tail_func(10000000000, 1);

![复制代码](http://note.youdao.com/src/E929234E8981423EAFC2A2A5B0969336)

从上可以看到尾递归把返回结果放到了调用的参数里。这个细小的变化导致，tail_func(n, res)不必像以前一样，非要等到拿到了tail_func(n-1, n*res)的返回值，才能计算它自己的返回结果 -- 它完全就等于tail_func(n-1, n*res)的返回值。因此理论上：tail_func(n)在调用tail_func(n-1)前，完全就可以先销毁自己放在栈上的东西。

这就是为什么尾递归如果在得到编译器的帮助下，是完全可以避免爆栈的原因：每一个函数在调用下一个函数之前，都能做到先把当前自己占用的栈给先释放了，尾递归的调用链上可以做到只有一个函数在使用栈，因此可以无限地调用！

所谓尾调用，就是一个函数返回另一个函数的返回值：

复制代码代码如下:



function f()

…

return g()

end

  

因为调用g()后，f()中不再执行任何代码，所以不需要保留f()的调用桟信息；Lua做了这样的优化，称为"尾调用消除"，g()返回后，控制点直接返回到调用f()的地方。

这种优化对尾递归非常有益，通常递归意味着调用桟的不断增长，甚至可能造成堆栈溢出；而尾递归提供了优化条件，编译器可以优化掉调用桟

![img](http://note.youdao.com/src/0ED3D9C5EDFC4F01A2DFB30A52209CCF)



3.元表相关

table存在两种行为：查询和修改（赋值），通过元方法__index和__newindex来改变table的这两种行为。

__index主要用于table的查询

table[key] 的访问过程，首先检查table表中是否存在key的字段，如果有则返回，否则检查是否有__index的元方法，没有返回nil,有则查找元方法。

__index元方法可以是一个函数，还可以是一个table。如果是一个函数，则以table和不存在的key作为参数方位该函数，

例如：__index = function(t,key)

如果是一个table时，就以相同的方式来访问这个table（即传入key访问元方法的table，如果存在则放回值，反之返回nil）

例如：__index = tab --此时会返回tab[key]的值

__index可以很好的实现具有默认值的table



function setDefaultValues(t,d)

​	local mt = {__index = function() return d end}

​	setmetatable(t, mt)

end

tab = {x=10,y=20}

print(tab.x ,tab.y,tab.z)	--由于没有设置元方法则为nil

setDefaultValues(tab,100)	--设置默认值（设置__index元方法）

print(tab.z)			--检查到有__index的元方法则返回默认值

__newindex主要用于table的更新

当对table中不存在的索引赋值时，解释器就会查找__newindex元方法。如果有这个元方法，就调用这个元方法，而不是执行复制。如果这个元方法是一个table，解释器就在table中进行赋值，而不是对原来的table。



local k = {}

local mt = {

​	__newindex = k

}

local t = {}

setmetatable(t, mt)

print("赋值前：")

for k,v in pairs(k) do

​	print(k ,v)

end

t[1] = 20

print("赋值后：t表中的值:")

for k,v in pairs(t) do

​	print(k ,v)

end



print("赋值后：k表中的值:")

for k,v in pairs(k) do

​	print(k ,v)

end



4.class的实现

子类在定义时复制所有基类的方法，在实例化时将该类作为metatable的__index赋值给实例。这就是cocos2dx里面的lua class的实现。



function class(classname, super)

​     local cls = {}

​     if super then --复制基类方法

​        cls = {}

​        for k,v in pairs(super) do cls[k] = v end

​        cls.super = super

​    else

​        cls = {ctor = function() end}

​    end



​    cls.__cname = classname

​    cls.__index = cls



​    function cls.new(...) --实例化

​        local instance = setmetatable({}, cls)

​        instance.class = cls

​        instance:ctor(...)

​        return instance

​    end

​    return cls

end

5.闭包实现

Lua使用闭包的扁平表示:

GC头部包含了垃圾回收信息；

闭包包含了一个指向原型的指针，原型包含了函数的所有静态信息：主要部分是函数编译之后的代码，其余包括参数个数、调试信息和其他类似的数据;

闭包还包含0个或多个指向upvalue的指针，每个upvalue表示一个由闭包使用的非局部变量.

![img](http://note.youdao.com/src/FF6FBB6589004740A5B86749709A7A3E)

 Lua闭包实现的核心部件是upvalue结构，它表示了一个闭包和一个变量的连接.

 用于访问upvalue的虚拟机指令有2条：GETUPVALUE将一个upvalue的值复制到寄存器；SETUPVALUE将一个寄存器的值复制到upvalue。

　一个upvalue有两种状态：open和closed。当一个upvalue被创建时，它是open的，并且它的指针指向Lua栈中对应的变量。当Lua关闭了一个upvalue，upvalue指向的值被复制到upvalue结构内部，并且指针也相应进行调整

 

6.table，string的实现

![img](http://note.youdao.com/src/F989FAE3253F481F82FC84C8284ADBE7)

lua中对基础数据类型使用统一的数据结构TValue表示，value_表示值，tt_表示数据类型。由此可知Value是一个union结构

对于nil,boolean,lightuserdata,number,cfunction这些数据类型的值都是直接存放在TValue中，其他类型的数据都用GCObject来表示，TValue中只是保存GCObject结构的指针



TString

1. /* 
2. ** creates a new string object 
3. */  
4. static TString *createstrobj (lua_State *L, const char *str, size_t l,  
5. ​                              int tag, unsigned int h, GCObject **list) {  
6.   TString *ts;  
7.   size_t totalsize;  /* total size of TString object */  
8.   totalsize = sizeof(TString) + ((l + 1) * sizeof(char));  
9.   ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;  
10.   ts->tsv.len = l;  
11.   ts->tsv.hash = h;  
12.   ts->tsv.extra = 0;  
13.   memcpy(ts+1, str, l*sizeof(char));  
14.   ((char *)(ts+1))[l] = '\0';  /* ending 0 */  
15.   return ts;  
16. }  

![img](http://note.youdao.com/src/EC2292CD831B47AD975575C6691C41EB)

​                                      图1-2

   从代码可以看出，字符串在lua的内存分配结构，如图1-2所示。lua字符串都自动加上结束符。

C代码  

1. /* 
2. ** new string (with explicit length) 
3. */  
4. TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {  
5.   if (l <= LUAI_MAXSHORTLEN)  /* short string? */  
6. ​    return internshrstr(L, str, l);  
7.   else {  
8. ​    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))  
9. ​      luaM_toobig(L);  
10. ​    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);  
11.   }  
12. }  

   

​    在实际中对字符串的使用大部分都是很短的，所以lua保存字符串分为短字符串和长字符串，短字符串都保存在全局的字符串hash表中，长字符串则放在全局的可gc对象列表中。

   static TString *internshrstr (lua_State *L, const char *str, size_t l) {  

1.   GCObject *o;  
2.   global_State *g = G(L);  
3.   unsigned int h = luaS_hash(str, l, g->seed);  
4.   for (o = g->strt.hash[lmod(h, g->strt.size)];  
5. ​       o != NULL;  
6. ​       o = gch(o)->next) {  
7. ​    TString *ts = rawgco2ts(o);  
8. ​    if (h == ts->tsv.hash &&  
9. ​        l == ts->tsv.len &&  
10. ​        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {  
11. ​      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */  
12. ​        changewhite(o);  /* resurrect it */  
13. ​      return ts;  
14. ​    }  
15.   }  
16.   return newshrstr(L, str, l, h);  /* not found; create a new string */  
17. }  

   

​    短字符串的hash表采用开放寻址hash算法，在处理一个短字符串的时候对首先判断字符串在hash表中是否已存在，存在则直接返回其地址；不存在则创建该字符串，并求出其hash值。长字符串则都重新分配内存保存。因此在对比两个字符串是否相等时，短字符串只要比较地址是否相等就行了，而对于长字符串则需要对比所有字符。由此可见lua中对于短字符串的处理很高效，一般用于字符串的比较，或者用作table的key。

  Table

  

![img](http://note.youdao.com/src/16471361C7A045F88883BCA7216834EE)



lua中的table是key-value的形式来存放数据的，table分为两部分：数组部分array和hash部分。array和sizearray为数组部分，node，lastfree，lsizenode为hash部分。



数组段和 hash 段两个部分。数字 key 一般放在数组段中，没有初始化过的 key 值全部设置为 nil 。当数字 key 过于离散的时候，部分较大的数字 key 会被移到 hash段中去。



key为你init

当key小于数组长度时，则直接返回数组中的值，否则计算key的hash值，从表的hash部分查找key的值。

当key为string

统一调用mainposition获取其hash值对应的散列地址.



当给table的key赋值的时候，会先查找key是否存在，如果存在则对value重新赋值，如果不存在则表示key也不存在，会调用luaH_newkey创建key，然后再对value赋值。在创建key的时候如果table的大小不够会触发rehash对表进行扩大。





7.gc相关

采用垃圾回收机制对所有的lua对象(GCObject)进行管理。Lua虚拟机会定期运行GC，释放掉已经不再被被引用到的lua对象。

基本算法【标记清除】

基本的垃圾回收算法被称为"mark-and-sweep"算法。算法本身其实很简单。

1.系统管理着所有已经创建了的对象。每个对象都有对其他对象的引用。

2.root集合代表着已知的系统级别的对象引用。

3.从root集合出发，就可以访问到系统引用到的所有对象。而没有被访问到的对象就是垃圾对象，需要被销毁。

我们可以将所有对象分成三个状态：

1. White状态，也就是待访问状态。表示对象还没有被垃圾回收的标记过程访问到。
2. Gray状态，也就是待扫描状态。表示对象已经被垃圾回收访问到了，但是对象本身对于其他对象的引用还没有进行遍历访问。
3. Black状态，也就是已扫描状态。表示对象已经被访问到了，并且也已经遍历了对象本身对其他对象的引用。

基本的算法可以描述如下：

1. 当前所有对象都是White状态;  
2. 将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  
3. while(Gray集合不为空)  
4. {  
5. ​    从Gray集合中移除一个对象O，并将O设置成Black状态;  
6. ​    for(O中每一个引用到的对象O1) {  
7. ​        if(O1在White状态) {  
8. ​            将O1从White设置成Gray，并放到到Gray集合中；  
9. ​        }  
10. ​    }  
11. }  
12. for(任意一个对象O){  
13. ​    if(O在White状态)  
14. ​        销毁对象O;  
15. ​    else  
16. ​        将O设置成White状态;  
17. }  

Incremental Garbage Collection

上面的算法如果一次性执行，在对象很多的情况下，会执行很长时间，严重影响程序本身的响应速度。其中一个解决办法就是，可以将上面的算法分步执行，这样每个步骤所耗费的时间就比较小了。我们可以将上述算法改为以下下几个步骤。

首先标识所有的root对象：

1. 当前所有对象都是White状态;  
2. 将root集合引用到的对象从White设置成Gray，并放到Gray集合中;  

遍历访问所有的gray对象。如果超出了本次计算量上限，退出等待下一次遍历:

1. while(Gray集合不为空,并且没有超过本次计算量的上限){  
2. ​    从Gray集合中移除一个对象O，并将O设置成Black状态;  
3. ​    for(O中每一个引用到的对象O1) {  
4. ​        if(O1在White状态) {  
5. ​            将O1从White设置成Gray，并放到到Gray集合中；  
6. ​        }  
7. ​    }  
8. }  

销毁垃圾对象：

1. for(任意一个对象O){  
2. ​    if(O在White状态)  
3. ​        销毁对象O;  
4. ​    else  
5. ​        将O设置成White状态;  
6. }  

在每个步骤之间，由于程序可以正常执行，所以会破坏当前对象之间的引用关系。black对象表示已经被扫描的对象，所以他应该不可能引用到一个white对象。当程序的改变使得一个black对象引用到一个white对象时，就会造成错误。解决这个问题的办法就是设置barrier。barrier在程序正常运行过程中，监控所有的引用改变。如果一个black对象需要引用一个white对象，存在两种处理办法：

1. 将white对象设置成gray，并添加到gray列表中等待扫描。这样等于帮助整个GC的标识过程向前推进了一步。
2. 将black对象该回成gray，并添加到gray列表中等待扫描。这样等于使整个GC的标识过程后退了一步。

这种垃圾回收方式被称为"Incremental Garbage Collection"(简称为"IGC"，Lua所采用的就是这种方法。使用"IGC"并不是没有代价的。IGC所检测出来的垃圾对象集合比实际的集合要小，也就是说，有些在GC过程中变成垃圾的对象，有可能在本轮GC中检测不到。不过，这些残余的垃圾对象一定会在下一轮GC被检测出来，不会造成泄露。

